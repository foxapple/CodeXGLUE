class MTransformationMatrix(object):
    """
    Manipulate the individual components of a transformation.
    """
    
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def asMatrix(*args, **kwargs):
        """
        Interpolates between the identity transformation and that currently in the object, returning the result as an MMatrix.
        """
    
        pass
    
    
    def asMatrixInverse(*args, **kwargs):
        """
        Returns the inverse of the matrix representing the transformation.
        """
    
        pass
    
    
    def asRotateMatrix(*args, **kwargs):
        """
        Returns the matrix which takes points from object space to the space immediately following the scale/shear/rotation transformations.
        """
    
        pass
    
    
    def asScaleMatrix(*args, **kwargs):
        """
        Returns the matrix which takes points from object space to the space immediately following scale and shear transformations.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Returns true if this transformation's matrix is within tolerance of another's matrix.
        """
    
        pass
    
    
    def reorderRotation(*args, **kwargs):
        """
        Reorders the transformation's rotate component to give the same overall rotation but using a new order or rotations.
        """
    
        pass
    
    
    def rotateBy(*args, **kwargs):
        """
        Adds to the transformation's rotation component.
        """
    
        pass
    
    
    def rotateByComponents(*args, **kwargs):
        """
        Adds to the transformation's rotation component.
        """
    
        pass
    
    
    def rotatePivot(*args, **kwargs):
        """
        Returns the transformation's rotate pivot component.
        """
    
        pass
    
    
    def rotatePivotTranslation(*args, **kwargs):
        """
        Returns the transformation's rotate pivot translation component.
        """
    
        pass
    
    
    def rotation(*args, **kwargs):
        """
        Returns the transformation's rotation component as either an Euler rotation or a quaternion.
        """
    
        pass
    
    
    def rotationComponents(*args, **kwargs):
        """
        Returns a list containing the four components of the transformation's rotate component.
        """
    
        pass
    
    
    def rotationOrder(*args, **kwargs):
        """
        Returns the order of rotations when the transformation's rotate component is expressed as an euler rotation.
        """
    
        pass
    
    
    def rotationOrientation(*args, **kwargs):
        """
        Returns a quaternion which orients the local rotation space.
        """
    
        pass
    
    
    def scale(*args, **kwargs):
        """
        Returns a list containing the transformation's scale components.
        """
    
        pass
    
    
    def scaleBy(*args, **kwargs):
        """
        Multiplies the transformation's scale components by the three floats in the provided sequence.
        """
    
        pass
    
    
    def scalePivot(*args, **kwargs):
        """
        Returns the transformation's scale pivot component.
        """
    
        pass
    
    
    def scalePivotTranslation(*args, **kwargs):
        """
        Returns the transformation's scale pivot translation component.
        """
    
        pass
    
    
    def setRotatePivot(*args, **kwargs):
        """
        Sets the transformation's rotate pivot component.
        """
    
        pass
    
    
    def setRotatePivotTranslation(*args, **kwargs):
        """
        Sets the transformation's rotate pivot translation component.
        """
    
        pass
    
    
    def setRotation(*args, **kwargs):
        """
        Sets the transformation's rotation component.
        """
    
        pass
    
    
    def setRotationComponents(*args, **kwargs):
        """
        Sets the transformation's rotate component from the four values in the provided sequence.
        """
    
        pass
    
    
    def setRotationOrientation(*args, **kwargs):
        """
        Sets a quaternion which orients the local rotation space.
        """
    
        pass
    
    
    def setScale(*args, **kwargs):
        """
        Sets the transformation's scale components to the three floats in the provided sequence.
        """
    
        pass
    
    
    def setScalePivot(*args, **kwargs):
        """
        Sets the transformation's scale pivot component.
        """
    
        pass
    
    
    def setScalePivotTranslation(*args, **kwargs):
        """
        Sets the transformation's scale pivot translation component.
        """
    
        pass
    
    
    def setShear(*args, **kwargs):
        """
        Sets the transformation's shear component.
        """
    
        pass
    
    
    def setToRotationAxis(*args, **kwargs):
        """
        Sets the transformation's rotate component to be a given axis vector and angle in radians.
        """
    
        pass
    
    
    def setTranslation(*args, **kwargs):
        """
        Sets the transformation's translation component.
        """
    
        pass
    
    
    def shear(*args, **kwargs):
        """
        Returns a list containing the transformation's shear components.
        """
    
        pass
    
    
    def shearBy(*args, **kwargs):
        """
        Multiplies the transformation's shear components by the three floats in the provided sequence.
        """
    
        pass
    
    
    def translateBy(*args, **kwargs):
        """
        Adds a vector to the transformation's translation component.
        """
    
        pass
    
    
    def translation(*args, **kwargs):
        """
        Returns the transformation's translation component as a vector.
        """
    
        pass
    
    
    __new__ = None
    
    
    kIdentity = None
    
    
    kInvalid = 0
    
    
    kLast = 7
    
    
    kTolerance = 1e-10
    
    
    kXYZ = 1
    
    
    kXZY = 4
    
    
    kYXZ = 5
    
    
    kYZX = 2
    
    
    kZXY = 3
    
    
    kZYX = 6


class MSyntax(object):
    """
    Syntax for commands.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addArg(*args, **kwargs):
        """
        Add a command argument.
        """
    
        pass
    
    
    def addFlag(*args, **kwargs):
        """
        Add a flag and its arguments.
        """
    
        pass
    
    
    def makeFlagMultiUse(*args, **kwargs):
        """
        Set whether a flag may be used multiple times on the command line.
        """
    
        pass
    
    
    def makeFlagQueryWithFullArgs(*args, **kwargs):
        """
        Set whether a flag requires its args when queried.
        """
    
        pass
    
    
    def maxObjects(*args, **kwargs):
        """
        Returns the maximum number of objects which can be passed to the command.
        """
    
        pass
    
    
    def minObjects(*args, **kwargs):
        """
        Returns the minimum number of objects which can be passed to the command.
        """
    
        pass
    
    
    def setMaxObjects(*args, **kwargs):
        """
        Sets the maximum number of objects which can be passed to the command.
        """
    
        pass
    
    
    def setMinObjects(*args, **kwargs):
        """
        Sets the minimum number of objects which can be passed to the command.
        """
    
        pass
    
    
    def setObjectType(*args, **kwargs):
        """
        Set the type and number of objects to be passed to the command.
        """
    
        pass
    
    
    def useSelectionAsDefault(*args, **kwargs):
        """
        If set to True then when no objects are provided on the command-line Maya will pass the current selection instead.
        """
    
        pass
    
    
    enableEdit = None
    
    enableQuery = None
    
    __new__ = None
    
    
    kAngle = 8
    
    
    kBoolean = 2
    
    
    kDistance = 7
    
    
    kDouble = 4
    
    
    kInvalidArgType = 0
    
    
    kInvalidObjectFormat = 0
    
    
    kLastArgType = 11
    
    
    kLastObjectFormat = 4
    
    
    kLong = 3
    
    
    kNoArg = 1
    
    
    kNone = 1
    
    
    kSelectionItem = 10
    
    
    kSelectionList = 3
    
    
    kString = 5
    
    
    kStringObjects = 2
    
    
    kTime = 9
    
    
    kUnsigned = 6


class MDoubleArray(object):
    """
    Array of double values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MFnBase(object):
    """
    Base class for function sets.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def hasObj(*args, **kwargs):
        """
        Returns True if the function set is compatible with the specified Maya object.
        """
    
        pass
    
    
    def object(*args, **kwargs):
        """
        Returns a reference to the object to which the function set is currently attached, or MObject.kNullObj if none.
        """
    
        pass
    
    
    def setObject(*args, **kwargs):
        """
        Attaches the function set to the specified Maya object.
        """
    
        pass
    
    
    def type(*args, **kwargs):
        """
        Returns the type of the function set.
        """
    
        pass
    
    
    __new__ = None


class MAttributePattern(object):
    """
    Manipulate attribute structure patterns.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def addRootAttr(*args, **kwargs):
        """
        Add the given root attribute to this pattern.
        """
    
        pass
    
    
    def name(*args, **kwargs):
        """
        Return the name of the attribute pattern.
        """
    
        pass
    
    
    def removeRootAttr(*args, **kwargs):
        """
        Return the nth or passed-in root attribute from this pattern.
        """
    
        pass
    
    
    def rootAttr(*args, **kwargs):
        """
        Return the nth root attribute in this pattern.
        """
    
        pass
    
    
    def rootAttrCount(*args, **kwargs):
        """
        Return the number of root attributes in this pattern.
        """
    
        pass
    
    
    def attrPattern(*args, **kwargs):
        """
        Return the specified pattern indexed from the global list.
        """
    
        pass
    
    
    def attrPatternCount(*args, **kwargs):
        """
        Return the global number of patterns created.
        """
    
        pass
    
    
    def findPattern(*args, **kwargs):
        """
        Return a pattern with the given name, None if not found.
        """
    
        pass
    
    
    __new__ = None


class MFloatVectorArray(object):
    """
    Array of MFloatVector values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MAngle(object):
    """
    Manipulate angular data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def asAngMinutes(*args, **kwargs):
        """
        Returns the angular value, converted to minutes of arc.
        """
    
        pass
    
    
    def asAngSeconds(*args, **kwargs):
        """
        Returns the angular value, converted to seconds of arc.
        """
    
        pass
    
    
    def asDegrees(*args, **kwargs):
        """
        Returns the angular value, converted to degrees.
        """
    
        pass
    
    
    def asRadians(*args, **kwargs):
        """
        Returns the angular value, converted to radians.
        """
    
        pass
    
    
    def asUnits(*args, **kwargs):
        """
        Returns the angular value, converted to the specified units.
        """
    
        pass
    
    
    def internalToUI(*args, **kwargs):
        """
        Converts a value from Maya's internal units to the units used in the UI.
        """
    
        pass
    
    
    def internalUnit(*args, **kwargs):
        """
        Returns the angular unit used internally by Maya.
        """
    
        pass
    
    
    def setUIUnit(*args, **kwargs):
        """
        Sets the angular unit used in Maya's UI.
        """
    
        pass
    
    
    def uiToInternal(*args, **kwargs):
        """
        Converts a value from the units used in the UI to Maya's internal units.
        """
    
        pass
    
    
    def uiUnit(*args, **kwargs):
        """
        Returns the units used to display angles in Maya's UI.
        """
    
        pass
    
    
    unit = None
    
    value = None
    
    __new__ = None
    
    
    kAngMinutes = 3
    
    
    kAngSeconds = 4
    
    
    kDegrees = 2
    
    
    kInvalid = 0
    
    
    kLast = 5
    
    
    kRadians = 1


class MEulerRotation(object):
    """
    X, Y and Z rotations, applied in a specified order.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __neg__(*args, **kwargs):
        """
        x.__neg__() <==> -x
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def alternateSolution(*args, **kwargs):
        """
        Returns an equivalent rotation which is not simply a multiple.
        """
    
        pass
    
    
    def asMatrix(*args, **kwargs):
        """
        Returns the rotation as an equivalent matrix.
        """
    
        pass
    
    
    def asQuaternion(*args, **kwargs):
        """
        Returns the rotation as an equivalent quaternion.
        """
    
        pass
    
    
    def asVector(*args, **kwargs):
        """
        Returns the X, Y and Z rotations as a vector.
        """
    
        pass
    
    
    def bound(*args, **kwargs):
        """
        Returns a new MEulerRotation having this rotation, but with each rotation component bound within +/- PI.
        """
    
        pass
    
    
    def boundIt(*args, **kwargs):
        """
        In-place bounding of each rotation component to lie wthin +/- PI.
        """
    
        pass
    
    
    def closestCut(*args, **kwargs):
        """
        Returns the rotation which is full spin multiples of this one and comes closest to target.
        """
    
        pass
    
    
    def closestSolution(*args, **kwargs):
        """
        Returns the equivalent rotation which comes closest to a target.
        """
    
        pass
    
    
    def incrementalRotateBy(*args, **kwargs):
        """
        Increase this rotation by a given angle around the specified axis. The update is done in series of small increments to avoid flipping.
        """
    
        pass
    
    
    def inverse(*args, **kwargs):
        """
        Returns a new MEulerRotation containing the inverse rotation of this one and reversed rotation order.
        """
    
        pass
    
    
    def invertIt(*args, **kwargs):
        """
        In-place inversion of the rotation. Rotation order is also reversed.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Returns true if this rotation has the same order as another and their X, Y and Z components are within a tolerance of each other.
        """
    
        pass
    
    
    def isZero(*args, **kwargs):
        """
        Returns true if the X, Y and Z components are each within a tolerance of 0.0.
        """
    
        pass
    
    
    def reorder(*args, **kwargs):
        """
        Returns a new MEulerRotation having this rotation, reordered to use the given rotation order.
        """
    
        pass
    
    
    def reorderIt(*args, **kwargs):
        """
        In-place reordering to use the given rotation order.
        """
    
        pass
    
    
    def setToAlternateSolution(*args, **kwargs):
        """
        Replace this rotation with an alternate solution.
        """
    
        pass
    
    
    def setToClosestCut(*args, **kwargs):
        """
        Replace this rotation with the closest cut to a target.
        """
    
        pass
    
    
    def setToClosestSolution(*args, **kwargs):
        """
        Replace this rotation with the closest solution to a target.
        """
    
        pass
    
    
    def setValue(*args, **kwargs):
        """
        Set the rotation.
        """
    
        pass
    
    
    def computeAlternateSolution(*args, **kwargs):
        """
        Returns an equivalent rotation which is not simply a multiple.
        """
    
        pass
    
    
    def computeBound(*args, **kwargs):
        """
        Returns an equivalent rotation with each rotation component bound within +/- PI.
        """
    
        pass
    
    
    def computeClosestCut(*args, **kwargs):
        """
        Returns the rotation which is full spin multiples of the src and comes closest to target.
        """
    
        pass
    
    
    def computeClosestSolution(*args, **kwargs):
        """
        Returns the equivalent rotation which comes closest to a target.
        """
    
        pass
    
    
    def decompose(*args, **kwargs):
        """
        Extracts a rotation from a matrix.
        """
    
        pass
    
    
    order = None
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kIdentity = None
    
    
    kTolerance = 1e-10
    
    
    kXYZ = 0
    
    
    kXZY = 3
    
    
    kYXZ = 4
    
    
    kYZX = 1
    
    
    kZXY = 2
    
    
    kZYX = 5


class MBoundingBox(object):
    """
    3D axis-aligned bounding box.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Empties the bounding box, setting its corners to (0, 0, 0).
        """
    
        pass
    
    
    def contains(*args, **kwargs):
        """
        Returns True if a point lies within the bounding box.
        """
    
        pass
    
    
    def expand(*args, **kwargs):
        """
        Expands the bounding box to include a point or other bounding box.
        """
    
        pass
    
    
    def intersects(*args, **kwargs):
        """
        Returns True if any part of a given bounding box lies within this one.
        """
    
        pass
    
    
    def transformUsing(*args, **kwargs):
        """
        Multiplies the bounding box's corners by a matrix.
        """
    
        pass
    
    
    center = None
    
    depth = None
    
    height = None
    
    max = None
    
    min = None
    
    width = None
    
    __new__ = None


class MUint64Array(object):
    """
    Array of MUint64 values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MIntArray(object):
    """
    Array of int values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MDistance(object):
    """
    Manipulate distance data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def asCentimeters(*args, **kwargs):
        """
        Return the distance value, converted to centimeters.
        """
    
        pass
    
    
    def asFeet(*args, **kwargs):
        """
        Return the distance value, converted to feet.
        """
    
        pass
    
    
    def asInches(*args, **kwargs):
        """
        Return the distance value, converted to inches.
        """
    
        pass
    
    
    def asKilometers(*args, **kwargs):
        """
        Return the distance value, converted to kilometers.
        """
    
        pass
    
    
    def asMeters(*args, **kwargs):
        """
        Return the distance value, converted to meters.
        """
    
        pass
    
    
    def asMiles(*args, **kwargs):
        """
        Return the distance value, converted to miles.
        """
    
        pass
    
    
    def asMillimeters(*args, **kwargs):
        """
        Return the distance value, converted to millimeters.
        """
    
        pass
    
    
    def asUnits(*args, **kwargs):
        """
        Return the distance value, converted to the specified units.
        """
    
        pass
    
    
    def asYards(*args, **kwargs):
        """
        Return the distance value, converted to yards.
        """
    
        pass
    
    
    def internalToUI(*args, **kwargs):
        """
        Convert a value from Maya's internal units to the units used in the UI.
        """
    
        pass
    
    
    def internalUnit(*args, **kwargs):
        """
        Return the distance unit used internally by Maya.
        """
    
        pass
    
    
    def setUIUnit(*args, **kwargs):
        """
        Change the units used to display distances in Maya's UI.
        """
    
        pass
    
    
    def uiToInternal(*args, **kwargs):
        """
        Convert a value from the units used in the UI to Maya's internal units.
        """
    
        pass
    
    
    def uiUnit(*args, **kwargs):
        """
        Return the units used to display distances in Maya's UI.
        """
    
        pass
    
    
    unit = None
    
    value = None
    
    __new__ = None
    
    
    kCentimeters = 6
    
    
    kFeet = 2
    
    
    kInches = 1
    
    
    kInvalid = 0
    
    
    kKilometers = 7
    
    
    kLast = 9
    
    
    kMeters = 8
    
    
    kMiles = 4
    
    
    kMillimeters = 5
    
    
    kYards = 3


class MUintArray(object):
    """
    Array of unsigned int values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MMatrix(object):
    """
    4x4 matrix with double-precision elements.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def adjoint(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's adjoint.
        """
    
        pass
    
    
    def det3x3(*args, **kwargs):
        """
        Returns the determinant of the 3x3 matrix formed by the first 3 elements of the first 3 rows of this matrix.
        """
    
        pass
    
    
    def det4x4(*args, **kwargs):
        """
        Returns this matrix's determinant.
        """
    
        pass
    
    
    def getElement(*args, **kwargs):
        """
        Returns the matrix element for the specified row and column.
        """
    
        pass
    
    
    def homogenize(*args, **kwargs):
        """
        Returns a new matrix containing the homogenized version of this matrix.
        """
    
        pass
    
    
    def inverse(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's inverse.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Test for equivalence of two matrices, within a tolerance.
        """
    
        pass
    
    
    def isSingular(*args, **kwargs):
        """
        Returns True if this matrix is singular.
        """
    
        pass
    
    
    def setElement(*args, **kwargs):
        """
        Sets the matrix element for the specified row and column.
        """
    
        pass
    
    
    def setToIdentity(*args, **kwargs):
        """
        Sets this matrix to the identity.
        """
    
        pass
    
    
    def setToProduct(*args, **kwargs):
        """
        Sets this matrix to the product of the two matrices passed in.
        """
    
        pass
    
    
    def transpose(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's transpose.
        """
    
        pass
    
    
    __new__ = None
    
    
    kIdentity = None
    
    
    kTolerance = 1e-10


class MDagPath(object):
    """
    Path to a DAG node from the top of the DAG.
    """
    
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def apiType(*args, **kwargs):
        """
        Returns the type of the object at the end of the path.
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        Returns the specified child of the object at the end of the path.
        """
    
        pass
    
    
    def childCount(*args, **kwargs):
        """
        Returns the number of objects parented directly beneath the object at the end of the path.
        """
    
        pass
    
    
    def exclusiveMatrix(*args, **kwargs):
        """
        Returns the matrix for all transforms in the path, excluding the end object.
        """
    
        pass
    
    
    def exclusiveMatrixInverse(*args, **kwargs):
        """
        Returns the inverse of exclusiveMatrix().
        """
    
        pass
    
    
    def extendToShape(*args, **kwargs):
        """
        Extends the path to the specified shape node parented directly beneath the transform at the current end of the path.
        """
    
        pass
    
    
    def fullPathName(*args, **kwargs):
        """
        Returns a string representation of the path from the DAG root to the path's last node.
        """
    
        pass
    
    
    def getPath(*args, **kwargs):
        """
        Returns the specified sub-path of this path.
        """
    
        pass
    
    
    def hasFn(*args, **kwargs):
        """
        Returns True if the object at the end of the path supports the given function set.
        """
    
        pass
    
    
    def inclusiveMatrix(*args, **kwargs):
        """
        Returns the matrix for all transforms in the path, including the end object, if it is a transform.
        """
    
        pass
    
    
    def inclusiveMatrixInverse(*args, **kwargs):
        """
        Returns the inverse of inclusiveMatrix().
        """
    
        pass
    
    
    def instanceNumber(*args, **kwargs):
        """
        Returns the instance number of this path to the object at the end.
        """
    
        pass
    
    
    def isInstanced(*args, **kwargs):
        """
        Returns True if the object at the end of the path can be reached by more than one path.
        """
    
        pass
    
    
    def isTemplated(*args, **kwargs):
        """
        Returns true if the DAG Node at the end of the path is templated.
        """
    
        pass
    
    
    def isValid(*args, **kwargs):
        """
        Returns True if this is a valid path.
        """
    
        pass
    
    
    def isVisible(*args, **kwargs):
        """
        Returns true if the DAG Node at the end of the path is visible.
        """
    
        pass
    
    
    def length(*args, **kwargs):
        """
        Returns the number of nodes on the path, not including the DAG's root node.
        """
    
        pass
    
    
    def node(*args, **kwargs):
        """
        Returns the DAG node at the end of the path.
        """
    
        pass
    
    
    def numberOfShapesDirectlyBelow(*args, **kwargs):
        """
        Returns the number of shape nodes parented directly beneath the transform at the end of the path.
        """
    
        pass
    
    
    def partialPathName(*args, **kwargs):
        """
        Returns the minimum string representation which will uniquely identify the path.
        """
    
        pass
    
    
    def pathCount(*args, **kwargs):
        """
        Returns the number of sub-paths which make up this path.
        """
    
        pass
    
    
    def pop(*args, **kwargs):
        """
        Removes objects from the end of the path.
        """
    
        pass
    
    
    def push(*args, **kwargs):
        """
        Extends the path to the specified child object, which must be parented directly beneath the object currently at the end of the path.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Replaces the current path held by this object with another.
        """
    
        pass
    
    
    def transform(*args, **kwargs):
        """
        Returns the last transform node on the path.
        """
    
        pass
    
    
    def getAPathTo(*args, **kwargs):
        """
        Returns the first path found to the given node.
        """
    
        pass
    
    
    def getAllPathsTo(*args, **kwargs):
        """
        Returns all paths to the given node.
        """
    
        pass
    
    
    __new__ = None


class MTime(object):
    """
    Manipulate time data.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __idiv__(*args, **kwargs):
        """
        x.__idiv__(y) <==> x/=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def asUnits(*args, **kwargs):
        """
        Return the time value, converted to the specified units.
        """
    
        pass
    
    
    def setUIUnit(*args, **kwargs):
        """
        Change the units used to display time in Maya's UI.
        """
    
        pass
    
    
    def uiUnit(*args, **kwargs):
        """
        Return the units used to display time in Maya's UI.
        """
    
        pass
    
    
    unit = None
    
    value = None
    
    __new__ = None
    
    
    k100FPS = 25
    
    
    k10FPS = 18
    
    
    k1200FPS = 38
    
    
    k120FPS = 26
    
    
    k125FPS = 27
    
    
    k12FPS = 19
    
    
    k1500FPS = 39
    
    
    k150FPS = 28
    
    
    k16FPS = 20
    
    
    k2000FPS = 40
    
    
    k200FPS = 29
    
    
    k20FPS = 21
    
    
    k240FPS = 30
    
    
    k250FPS = 31
    
    
    k2FPS = 12
    
    
    k3000FPS = 41
    
    
    k300FPS = 32
    
    
    k375FPS = 33
    
    
    k3FPS = 13
    
    
    k400FPS = 34
    
    
    k40FPS = 22
    
    
    k4FPS = 14
    
    
    k500FPS = 35
    
    
    k5FPS = 15
    
    
    k6000FPS = 42
    
    
    k600FPS = 36
    
    
    k6FPS = 16
    
    
    k750FPS = 37
    
    
    k75FPS = 23
    
    
    k80FPS = 24
    
    
    k8FPS = 17
    
    
    kFilm = 6
    
    
    kGames = 5
    
    
    kHours = 1
    
    
    kInvalid = 0
    
    
    kLast = 44
    
    
    kMilliseconds = 4
    
    
    kMinutes = 2
    
    
    kNTSCField = 11
    
    
    kNTSCFrame = 8
    
    
    kPALField = 10
    
    
    kPALFrame = 7
    
    
    kSeconds = 3
    
    
    kShowScan = 9
    
    
    kUserDef = 43


class MMeshIsectAccelParams(object):
    """
    Opaque class used to store parameters used by MFnMesh's
    intersection calculations for later re-use.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    __new__ = None


class MFloatArray(object):
    """
    Array of float values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MVector(object):
    """
    3D vector with double-precision coordinates.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __idiv__(*args, **kwargs):
        """
        x.__idiv__(y) <==> x/=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __neg__(*args, **kwargs):
        """
        x.__neg__() <==> -x
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __rxor__(*args, **kwargs):
        """
        x.__rxor__(y) <==> y^x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def __xor__(*args, **kwargs):
        """
        x.__xor__(y) <==> x^y
        """
    
        pass
    
    
    def angle(*args, **kwargs):
        """
        Returns the angle, in radians, between this vector and another.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Returns True if this vector and another are within a given tolerance of being equal.
        """
    
        pass
    
    
    def isParallel(*args, **kwargs):
        """
        Returns True if this vector and another are within the given tolerance of being parallel.
        """
    
        pass
    
    
    def length(*args, **kwargs):
        """
        Returns the magnitude of this vector.
        """
    
        pass
    
    
    def normal(*args, **kwargs):
        """
        Returns a new vector containing the normalized version of this one.
        """
    
        pass
    
    
    def normalize(*args, **kwargs):
        """
        Normalizes this vector in-place and returns a new reference to it.
        """
    
        pass
    
    
    def rotateBy(*args, **kwargs):
        """
        Returns the vector resulting from rotating this one by the given amount.
        """
    
        pass
    
    
    def rotateTo(*args, **kwargs):
        """
        Returns the quaternion which will rotate this vector into another.
        """
    
        pass
    
    
    def transformAsNormal(*args, **kwargs):
        """
        Returns a new vector which is calculated by postmultiplying this vector by the transpose of the given matrix's inverse and then normalizing the result.
        """
    
        pass
    
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kOneVector = None
    
    
    kTolerance = 1e-10
    
    
    kWaxis = 3
    
    
    kXaxis = 0
    
    
    kXaxisVector = None
    
    
    kXnegAxisVector = None
    
    
    kYaxis = 1
    
    
    kYaxisVector = None
    
    
    kYnegAxisVector = None
    
    
    kZaxis = 2
    
    
    kZaxisVector = None
    
    
    kZeroVector = None
    
    
    kZnegAxisVector = None


class MDGModifier(object):
    """
    Used to change the structure of the dependency graph.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addAttribute(*args, **kwargs):
        """
        addAttribute(MObject node, MObject attribute) -> self
        
        Adds an operation to the modifier to add a new dynamic attribute to the
        given dependency node. If the attribute is a compound its children will
        be added as well, so only the parent needs to be added using this method.
        """
    
        pass
    
    
    def addExtensionAttribute(*args, **kwargs):
        """
        addExtensionAttribute(MNodeClass nodeClass, MObject attribute) -> self
        
        Adds an operation to the modifier to add a new extension attribute to
        the given node class. If the attribute is a compound its children will be
        added as well, so only the parent needs to be added using this method.
        """
    
        pass
    
    
    def commandToExecute(*args, **kwargs):
        """
        commandToExecute(command) -> self
        
        Adds an operation to the modifier to execute a MEL command. The specified
        command must be undoable otherwise unexpected results may occur. It is
        best to use multiple commandToExecute() calls rather than batching
        multiple commands into one call to commandToExecute(). They will still
        be undone together, as a single undo action by the user, but Maya will
        better be able to recover if one of the commands fails.
        """
    
        pass
    
    
    def connect(*args, **kwargs):
        """
        connect(MPlug source, MPlug dest) -> self
        connect(MObject sourceNode, MObject sourceAttr,
                MObject destNode,   MObject destAttr) -> self
        
        Adds an operation to the modifier that connects two plugs in the
        dependency graph. It is the user's responsibility to ensure that the
        source and destination attributes are of compatible types. For instance,
        if the source attribute is a nurbs surface then the destination must
        also be a nurbs surface.
        Plugs can either be specified with node and attribute MObjects or with
        MPlugs.
        """
    
        pass
    
    
    def createNode(*args, **kwargs):
        """
        createNode(typeName) -> MObject
        createNode(MTypeId typeId) -> MObject
        
        Adds an operation to the modifier to create a node of the given type.
        The new node is created and returned but will not be added to the
        Dependency Graph until the modifier's doIt() method is called. Raises
        TypeError if the named node type does not exist or if it is a DAG node
        type.
        """
    
        pass
    
    
    def deleteNode(*args, **kwargs):
        """
        deleteNode(MObject node) -> self
        
        Adds an operation to the modifer which deletes the specified node from
        the Dependency Graph. If the modifier already contains other operations
        on the same node (e.g. a disconnect) then they should be committed by
        calling the modifier's doIt() before the deleteNode operation is added.
        """
    
        pass
    
    
    def disconnect(*args, **kwargs):
        """
        disconnect(MPlug source, MPlug dest) -> self
        disconnect(MObject sourceNode, MObject sourceAttr,
                   MObject destNode,   MObject destAttr) -> self
        
        Adds an operation to the modifier that breaks a connection between two
        plugs in the dependency graph.
        Plugs can either be specified with node and attribute MObjects or with
        MPlugs.
        """
    
        pass
    
    
    def doIt(*args, **kwargs):
        """
        doIt() -> self
        
        Executes the modifier's operations. If doIt() is called multiple times
        in a row, without any intervening calls to undoIt(), then only the
        operations which were added since the previous doIt() call will be
        executed. If undoIt() has been called then the next call to doIt() will
        do all operations.
        """
    
        pass
    
    
    def linkExtensionAttributeToPlugin(*args, **kwargs):
        """
        linkExtensionAttributeToPlugin(MObject plugin, MObject attribute) -> self
        
        The plugin can call this method to indicate that the extension attribute
        defines part of the plugin, regardless of the node type to which it
        attaches itself. This requirement is used when the plugin is checked to
        see if it is in use or if is able to be unloaded or if it is required as
        part of a stored file. For compound attributes only the topmost parent
        attribute may be passed in and all of its children will be included,
        recursively. Thus it's not possible to link a child attribute to a
        plugin by itself. Note that the link is established immediately and is
        not affected by the modifier's doIt() or undoIt() methods.
        """
    
        pass
    
    
    def newPlugValue(*args, **kwargs):
        """
        newPlugValue(MPlug plug, MObject value) -> self
        
        Adds an operation to the modifier to set the value of a plug, where
        value is an MObject data wrapper, such as created by the various
        MFn*Data classes.
        """
    
        pass
    
    
    def newPlugValueBool(*args, **kwargs):
        """
        newPlugValueBool(MPlug plug, bool value) -> self
        
        Adds an operation to the modifier to set a value onto a bool plug.
        """
    
        pass
    
    
    def newPlugValueChar(*args, **kwargs):
        """
        newPlugValueChar(MPlug plug, int value) -> self
        
        Adds an operation to the modifier to set a value onto a char (single
        byte signed integer) plug.
        """
    
        pass
    
    
    def newPlugValueDouble(*args, **kwargs):
        """
        newPlugValueDouble(MPlug plug, float value) -> self
        
        Adds an operation to the modifier to set a value onto a double-precision
        float plug.
        """
    
        pass
    
    
    def newPlugValueFloat(*args, **kwargs):
        """
        newPlugValueFloat(MPlug plug, float value) -> self
        
        Adds an operation to the modifier to set a value onto a single-precision
        float plug.
        """
    
        pass
    
    
    def newPlugValueInt(*args, **kwargs):
        """
        newPlugValueInt(MPlug plug, int value) -> self
        
        Adds an operation to the modifier to set a value onto an int plug.
        """
    
        pass
    
    
    def newPlugValueMAngle(*args, **kwargs):
        """
        newPlugValueMAngle(MPlug plug, MAngle value) -> self
        
        Adds an operation to the modifier to set a value onto an angle plug.
        """
    
        pass
    
    
    def newPlugValueMDistance(*args, **kwargs):
        """
        newPlugValueMDistance(MPlug plug, MDistance value) -> self
        
        Adds an operation to the modifier to set a value onto a distance plug.
        """
    
        pass
    
    
    def newPlugValueMTime(*args, **kwargs):
        """
        newPlugValueMTime(MPlug plug, MTime value) -> self
        
        Adds an operation to the modifier to set a value onto a time plug.
        """
    
        pass
    
    
    def newPlugValueShort(*args, **kwargs):
        """
        newPlugValueShort(MPlug plug, int value) -> self
        
        Adds an operation to the modifier to set a value onto a short
        integer plug.
        """
    
        pass
    
    
    def newPlugValueString(*args, **kwargs):
        """
        newPlugValueString(MPlug plug, string value) -> self
        
        Adds an operation to the modifier to set a value onto a string plug.
        """
    
        pass
    
    
    def removeAttribute(*args, **kwargs):
        """
        removeAttribute(MObject node, MObject attribute) -> self
        
        Adds an operation to the modifier to remove a dynamic attribute from the
        given dependency node. If the attribute is a compound its children will
        be removed as well, so only the parent needs to be removed using this
        method. The attribute MObject passed in will be set to kNullObj. There
        should be no function sets attached to the attribute at the time of the
        call as their behaviour may become unpredictable.
        """
    
        pass
    
    
    def removeExtensionAttribute(*args, **kwargs):
        """
        removeExtensionAttribute(MNodeClass nodeClass, MObject attribute) -> self
        
        Adds an operation to the modifier to remove an extension attribute from
        the given node class. If the attribute is a compound its children will
        be removed as well, so only the parent needs to be removed using this
        method. The attribute MObject passed in will be set to kNullObj. There
        should be no function sets attached to the attribute at the time of the
        call as their behaviour may become unpredictable.
        """
    
        pass
    
    
    def removeExtensionAttributeIfUnset(*args, **kwargs):
        """
        removeExtensionAttributeIfUnset(MNodeClass nodeClass,
                                        MObject attribute) -> self
        
        Adds an operation to the modifier to remove an extension attribute from
        the given node class, but only if there are no nodes in the graph with
        non-default values for this attribute. If the attribute is a compound
        its children will be removed as well, so only the parent needs to be
        removed using this method. The attribute MObject passed in will be set
        to kNullObj. There should be no function sets attached to the attribute
        at the time of the call as their behaviour may become unpredictable.
        """
    
        pass
    
    
    def renameNode(*args, **kwargs):
        """
        renameNode(MObject node, string newName) -> self
        
        Adds an operation to the modifer to rename a node.
        """
    
        pass
    
    
    def setNodeLockState(*args, **kwargs):
        """
        setNodeLockState(MObject node, bool newState) -> self
        
        Adds an operation to the modifier to set the lockState of a node.
        """
    
        pass
    
    
    def undoIt(*args, **kwargs):
        """
        undoIt() -> self
        
        Undoes all of the operations that have been given to this modifier. It
        is only valid to call this method after the doIt() method has been
        called.
        """
    
        pass
    
    
    def unlinkExtensionAttributeFromPlugin(*args, **kwargs):
        """
        unlinkExtensionAttributeFromPlugin(MObject plugin,
                                           MObject attribute) -> self
        
        The plugin can call this method to indicate that it no longer requires
        an extension attribute for its operation. This requirement is used when
        the plugin is checked to see if it is in use or if is able to be unloaded
        or if it is required as part of a stored file. For compound attributes
        only the topmost parent attribute may be passed in and all of its
        children will be unlinked, recursively. Thus it's not possible to unlink
        a child attribute from a plugin by itself. Note that the link is broken
        immediately and is not affected by the modifier's doIt() or undoIt()
        methods.
        """
    
        pass
    
    
    __new__ = None


class MSpace(object):
    """
    Static class providing coordinate space constants.
    """
    
    
    
    kInvalid = 0
    
    
    kLast = 5
    
    
    kObject = 2
    
    
    kPostTransform = 3
    
    
    kPreTransform = 2
    
    
    kTransform = 1
    
    
    kWorld = 4


class MColorArray(object):
    """
    Array of MColor values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MPoint(object):
    """
    3D point with double-precision coordinates.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def cartesianize(*args, **kwargs):
        """
        Convert point to cartesian form.
        """
    
        pass
    
    
    def distanceTo(*args, **kwargs):
        """
        Return distance between this point and another.
        """
    
        pass
    
    
    def homogenize(*args, **kwargs):
        """
        Convert point to homogenous form.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Test for equivalence of two points, within a tolerance.
        """
    
        pass
    
    
    def rationalize(*args, **kwargs):
        """
        Convert point to rational form.
        """
    
        pass
    
    
    w = None
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kOrigin = None
    
    
    kTolerance = 1e-10


class MFloatMatrix(object):
    """
    4x4 matrix with single-precision elements.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def adjoint(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's adjoint.
        """
    
        pass
    
    
    def det3x3(*args, **kwargs):
        """
        Returns the determinant of the 3x3 matrix formed by the first 3 elements of the first 3 rows of this matrix.
        """
    
        pass
    
    
    def det4x4(*args, **kwargs):
        """
        Returns this matrix's determinant.
        """
    
        pass
    
    
    def getElement(*args, **kwargs):
        """
        Returns the matrix element for the specified row and column.
        """
    
        pass
    
    
    def homogenize(*args, **kwargs):
        """
        Returns a new matrix containing the homogenized version of this matrix.
        """
    
        pass
    
    
    def inverse(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's inverse.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Test for equivalence of two matrices, within a tolerance.
        """
    
        pass
    
    
    def setElement(*args, **kwargs):
        """
        Sets the matrix element for the specified row and column.
        """
    
        pass
    
    
    def setToIdentity(*args, **kwargs):
        """
        Sets this matrix to the identity.
        """
    
        pass
    
    
    def setToProduct(*args, **kwargs):
        """
        Sets this matrix to the product of the two matrices passed in.
        """
    
        pass
    
    
    def transpose(*args, **kwargs):
        """
        Returns a new matrix containing this matrix's transpose.
        """
    
        pass
    
    
    __new__ = None
    
    
    kTolerance = 9.999999747378752e-06


class MDagPathArray(object):
    """
    Array of MDagPath values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MObjectArray(object):
    """
    Array of MObject values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MDGContext(object):
    """
    Dependency graph context.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def getTime(*args, **kwargs):
        """
        Returns the time at which this context is set to evaluate.
        """
    
        pass
    
    
    def isNormal(*args, **kwargs):
        """
        Returns True if the context is set to evaluate normally. Returns False if the context is set to evaluate at a specific time.
        """
    
        pass
    
    
    __new__ = None
    
    
    kNormal = None


class MVectorArray(object):
    """
    Array of MVector values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MMeshSmoothOptions(object):
    """
    Options for control of smooth mesh generation.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    boundaryRule = None
    
    divisions = None
    
    keepBorderEdge = None
    
    keepHardEdge = None
    
    propEdgeHardness = None
    
    smoothUVs = None
    
    smoothness = None
    
    __new__ = None
    
    
    kCreaseAll = 1
    
    
    kCreaseEdge = 2
    
    
    kInvalid = -1
    
    
    kLast = 3
    
    
    kLegacy = 0


class MPointArray(object):
    """
    Array of MPoint values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MTypeId(object):
    """
    Stores a Maya object type identifier.
    """
    
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def id(*args, **kwargs):
        """
        Returns the type id as a long.
        """
    
        pass
    
    
    __new__ = None


class MFloatPoint(object):
    """
    3D point with single-precision coordinates.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def cartesianize(*args, **kwargs):
        """
        Convert point to cartesian form.
        """
    
        pass
    
    
    def distanceTo(*args, **kwargs):
        """
        Return distance between this point and another.
        """
    
        pass
    
    
    def homogenize(*args, **kwargs):
        """
        Convert point to homogenous form.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Test for equivalence of two points, within a tolerance.
        """
    
        pass
    
    
    def rationalize(*args, **kwargs):
        """
        Convert point to rational form.
        """
    
        pass
    
    
    w = None
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kOrigin = None
    
    
    kTolerance = 1e-10


class MPlug(object):
    """
    Create and access dependency node plugs.
    """
    
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns a plug for the array of plugs of which this plug is an element.
        """
    
        pass
    
    
    def asBool(*args, **kwargs):
        """
        Retrieves the plug's value, as a boolean.
        """
    
        pass
    
    
    def asChar(*args, **kwargs):
        """
        Retrieves the plug's value, as a single-byte integer.
        """
    
        pass
    
    
    def asDouble(*args, **kwargs):
        """
        Retrieves the plug's value, as a double-precision float.
        """
    
        pass
    
    
    def asFloat(*args, **kwargs):
        """
        Retrieves the plug's value, as a single-precision float.
        """
    
        pass
    
    
    def asInt(*args, **kwargs):
        """
        Retrieves the plug's value, as a regular integer.
        """
    
        pass
    
    
    def asMAngle(*args, **kwargs):
        """
        Retrieves the plug's value, as an MAngle.
        """
    
        pass
    
    
    def asMDistance(*args, **kwargs):
        """
        Retrieves the plug's value, as an MDistance.
        """
    
        pass
    
    
    def asMObject(*args, **kwargs):
        """
        Retrieves the plug's value, as as an MObject containing a direct reference to the plug's data.
        """
    
        pass
    
    
    def asMTime(*args, **kwargs):
        """
        Retrieves the plug's value, as an MTime.
        """
    
        pass
    
    
    def asShort(*args, **kwargs):
        """
        Retrieves the plug's value, as a short integer.
        """
    
        pass
    
    
    def asString(*args, **kwargs):
        """
        Retrieves the plug's value, as a string.
        """
    
        pass
    
    
    def attribute(*args, **kwargs):
        """
        Returns the attribute currently referenced by this plug.
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        Returns a plug for the specified child attribute of this plug.
        """
    
        pass
    
    
    def connectedTo(*args, **kwargs):
        """
        Returns an array of plugs which are connected to this one.
        """
    
        pass
    
    
    def connectionByPhysicalIndex(*args, **kwargs):
        """
        Returns a plug for the index'th connected element of this plug.
        """
    
        pass
    
    
    def constructHandle(*args, **kwargs):
        """
        Constructs a data handle for the plug.
        """
    
        pass
    
    
    def destructHandle(*args, **kwargs):
        """
        Destroys a data handle previously constructed using constructHandle().
        """
    
        pass
    
    
    def elementByLogicalIndex(*args, **kwargs):
        """
        Returns a plug for the element of this plug array having the specified logical index.
        """
    
        pass
    
    
    def elementByPhysicalIndex(*args, **kwargs):
        """
        Returns a plug for the element of this plug array having the specified physical index.
        """
    
        pass
    
    
    def evaluateNumElements(*args, **kwargs):
        """
        Like numElements() but evaluates all connected elements first to ensure that they are included in the count.
        """
    
        pass
    
    
    def getExistingArrayAttributeIndices(*args, **kwargs):
        """
        Returns an array of all the plug's logical indices which are currently in use.
        """
    
        pass
    
    
    def getSetAttrCmds(*args, **kwargs):
        """
        Returns a list of strings containing the setAttr commands (in MEL syntax) for this plug and all of its descendents.
        """
    
        pass
    
    
    def isFreeToChange(*args, **kwargs):
        """
        Returns a value indicating if the plug's value can be changed, after taking into account the effects of locking and connections.
        """
    
        pass
    
    
    def logicalIndex(*args, **kwargs):
        """
        Returns this plug's logical index within its parent array.
        """
    
        pass
    
    
    def name(*args, **kwargs):
        """
        Returns the name of the plug.
        """
    
        pass
    
    
    def node(*args, **kwargs):
        """
        Returns the node that this plug belongs to.
        """
    
        pass
    
    
    def numChildren(*args, **kwargs):
        """
        Returns the number of children this plug has.
        """
    
        pass
    
    
    def numConnectedChildren(*args, **kwargs):
        """
        Returns the number of this plug's children which have connections.
        """
    
        pass
    
    
    def numConnectedElements(*args, **kwargs):
        """
        Returns the number of this plug's elements which have connections.
        """
    
        pass
    
    
    def numElements(*args, **kwargs):
        """
        Returns the number of the plug's logical indices which are currently in use. Connected elements which have not yet been evaluated may not yet fully exist and may be excluded from the count.
        """
    
        pass
    
    
    def parent(*args, **kwargs):
        """
        Returns a plug for the parent of this plug.
        """
    
        pass
    
    
    def partialName(*args, **kwargs):
        """
        Returns the name of the plug, formatted according to various criteria.
        """
    
        pass
    
    
    def selectAncestorLogicalIndex(*args, **kwargs):
        """
        Changes the logical index of the specified attribute in the plug's path.
        """
    
        pass
    
    
    def setAttribute(*args, **kwargs):
        """
        Switches the plug to reference the given attribute of the same node as the previously referenced attribute.
        """
    
        pass
    
    
    def setBool(*args, **kwargs):
        """
        Sets the plug's value as a boolean.
        """
    
        pass
    
    
    def setChar(*args, **kwargs):
        """
        Sets the plug's value as a single-byte integer.
        """
    
        pass
    
    
    def setDouble(*args, **kwargs):
        """
        Sets the plug's value as a double-precision float.
        """
    
        pass
    
    
    def setFloat(*args, **kwargs):
        """
        Sets the plug's value as a single-precision float.
        """
    
        pass
    
    
    def setInt(*args, **kwargs):
        """
        Sets the plug's value as a regular integer.
        """
    
        pass
    
    
    def setMAngle(*args, **kwargs):
        """
        Sets the plug's value as an MAngle.
        """
    
        pass
    
    
    def setMDataHandle(*args, **kwargs):
        """
        Sets the plug's value as a data handle.
        """
    
        pass
    
    
    def setMDistance(*args, **kwargs):
        """
        Sets the plug's value as an MDistance.
        """
    
        pass
    
    
    def setMObject(*args, **kwargs):
        """
        Sets the plug's value as an MObject.
        """
    
        pass
    
    
    def setMPxData(*args, **kwargs):
        """
        Sets the plug's value using custom plug-in data.
        """
    
        pass
    
    
    def setMTime(*args, **kwargs):
        """
        Sets the plug's value as an MTime.
        """
    
        pass
    
    
    def setNumElements(*args, **kwargs):
        """
        Pre-allocates space for count elements in an array of plugs.
        """
    
        pass
    
    
    def setShort(*args, **kwargs):
        """
        Sets the plug's value as a short integer.
        """
    
        pass
    
    
    def setString(*args, **kwargs):
        """
        Sets the plug's value as a string.
        """
    
        pass
    
    
    info = None
    
    isArray = None
    
    isCaching = None
    
    isChannelBox = None
    
    isChild = None
    
    isCompound = None
    
    isConnected = None
    
    isDestination = None
    
    isDynamic = None
    
    isElement = None
    
    isFromReferencedFile = None
    
    isIgnoredWhenRendering = None
    
    isKeyable = None
    
    isLocked = None
    
    isNetworked = None
    
    isNull = None
    
    isProcedural = None
    
    isSource = None
    
    __new__ = None
    
    
    kAll = 0
    
    
    kChanged = 2
    
    
    kChildrenNotFreeToChange = 2
    
    
    kFreeToChange = 0
    
    
    kLastAttrSelector = 3
    
    
    kNonDefault = 1
    
    
    kNotFreeToChange = 1


class MArgParser(object):
    """
    Command argument list parser.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def commandArgumentBool(*args, **kwargs):
        """
        commandArgumentBool(argIndex) -> bool
        
        Returns the specified command argument as a bool.
        """
    
        pass
    
    
    def commandArgumentDouble(*args, **kwargs):
        """
        Alias for commandArgumentFloat().
        """
    
        pass
    
    
    def commandArgumentFloat(*args, **kwargs):
        """
        commandArgumentFloat(argIndex) -> float
        
        Returns the specified command argument as a float.
        """
    
        pass
    
    
    def commandArgumentInt(*args, **kwargs):
        """
        commandArgumentInt(argIndex) -> int
        
        Returns the specified command argument as an int.
        """
    
        pass
    
    
    def commandArgumentMAngle(*args, **kwargs):
        """
        commandArgumentMAngle(argIndex) -> MAngle
        
        Returns the specified command argument as an MAngle.
        """
    
        pass
    
    
    def commandArgumentMDistance(*args, **kwargs):
        """
        commandArgumentMDistance(argIndex) -> MDistance
        
        Returns the specified command argument as an MDistance.
        """
    
        pass
    
    
    def commandArgumentMTime(*args, **kwargs):
        """
        commandArgumentMTime(argIndex) -> MTime
        
        Returns the specified command argument as an MTime.
        """
    
        pass
    
    
    def commandArgumentString(*args, **kwargs):
        """
        commandArgumentString(argIndex) -> unicode string
        
        Returns the specified command argument as a string.
        """
    
        pass
    
    
    def flagArgumentBool(*args, **kwargs):
        """
        flagArgumentBool(flagName, argIndex) -> bool
        
        Returns the specified argument of the specified single-use flag as
        a bool.
        """
    
        pass
    
    
    def flagArgumentDouble(*args, **kwargs):
        """
        flagArgumentDouble(flagName, argIndex) -> float
        
        Alias for flagArgumentFloat().
        """
    
        pass
    
    
    def flagArgumentFloat(*args, **kwargs):
        """
        flagArgumentFloat(flagName, argIndex) -> float
        
        Returns the specified argument of the specified single-use flag as
        a float.
        """
    
        pass
    
    
    def flagArgumentInt(*args, **kwargs):
        """
        flagArgumentInt(flagName, argIndex) -> int
        
        Returns the specified argument of the specified single-use flag as
        an int.
        """
    
        pass
    
    
    def flagArgumentMAngle(*args, **kwargs):
        """
        flagArgumentMAngle(flagName, argIndex) -> MAngle
        
        Returns the specified argument of the specified single-use flag as
        an MAngle.
        """
    
        pass
    
    
    def flagArgumentMDistance(*args, **kwargs):
        """
        flagArgumentMDistance(flagName, argIndex) -> MDistance
        
        Returns the specified argument of the specified single-use flag as
        an MDistance.
        """
    
        pass
    
    
    def flagArgumentMTime(*args, **kwargs):
        """
        flagArgumentMTime(flagName, argIndex) -> MTime
        
        Returns the specified argument of the specified single-use flag as
        an MTime.
        """
    
        pass
    
    
    def flagArgumentString(*args, **kwargs):
        """
        flagArgumentString(flagName, argIndex) -> string
        
        Returns the specified argument of the specified single-use flag as
        a string.
        """
    
        pass
    
    
    def getFlagArgumentList(*args, **kwargs):
        """
        getFlagArgumentList(flagName, occurrence) -> MArgList
        
        Returns the arguments for the specified occurrence of the given
        multi-use flag as an MArgList. Raises RuntimeError if the flag has
        not been enabled for multi-use. Raises IndexError if occurrence is
        out of range.
        """
    
        pass
    
    
    def getFlagArgumentPosition(*args, **kwargs):
        """
        getFlagArgumentPosition(flagName, occurrence) -> int
        
        Returns the position in the argument list of the specified occurrence
        of the given flag. Raises IndexError if occurrence is out of range.
        """
    
        pass
    
    
    def getObjectStrings(*args, **kwargs):
        """
        getObjectStrings() -> tuple of unicode strings
        
        If the command's MSyntax has set the object format to kStringObjects
        then this method will return the objects passed to the command as a
        tuple of strings. If any other object format is set then an empty
        tuple will be returned.
        """
    
        pass
    
    
    def isFlagSet(*args, **kwargs):
        """
        isFlagSet(flagName) -> bool
        
        Returns True if the given flag appears on the command line.
        """
    
        pass
    
    
    def numberOfFlagUses(*args, **kwargs):
        """
        numberOfFlagUses(flagName) -> int
        
        Returns the number of times that the flag appears on the command
        line.
        """
    
        pass
    
    
    isEdit = None
    
    isQuery = None
    
    numberOfFlagsUsed = None
    
    __new__ = None


class MQuaternion(object):
    """
    Quaternion math.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __neg__(*args, **kwargs):
        """
        x.__neg__() <==> -x
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def asAxisAngle(*args, **kwargs):
        """
        Returns the rotation as a tuple containing an axis vector and an angle in radians about that axis.
        """
    
        pass
    
    
    def asEulerRotation(*args, **kwargs):
        """
        Returns the rotation as an equivalent MEulerRotation.
        """
    
        pass
    
    
    def asMatrix(*args, **kwargs):
        """
        Returns the rotation as an equivalent rotation matrix.
        """
    
        pass
    
    
    def conjugate(*args, **kwargs):
        """
        Returns the conjugate of this quaternion (i.e. x, y and z components negated).
        """
    
        pass
    
    
    def conjugateIt(*args, **kwargs):
        """
        In-place conjugation (i.e. negates the x, y and z components).
        """
    
        pass
    
    
    def exp(*args, **kwargs):
        """
        Returns a new quaternion containing the exponent of this one.
        """
    
        pass
    
    
    def inverse(*args, **kwargs):
        """
        Returns a new quaternion containing the inverse of this one.
        """
    
        pass
    
    
    def invertIt(*args, **kwargs):
        """
        In-place inversion.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Returns True if the distance between the two quaternions (in quaternion space) is less than or equal to the given tolerance.
        """
    
        pass
    
    
    def log(*args, **kwargs):
        """
        Returns a new quaternion containing the natural log of this one.
        """
    
        pass
    
    
    def negateIt(*args, **kwargs):
        """
        In-place negation of the x, y, z and w components.
        """
    
        pass
    
    
    def normal(*args, **kwargs):
        """
        Returns a new quaternion containing the normalized version of this one (i.e. scaled to unit length).
        """
    
        pass
    
    
    def normalizeIt(*args, **kwargs):
        """
        In-place normalization (i.e. scales the quaternion to unit length).
        """
    
        pass
    
    
    def setToXAxis(*args, **kwargs):
        """
        Set this quaternion to be equivalent to a rotation of a given angle, in radians, about the X-axis.
        """
    
        pass
    
    
    def setToYAxis(*args, **kwargs):
        """
        Set this quaternion to be equivalent to a rotation of a given angle, in radians, about the Y-axis.
        """
    
        pass
    
    
    def setToZAxis(*args, **kwargs):
        """
        Set this quaternion to be equivalent to a rotation of a given angle, in radians, about the Z-axis.
        """
    
        pass
    
    
    def setValue(*args, **kwargs):
        """
        Set the value of this quaternion to that of the specified MQuaternion, MEulerRotation, MMatrix or MVector and angle.
        """
    
        pass
    
    
    def slerp(*args, **kwargs):
        """
        Returns the quaternion at a given interpolation value along the shortest path between two quaternions.
        """
    
        pass
    
    
    def squad(*args, **kwargs):
        """
        Returns the quaternion at a given interpolation value along a cubic curve segment in quaternion space.
        """
    
        pass
    
    
    def squadPt(*args, **kwargs):
        """
        Returns a new quaternion representing an intermediate point which when used with squad() will produce a C1 continuous spline.
        """
    
        pass
    
    
    w = None
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kIdentity = None
    
    
    kTolerance = 1e-10


class MPxAttributePatternFactory(object):
    """
    Base class for custom attribute pattern factories.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    __new__ = None


class MColor(object):
    """
    Manipulate color data.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __idiv__(*args, **kwargs):
        """
        x.__idiv__(y) <==> x/=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def getColor(*args, **kwargs):
        """
        Returns a list containing the color's components, in the specified color model.
        """
    
        pass
    
    
    def setColor(*args, **kwargs):
        """
        Sets the color's components and color model.
        """
    
        pass
    
    
    a = None
    
    b = None
    
    g = None
    
    r = None
    
    __new__ = None
    
    
    kByte = 1
    
    
    kCMY = 2
    
    
    kCMYK = 3
    
    
    kFloat = 0
    
    
    kHSV = 1
    
    
    kOpaqueBlack = None
    
    
    kRGB = 0
    
    
    kShort = 2


class MSelectionList(object):
    """
    A heterogenous list of MObjects, MPlugs and MDagPaths.
    
    __init__()
    Initializes a new, empty MSelectionList object.
    
    __init__(MSelectionList other)
    Initializes a new MSelectionList object containing the same
    items as another list.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def add(*args, **kwargs):
        """
        add(pattern, searchChildNamespaces=False) -> self
        add(item, mergeWithExisting=True) -> self
        
        
        The first version adds to the list any nodes, DAG paths, components
        or plugs which match the given the pattern string.
        
        The second version adds the specific item to the list, where the
        item can be a plug (MPlug), a node (MObject), a DAG path (MDagPath)
        or a component (tuple of (MDagPath, MObject) ).
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        clear() -> self
        
        Empties the selection list.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        copy(src) -> self
        
        Replaces the contents of the selection list with a copy of those from src (MSelectionList).
        """
    
        pass
    
    
    def getComponent(*args, **kwargs):
        """
        getComponent(index) -> (MDagPath, MObject)
        
        Returns the index'th item of the list as a component, represented by
        a tuple containing an MDagPath and an MObject. If the item is just a
        DAG path without a component then MObject.kNullObj will be returned
        in the second element of the tuple. Raises TypeError if the item is
        neither a DAG path nor a component. Raises IndexError if index is
        out of range.
        """
    
        pass
    
    
    def getDagPath(*args, **kwargs):
        """
        getDagPath(index) -> MDagPath
        
        Returns the DAG path associated with the index'th item of the list.
        Raises TypeError if the item is neither a DAG path nor a component.
        Raises IndexError if index is out of range.
        """
    
        pass
    
    
    def getDependNode(*args, **kwargs):
        """
        getDependNode(index) -> MObject
        
        Returns the node associated with the index'th item, whether it be a
        dependency node, DAG path, component or plug. Raises IndexError if
        index is out of range.
        """
    
        pass
    
    
    def getPlug(*args, **kwargs):
        """
        getPlug(index) -> MPlug
        
        Returns the index'th item of the list as a plug. Raises TypeError if
        the item is not a plug. Raises IndexError if index is out of range.
        """
    
        pass
    
    
    def getSelectionStrings(*args, **kwargs):
        """
        getSelectionStrings(index=None) -> (string, string, ...)
        
        Returns a tuple containing the string representation of the
        specified item. For nodes, DAG paths, plugs and contiguous
        components the tuple will only contain a single string, but for non-
        contiguous components there will be a separate string for each
        distinct block of contiguous elements. If index is not specified
        then the string representations of all the items in the selection
        list are returned. Raises IndexError if index is out of bounds.
        """
    
        pass
    
    
    def hasItem(*args, **kwargs):
        """
        hasItem(item) -> bool
        
        Returns True if the given item is on the selection list. For a
        component this means that all of the elements of the component must
        be on the list. A component is passed as a tuple containing the
        MDagPath of the DAG node and an MObject containing the component.
        """
    
        pass
    
    
    def hasItemPartly(*args, **kwargs):
        """
        hasItemPartly(dagPath, component) -> bool
        
        Returns True if at least one of the component's elements is on the
        selection list. Raises TypeError if dagPath is invalid or component
        does not contain a component.
        """
    
        pass
    
    
    def isEmpty(*args, **kwargs):
        """
        isEmpty() -> bool
        
        Returns True if the selection list is empty.
        """
    
        pass
    
    
    def length(*args, **kwargs):
        """
        length() -> int
        
        Returns the number of items on the selection list.
        """
    
        pass
    
    
    def merge(*args, **kwargs):
        """
        merge(other, strategy=kMergeNormal) -> self
        merge(dagPath, component, strategy=kMergeNormal) -> self
        
        The first version merges the items from another selection list in
        with those already on the list, using the given strategy.
        
        The second version merges the specified component with those already
        on the list.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        remove(index) -> self
        
        Removes the index'th item from the list. Raises IndexError if the
        index is out of range.
        """
    
        pass
    
    
    def replace(*args, **kwargs):
        """
        replace(index, newItem) -> self
        
        Replaces the index'th item on the list with a new item. A component
        is passed as a tuple containing the MDagPath of the DAG node and an
        MObject containing the component. Raises IndexError if the index is
        out of range.
        """
    
        pass
    
    
    def toggle(*args, **kwargs):
        """
        toggle(dagPath, component) -> self
        
        Removes from the list those elements of the given component which
        are already on it and adds those which are not.
        """
    
        pass
    
    
    __new__ = None
    
    
    kMergeNormal = 0
    
    
    kRemoveFromList = 2
    
    
    kXORWithList = 1


class MFn(object):
    """
    Static class providing constants for all API types.
    """
    
    
    
    kAISEnvFacade = 961
    
    
    kAddDoubleLinear = 5
    
    
    kAdskMaterial = 1049
    
    
    kAffect = 6
    
    
    kAimConstraint = 111
    
    
    kAir = 257
    
    
    kAlignCurve = 41
    
    
    kAlignManip = 897
    
    
    kAlignSurface = 42
    
    
    kAmbientLight = 303
    
    
    kAngle = 270
    
    
    kAngleBetween = 21
    
    
    kAnimBlend = 781
    
    
    kAnimBlendInOut = 782
    
    
    kAnimCurve = 7
    
    
    kAnimCurveTimeToAngular = 8
    
    
    kAnimCurveTimeToDistance = 9
    
    
    kAnimCurveTimeToTime = 10
    
    
    kAnimCurveTimeToUnitless = 11
    
    
    kAnimCurveUnitlessToAngular = 12
    
    
    kAnimCurveUnitlessToDistance = 13
    
    
    kAnimCurveUnitlessToTime = 14
    
    
    kAnimCurveUnitlessToUnitless = 15
    
    
    kAnimLayer = 1002
    
    
    kAnisotropy = 609
    
    
    kAnnotation = 271
    
    
    kAnyGeometryVarGroup = 115
    
    
    kArcLength = 273
    
    
    kAreaLight = 305
    
    
    kArrayMapper = 517
    
    
    kArrowManip = 123
    
    
    kAssembly = 1063
    
    
    kAsset = 1000
    
    
    kAttachCurve = 43
    
    
    kAttachSurface = 44
    
    
    kAttribute = 554
    
    
    kAttribute2Double = 734
    
    
    kAttribute2Float = 735
    
    
    kAttribute2Int = 737
    
    
    kAttribute2Long = 737
    
    
    kAttribute2Short = 736
    
    
    kAttribute3Double = 738
    
    
    kAttribute3Float = 739
    
    
    kAttribute3Int = 741
    
    
    kAttribute3Long = 741
    
    
    kAttribute3Short = 740
    
    
    kAttribute4Double = 866
    
    
    kAudio = 22
    
    
    kAverageCurveManip = 149
    
    
    kAvgCurves = 45
    
    
    kAvgNurbsSurfacePoints = 47
    
    
    kAvgSurfacePoints = 46
    
    
    kAxesActionManip = 124
    
    
    kBackground = 23
    
    
    kBallProjectionManip = 125
    
    
    kBarnDoorManip = 150
    
    
    kBase = 1
    
    
    kBaseLattice = 249
    
    
    kBendLattice = 335
    
    
    kBevel = 48
    
    
    kBevelManip = 151
    
    
    kBevelPlus = 885
    
    
    kBezierCurve = 1036
    
    
    kBezierCurveData = 1037
    
    
    kBezierCurveToNurbs = 1039
    
    
    kBinaryData = 733
    
    
    kBirailSrf = 49
    
    
    kBlend = 27
    
    
    kBlendColorSet = 726
    
    
    kBlendColors = 31
    
    
    kBlendDevice = 30
    
    
    kBlendManip = 152
    
    
    kBlendNodeAdditiveRotation = 1015
    
    
    kBlendNodeAdditiveScale = 1014
    
    
    kBlendNodeBase = 1003
    
    
    kBlendNodeBoolean = 1004
    
    
    kBlendNodeDouble = 1005
    
    
    kBlendNodeDoubleAngle = 1006
    
    
    kBlendNodeDoubleLinear = 1007
    
    
    kBlendNodeEnum = 1008
    
    
    kBlendNodeFloat = 1009
    
    
    kBlendNodeFloatAngle = 1010
    
    
    kBlendNodeFloatLinear = 1011
    
    
    kBlendNodeInt16 = 1012
    
    
    kBlendNodeInt32 = 1013
    
    
    kBlendNodeTime = 1034
    
    
    kBlendShape = 336
    
    
    kBlendTwoAttr = 28
    
    
    kBlendWeighted = 29
    
    
    kBlindData = 743
    
    
    kBlindDataTemplate = 744
    
    
    kBlinn = 365
    
    
    kBlinnMaterial = 380
    
    
    kBoundary = 53
    
    
    kBox = 853
    
    
    kBoxData = 852
    
    
    kBrownian = 497
    
    
    kBrush = 752
    
    
    kBulge = 486
    
    
    kBulgeLattice = 337
    
    
    kBump = 32
    
    
    kBump3d = 33
    
    
    kButtonManip = 153
    
    
    kCacheBase = 981
    
    
    kCacheBlend = 982
    
    
    kCacheFile = 971
    
    
    kCacheTrack = 983
    
    
    kCacheableNode = 978
    
    
    kCamera = 250
    
    
    kCameraManip = 154
    
    
    kCameraPlaneManip = 143
    
    
    kCameraSet = 993
    
    
    kCameraView = 34
    
    
    kCenterManip = 134
    
    
    kChainToSpline = 35
    
    
    kCharacter = 675
    
    
    kCharacterMap = 790
    
    
    kCharacterMappingData = 729
    
    
    kCharacterOffset = 676
    
    
    kChecker = 487
    
    
    kChoice = 36
    
    
    kChooser = 759
    
    
    kCircle = 54
    
    
    kCircleManip = 126
    
    
    kCirclePointManip = 231
    
    
    kCircleSweepManip = 128
    
    
    kClampColor = 39
    
    
    kClientDevice = 1059
    
    
    kClip = 796
    
    
    kClipGhostShape = 1064
    
    
    kClipLibrary = 767
    
    
    kClipScheduler = 766
    
    
    kClipToGhostData = 1065
    
    
    kCloseCurve = 55
    
    
    kCloseSurface = 57
    
    
    kClosestPointOnMesh = 973
    
    
    kClosestPointOnSurface = 56
    
    
    kCloth = 488
    
    
    kCloud = 498
    
    
    kCluster = 251
    
    
    kClusterFilter = 344
    
    
    kClusterFlexor = 300
    
    
    kCoiManip = 155
    
    
    kCollision = 253
    
    
    kColorBackground = 24
    
    
    kColorProfile = 1048
    
    
    kCommCornerManip = 600
    
    
    kCommCornerOperManip = 601
    
    
    kCommEdgeOperManip = 598
    
    
    kCommEdgePtManip = 597
    
    
    kCommEdgeSegmentManip = 599
    
    
    kComponent = 524
    
    
    kComponentListData = 572
    
    
    kComponentManip = 661
    
    
    kCompoundAttribute = 564
    
    
    kConcentricProjectionManip = 129
    
    
    kCondition = 37
    
    
    kCone = 96
    
    
    kConstraint = 917
    
    
    kContainer = 995
    
    
    kContainerBase = 1050
    
    
    kContrast = 38
    
    
    kControl = 475
    
    
    kCopyColorSet = 725
    
    
    kCopyUVSet = 794
    
    
    kCpManip = 156
    
    
    kCrater = 499
    
    
    kCreaseSet = 1072
    
    
    kCreate = 40
    
    
    kCreateBPManip = 823
    
    
    kCreateBezierManip = 1035
    
    
    kCreateCVManip = 157
    
    
    kCreateColorSet = 723
    
    
    kCreateEPManip = 158
    
    
    kCreateSectionManip = 810
    
    
    kCreateUVSet = 795
    
    
    kCrossSectionEditManip = 811
    
    
    kCrossSectionManager = 809
    
    
    kCubicProjectionManip = 130
    
    
    kCurve = 266
    
    
    kCurveCVComponent = 525
    
    
    kCurveCurveIntersect = 628
    
    
    kCurveEPComponent = 526
    
    
    kCurveEdManip = 159
    
    
    kCurveFromMeshCoM = 919
    
    
    kCurveFromMeshEdge = 627
    
    
    kCurveFromSubdivEdge = 822
    
    
    kCurveFromSubdivFace = 828
    
    
    kCurveFromSurface = 58
    
    
    kCurveFromSurfaceBnd = 59
    
    
    kCurveFromSurfaceCoS = 60
    
    
    kCurveFromSurfaceIso = 61
    
    
    kCurveInfo = 62
    
    
    kCurveKnotComponent = 527
    
    
    kCurveNormalizerAngle = 985
    
    
    kCurveNormalizerLinear = 986
    
    
    kCurveParamComponent = 528
    
    
    kCurveSegmentManip = 160
    
    
    kCurveVarGroup = 116
    
    
    kCylinder = 98
    
    
    kCylindricalProjectionManip = 131
    
    
    kDOF = 323
    
    
    kDPbirailSrf = 50
    
    
    kDagContainer = 1051
    
    
    kDagNode = 107
    
    
    kDagPose = 677
    
    
    kDagSelectionItem = 551
    
    
    kData = 571
    
    
    kData2Double = 581
    
    
    kData2Float = 582
    
    
    kData2Int = 583
    
    
    kData2Long = 583
    
    
    kData2Short = 584
    
    
    kData3Double = 585
    
    
    kData3Float = 586
    
    
    kData3Int = 587
    
    
    kData3Long = 587
    
    
    kData3Short = 588
    
    
    kData4Double = 867
    
    
    kDblTrsManip = 190
    
    
    kDecayRegionCapComponent = 537
    
    
    kDecayRegionComponent = 538
    
    
    kDefaultLightList = 317
    
    
    kDeformBend = 612
    
    
    kDeformBendManip = 618
    
    
    kDeformFlare = 615
    
    
    kDeformFlareManip = 621
    
    
    kDeformFunc = 611
    
    
    kDeformSine = 616
    
    
    kDeformSineManip = 622
    
    
    kDeformSquash = 614
    
    
    kDeformSquashManip = 620
    
    
    kDeformTwist = 613
    
    
    kDeformTwistManip = 619
    
    
    kDeformWave = 617
    
    
    kDeformWaveManip = 623
    
    
    kDeleteColorSet = 724
    
    
    kDeleteComponent = 318
    
    
    kDeleteUVSet = 787
    
    
    kDependencyNode = 4
    
    
    kDetachCurve = 63
    
    
    kDetachSurface = 64
    
    
    kDiffuseMaterial = 378
    
    
    kDimension = 269
    
    
    kDimensionManip = 232
    
    
    kDirectedDisc = 276
    
    
    kDirectionManip = 161
    
    
    kDirectionalLight = 308
    
    
    kDiscManip = 132
    
    
    kDiskCache = 849
    
    
    kDispatchCompute = 319
    
    
    kDisplacementShader = 321
    
    
    kDisplayLayer = 720
    
    
    kDisplayLayerManager = 721
    
    
    kDistance = 272
    
    
    kDistanceBetween = 322
    
    
    kDistanceManip = 625
    
    
    kDofManip = 162
    
    
    kDoubleAngleAttribute = 556
    
    
    kDoubleArrayData = 573
    
    
    kDoubleIndexedComponent = 701
    
    
    kDoubleLinearAttribute = 558
    
    
    kDoubleShadingSwitch = 606
    
    
    kDrag = 258
    
    
    kDropOffFunction = 812
    
    
    kDropoffLocator = 282
    
    
    kDropoffManip = 163
    
    
    kDummy = 254
    
    
    kDummyConnectable = 324
    
    
    kDynAirManip = 711
    
    
    kDynArrayAttrsData = 716
    
    
    kDynAttenuationManip = 715
    
    
    kDynBase = 707
    
    
    kDynBaseFieldManip = 710
    
    
    kDynEmitterManip = 708
    
    
    kDynFieldsManip = 709
    
    
    kDynGlobals = 756
    
    
    kDynNewtonManip = 712
    
    
    kDynParticleSetComponent = 549
    
    
    kDynSpreadManip = 714
    
    
    kDynSweptGeometryData = 730
    
    
    kDynTurbulenceManip = 713
    
    
    kDynamicConstraint = 975
    
    
    kDynamicsController = 325
    
    
    kEdgeComponent = 534
    
    
    kEditCurve = 807
    
    
    kEditCurveManip = 808
    
    
    kEditMetadata = 1071
    
    
    kEmitter = 255
    
    
    kEnableManip = 136
    
    
    kEnumAttribute = 561
    
    
    kEnvBall = 480
    
    
    kEnvChrome = 482
    
    
    kEnvCube = 481
    
    
    kEnvFacade = 960
    
    
    kEnvFogMaterial = 372
    
    
    kEnvFogShape = 278
    
    
    kEnvSky = 483
    
    
    kEnvSphere = 484
    
    
    kExplodeNurbsShell = 679
    
    
    kExpression = 327
    
    
    kExtendCurve = 65
    
    
    kExtendCurveDistanceManip = 164
    
    
    kExtendSurface = 66
    
    
    kExtendSurfaceDistanceManip = 703
    
    
    kExtract = 328
    
    
    kExtrude = 67
    
    
    kExtrudeManip = 165
    
    
    kFFD = 338
    
    
    kFFblendSrf = 68
    
    
    kFFfilletSrf = 69
    
    
    kFacade = 958
    
    
    kFfdDualBase = 339
    
    
    kField = 256
    
    
    kFileBackground = 25
    
    
    kFileTexture = 489
    
    
    kFilletCurve = 70
    
    
    kFilter = 329
    
    
    kFilterClosestSample = 330
    
    
    kFilterEuler = 331
    
    
    kFilterSimplify = 332
    
    
    kFitBspline = 71
    
    
    kFixedLineManip = 233
    
    
    kFlexor = 299
    
    
    kFloatAngleAttribute = 557
    
    
    kFloatArrayData = 1019
    
    
    kFloatLinearAttribute = 559
    
    
    kFloatMatrixAttribute = 568
    
    
    kFloatVectorArrayData = 996
    
    
    kFlow = 72
    
    
    kFluid = 899
    
    
    kFluidData = 901
    
    
    kFluidEmitter = 905
    
    
    kFluidGeom = 900
    
    
    kFluidTexture2D = 894
    
    
    kFluidTexture3D = 893
    
    
    kFollicle = 920
    
    
    kForceUpdateManip = 682
    
    
    kFosterParent = 1074
    
    
    kFourByFourMatrix = 762
    
    
    kFractal = 490
    
    
    kFreePointManip = 133
    
    
    kFreePointTriadManip = 137
    
    
    kGammaCorrect = 333
    
    
    kGenericAttribute = 565
    
    
    kGeoConnectable = 326
    
    
    kGeoConnector = 907
    
    
    kGeometric = 265
    
    
    kGeometryConstraint = 113
    
    
    kGeometryData = 699
    
    
    kGeometryFilt = 334
    
    
    kGeometryOnLineManip = 142
    
    
    kGeometryVarGroup = 114
    
    
    kGlobalCacheControls = 848
    
    
    kGlobalStitch = 688
    
    
    kGranite = 500
    
    
    kGravity = 259
    
    
    kGreasePencilSequence = 1070
    
    
    kGreasePlane = 1068
    
    
    kGreasePlaneRenderShape = 1069
    
    
    kGrid = 491
    
    
    kGroundPlane = 290
    
    
    kGroupId = 348
    
    
    kGroupParts = 349
    
    
    kGuide = 350
    
    
    kGuideLine = 301
    
    
    kHairConstraint = 925
    
    
    kHairSystem = 921
    
    
    kHairTubeShader = 932
    
    
    kHandleRotateManip = 216
    
    
    kHardenPointCurve = 73
    
    
    kHardwareReflectionMap = 872
    
    
    kHardwareRenderGlobals = 516
    
    
    kHardwareRenderingGlobals = 1053
    
    
    kHeightField = 906
    
    
    kHikEffector = 945
    
    
    kHikFKJoint = 947
    
    
    kHikFloorContactMarker = 967
    
    
    kHikGroundPlane = 968
    
    
    kHikHandle = 949
    
    
    kHikIKEffector = 946
    
    
    kHikSolver = 948
    
    
    kHistorySwitch = 972
    
    
    kHsvToRgb = 351
    
    
    kHwShaderNode = 875
    
    
    kHyperGraphInfo = 352
    
    
    kHyperLayout = 353
    
    
    kHyperLayoutDG = 987
    
    
    kHyperView = 354
    
    
    kIkEffector = 119
    
    
    kIkHandle = 120
    
    
    kIkRPManip = 167
    
    
    kIkSolver = 355
    
    
    kIkSplineManip = 166
    
    
    kIkSystem = 361
    
    
    kIllustratorCurve = 74
    
    
    kImageAdd = 646
    
    
    kImageBlur = 652
    
    
    kImageColorCorrect = 651
    
    
    kImageData = 640
    
    
    kImageDepth = 654
    
    
    kImageDiff = 647
    
    
    kImageDisplay = 655
    
    
    kImageFilter = 653
    
    
    kImageLoad = 641
    
    
    kImageMotionBlur = 657
    
    
    kImageMultiply = 648
    
    
    kImageNetDest = 644
    
    
    kImageNetSrc = 643
    
    
    kImageOver = 649
    
    
    kImagePlane = 362
    
    
    kImageRender = 645
    
    
    kImageSave = 642
    
    
    kImageSource = 778
    
    
    kImageUnder = 650
    
    
    kImageView = 656
    
    
    kImplicitCone = 880
    
    
    kImplicitSphere = 881
    
    
    kInsertKnotCrv = 75
    
    
    kInsertKnotSrf = 76
    
    
    kInstancer = 749
    
    
    kIntArrayData = 574
    
    
    kIntersectSurface = 77
    
    
    kInvalid = 0
    
    
    kIsoparmComponent = 529
    
    
    kIsoparmManip = 146
    
    
    kItemList = 553
    
    
    kJiggleDeformer = 847
    
    
    kJoint = 121
    
    
    kJointCluster = 346
    
    
    kJointClusterManip = 168
    
    
    kJointTranslateManip = 229
    
    
    kKeyframeDelta = 934
    
    
    kKeyframeDeltaAddRemove = 937
    
    
    kKeyframeDeltaBlockAddRemove = 938
    
    
    kKeyframeDeltaBreakdown = 942
    
    
    kKeyframeDeltaInfType = 939
    
    
    kKeyframeDeltaMove = 935
    
    
    kKeyframeDeltaScale = 936
    
    
    kKeyframeDeltaTangent = 940
    
    
    kKeyframeDeltaWeighted = 941
    
    
    kKeyframeRegionManip = 984
    
    
    kKeyingGroup = 674
    
    
    kLambert = 363
    
    
    kLambertMaterial = 379
    
    
    kLast = 1075
    
    
    kLattice = 279
    
    
    kLatticeComponent = 535
    
    
    kLatticeData = 575
    
    
    kLatticeGeom = 280
    
    
    kLayeredShader = 368
    
    
    kLayeredTexture = 791
    
    
    kLeastSquares = 370
    
    
    kLeather = 501
    
    
    kLight = 302
    
    
    kLightDataAttribute = 566
    
    
    kLightFogMaterial = 371
    
    
    kLightInfo = 369
    
    
    kLightLink = 755
    
    
    kLightList = 373
    
    
    kLightManip = 169
    
    
    kLightProjectionGeometry = 234
    
    
    kLightSource = 374
    
    
    kLightSourceMaterial = 382
    
    
    kLimitManip = 135
    
    
    kLineArrowManip = 235
    
    
    kLineManip = 147
    
    
    kLineModifier = 962
    
    
    kLinearLight = 306
    
    
    kLocator = 281
    
    
    kLodGroup = 760
    
    
    kLodThresholds = 758
    
    
    kLookAt = 112
    
    
    kLuminance = 375
    
    
    kMCsolver = 356
    
    
    kMPbirailSrf = 51
    
    
    kMakeGroup = 376
    
    
    kMandelbrot = 1066
    
    
    kMandelbrot3D = 1067
    
    
    kManip2DContainer = 192
    
    
    kManipContainer = 148
    
    
    kManipulator = 230
    
    
    kManipulator2D = 205
    
    
    kManipulator3D = 122
    
    
    kMarble = 502
    
    
    kMarker = 283
    
    
    kMarkerManip = 210
    
    
    kMaterial = 377
    
    
    kMaterialFacade = 959
    
    
    kMaterialInfo = 383
    
    
    kMatrixAdd = 384
    
    
    kMatrixAttribute = 567
    
    
    kMatrixData = 576
    
    
    kMatrixFloatData = 659
    
    
    kMatrixHold = 385
    
    
    kMatrixMult = 386
    
    
    kMatrixPass = 387
    
    
    kMatrixWtAdd = 388
    
    
    kMembrane = 1020
    
    
    kMentalRayTexture = 927
    
    
    kMergeVertsToolManip = 1021
    
    
    kMesh = 296
    
    
    kMeshComponent = 539
    
    
    kMeshData = 577
    
    
    kMeshEdgeComponent = 540
    
    
    kMeshFaceVertComponent = 544
    
    
    kMeshFrEdgeComponent = 542
    
    
    kMeshGeom = 297
    
    
    kMeshMapComponent = 803
    
    
    kMeshPolygonComponent = 541
    
    
    kMeshVarGroup = 117
    
    
    kMeshVertComponent = 543
    
    
    kMeshVtxFaceComponent = 732
    
    
    kMessageAttribute = 569
    
    
    kMidModifier = 389
    
    
    kMidModifierWithMatrix = 390
    
    
    kModel = 3
    
    
    kModifyEdgeBaseManip = 824
    
    
    kModifyEdgeCrvManip = 815
    
    
    kModifyEdgeManip = 816
    
    
    kMotionPath = 435
    
    
    kMotionPathManip = 170
    
    
    kMountain = 492
    
    
    kMoveUVShellManip2D = 697
    
    
    kMoveVertexManip = 750
    
    
    kMultDoubleLinear = 761
    
    
    kMultiSubVertexComponent = 547
    
    
    kMultilisterLight = 436
    
    
    kMultiplyDivide = 437
    
    
    kMute = 916
    
    
    kNBase = 980
    
    
    kNCloth = 989
    
    
    kNComponent = 976
    
    
    kNId = 1018
    
    
    kNIdData = 1017
    
    
    kNObject = 998
    
    
    kNObjectData = 997
    
    
    kNParticle = 990
    
    
    kNRigid = 991
    
    
    kNamedObject = 2
    
    
    kNearestPointOnCurve = 1047
    
    
    kNewton = 260
    
    
    kNoise = 865
    
    
    kNonAmbientLight = 304
    
    
    kNonDagSelectionItem = 552
    
    
    kNonExtendedLight = 307
    
    
    kNonLinear = 610
    
    
    kNormalConstraint = 238
    
    
    kNucleus = 979
    
    
    kNumericAttribute = 555
    
    
    kNumericData = 580
    
    
    kNurbsBoolean = 680
    
    
    kNurbsCircular2PtArc = 630
    
    
    kNurbsCircular3PtArc = 629
    
    
    kNurbsCube = 80
    
    
    kNurbsCurve = 267
    
    
    kNurbsCurveData = 579
    
    
    kNurbsCurveGeom = 268
    
    
    kNurbsCurveToBezier = 1038
    
    
    kNurbsPlane = 79
    
    
    kNurbsSquare = 608
    
    
    kNurbsSurface = 294
    
    
    kNurbsSurfaceData = 578
    
    
    kNurbsSurfaceGeom = 295
    
    
    kNurbsTesselate = 78
    
    
    kNurbsToSubdiv = 747
    
    
    kObjectAttrFilter = 667
    
    
    kObjectBinFilter = 928
    
    
    kObjectFilter = 663
    
    
    kObjectMultiFilter = 664
    
    
    kObjectNameFilter = 665
    
    
    kObjectRenderFilter = 668
    
    
    kObjectScriptFilter = 669
    
    
    kObjectTypeFilter = 666
    
    
    kOcean = 861
    
    
    kOceanShader = 884
    
    
    kOffsetCos = 81
    
    
    kOffsetCosManip = 171
    
    
    kOffsetCurve = 82
    
    
    kOffsetCurveManip = 172
    
    
    kOffsetSurface = 631
    
    
    kOffsetSurfaceManip = 639
    
    
    kOldGeometryConstraint = 438
    
    
    kOpticalFX = 439
    
    
    kOrientConstraint = 239
    
    
    kOrientationComponent = 545
    
    
    kOrientationLocator = 286
    
    
    kOrientationMarker = 284
    
    
    kOrthoGrid = 291
    
    
    kPASolver = 357
    
    
    kPairBlend = 912
    
    
    kParamDimension = 275
    
    
    kParentConstraint = 242
    
    
    kParticle = 311
    
    
    kParticleAgeMapper = 440
    
    
    kParticleCloud = 441
    
    
    kParticleColorMapper = 442
    
    
    kParticleIncandecenceMapper = 443
    
    
    kParticleSamplerInfo = 793
    
    
    kParticleTransparencyMapper = 444
    
    
    kPartition = 445
    
    
    kPassContributionMap = 774
    
    
    kPfxGeometry = 930
    
    
    kPfxHair = 931
    
    
    kPfxToon = 955
    
    
    kPhong = 366
    
    
    kPhongExplorer = 367
    
    
    kPhongMaterial = 381
    
    
    kPivotComponent = 530
    
    
    kPivotManip2D = 191
    
    
    kPlace2dTexture = 446
    
    
    kPlace3dTexture = 447
    
    
    kPlanarProjectionManip = 207
    
    
    kPlanarTrimSrf = 83
    
    
    kPlane = 288
    
    
    kPlugin = 570
    
    
    kPluginCameraSet = 994
    
    
    kPluginClientDevice = 1060
    
    
    kPluginConstraintNode = 999
    
    
    kPluginData = 589
    
    
    kPluginDeformerNode = 602
    
    
    kPluginDependNode = 448
    
    
    kPluginEmitterNode = 718
    
    
    kPluginFieldNode = 717
    
    
    kPluginGeometryData = 754
    
    
    kPluginHardwareShader = 876
    
    
    kPluginHwShaderNode = 877
    
    
    kPluginIkSolver = 748
    
    
    kPluginImagePlaneNode = 988
    
    
    kPluginLocatorNode = 449
    
    
    kPluginManipContainer = 683
    
    
    kPluginManipulatorNode = 1016
    
    
    kPluginObjectSet = 909
    
    
    kPluginParticleAttributeMapperNode = 992
    
    
    kPluginShape = 698
    
    
    kPluginSpringNode = 719
    
    
    kPluginThreadedDevice = 1061
    
    
    kPluginTransformNode = 898
    
    
    kPlusMinusAverage = 450
    
    
    kPointArrayData = 590
    
    
    kPointConstraint = 240
    
    
    kPointLight = 309
    
    
    kPointManip = 236
    
    
    kPointMatrixMult = 451
    
    
    kPointOnCurveInfo = 84
    
    
    kPointOnCurveManip = 208
    
    
    kPointOnLineManip = 211
    
    
    kPointOnPolyConstraint = 1042
    
    
    kPointOnSurfaceInfo = 85
    
    
    kPointOnSurfaceManip = 212
    
    
    kPoleVectorConstraint = 243
    
    
    kPolyAppend = 393
    
    
    kPolyAppendVertex = 783
    
    
    kPolyArrow = 963
    
    
    kPolyAutoProj = 837
    
    
    kPolyAutoProjManip = 951
    
    
    kPolyAverageVertex = 836
    
    
    kPolyBevel = 391
    
    
    kPolyBlindData = 745
    
    
    kPolyBoolOp = 604
    
    
    kPolyBridgeEdge = 977
    
    
    kPolyChipOff = 394
    
    
    kPolyCloseBorder = 395
    
    
    kPolyCollapseEdge = 396
    
    
    kPolyCollapseF = 397
    
    
    kPolyColorDel = 728
    
    
    kPolyColorMod = 727
    
    
    kPolyColorPerVertex = 722
    
    
    kPolyComponentData = 969
    
    
    kPolyCone = 427
    
    
    kPolyConnectComponents = 1043
    
    
    kPolyCreaseEdge = 944
    
    
    kPolyCreateFacet = 433
    
    
    kPolyCreateToolManip = 140
    
    
    kPolyCreator = 425
    
    
    kPolyCube = 428
    
    
    kPolyCut = 887
    
    
    kPolyCutManip = 891
    
    
    kPolyCutManipContainer = 890
    
    
    kPolyCylProj = 398
    
    
    kPolyCylinder = 429
    
    
    kPolyDelEdge = 399
    
    
    kPolyDelFacet = 400
    
    
    kPolyDelVertex = 401
    
    
    kPolyDuplicateEdge = 957
    
    
    kPolyEdgeToCurve = 1001
    
    
    kPolyEditEdgeFlow = 1073
    
    
    kPolyExtrudeEdge = 780
    
    
    kPolyExtrudeFacet = 402
    
    
    kPolyExtrudeManip = 1056
    
    
    kPolyExtrudeManipContainer = 1057
    
    
    kPolyExtrudeVertex = 911
    
    
    kPolyFlipEdge = 779
    
    
    kPolyFlipUV = 874
    
    
    kPolyHelix = 970
    
    
    kPolyHoleFace = 1041
    
    
    kPolyLayoutUV = 838
    
    
    kPolyMapCut = 403
    
    
    kPolyMapDel = 404
    
    
    kPolyMapSew = 405
    
    
    kPolyMapSewMove = 839
    
    
    kPolyMappingManip = 194
    
    
    kPolyMergeEdge = 406
    
    
    kPolyMergeFacet = 407
    
    
    kPolyMergeUV = 895
    
    
    kPolyMergeVert = 685
    
    
    kPolyMesh = 430
    
    
    kPolyMirror = 943
    
    
    kPolyModifierManip = 195
    
    
    kPolyMoveEdge = 408
    
    
    kPolyMoveFacet = 409
    
    
    kPolyMoveFacetUV = 410
    
    
    kPolyMoveUV = 411
    
    
    kPolyMoveUVManip = 193
    
    
    kPolyMoveVertex = 412
    
    
    kPolyMoveVertexManip = 196
    
    
    kPolyMoveVertexUV = 413
    
    
    kPolyNormal = 414
    
    
    kPolyNormalPerVertex = 746
    
    
    kPolyNormalizeUV = 873
    
    
    kPolyPipe = 966
    
    
    kPolyPlanProj = 415
    
    
    kPolyPlatonicSolid = 965
    
    
    kPolyPoke = 888
    
    
    kPolyPokeManip = 892
    
    
    kPolyPrimitive = 426
    
    
    kPolyPrimitiveMisc = 964
    
    
    kPolyPrism = 952
    
    
    kPolyProj = 416
    
    
    kPolyProjectCurve = 1054
    
    
    kPolyProjectionManip = 174
    
    
    kPolyPyramid = 953
    
    
    kPolyQuad = 417
    
    
    kPolyReduce = 757
    
    
    kPolySelectEditFeedbackManip = 1024
    
    
    kPolySeparate = 452
    
    
    kPolySewEdge = 684
    
    
    kPolySmooth = 418
    
    
    kPolySmoothFacet = 686
    
    
    kPolySmoothProxy = 929
    
    
    kPolySoftEdge = 419
    
    
    kPolySphProj = 420
    
    
    kPolySphere = 431
    
    
    kPolySpinEdge = 1040
    
    
    kPolySplit = 421
    
    
    kPolySplitEdge = 801
    
    
    kPolySplitRing = 954
    
    
    kPolySplitToolManip = 141
    
    
    kPolySplitVert = 797
    
    
    kPolyStraightenUVBorder = 896
    
    
    kPolySubdEdge = 422
    
    
    kPolySubdFacet = 423
    
    
    kPolyToSubdiv = 672
    
    
    kPolyToolFeedbackManip = 1023
    
    
    kPolyToolFeedbackShape = 312
    
    
    kPolyTorus = 432
    
    
    kPolyTransfer = 835
    
    
    kPolyTriangulate = 424
    
    
    kPolyTweak = 392
    
    
    kPolyTweakUV = 696
    
    
    kPolyUVRectangle = 1052
    
    
    kPolyUnite = 434
    
    
    kPolyVertexNormalManip = 197
    
    
    kPolyWedgeFace = 889
    
    
    kPositionMarker = 285
    
    
    kPostProcessList = 453
    
    
    kPrecompExport = 775
    
    
    kPrimitive = 86
    
    
    kProjectCurve = 87
    
    
    kProjectTangent = 88
    
    
    kProjectTangentManip = 177
    
    
    kProjection = 454
    
    
    kProjectionManip = 173
    
    
    kProjectionMultiManip = 176
    
    
    kProjectionUVManip = 175
    
    
    kPropModManip = 178
    
    
    kPropMoveTriadManip = 138
    
    
    kProxy = 108
    
    
    kProxyManager = 950
    
    
    kPsdFileTexture = 933
    
    
    kQuadPtOnLineManip = 179
    
    
    kQuadShadingSwitch = 910
    
    
    kRBFsurface = 89
    
    
    kRPsolver = 359
    
    
    kRadial = 261
    
    
    kRadius = 274
    
    
    kRamp = 493
    
    
    kRampBackground = 26
    
    
    kRampShader = 882
    
    
    kRbfSrfManip = 180
    
    
    kRebuildCurve = 90
    
    
    kRebuildSurface = 91
    
    
    kRecord = 455
    
    
    kReference = 742
    
    
    kReflect = 364
    
    
    kRemapColor = 923
    
    
    kRemapHsv = 924
    
    
    kRemapValue = 922
    
    
    kRenderBox = 854
    
    
    kRenderCone = 97
    
    
    kRenderGlobals = 512
    
    
    kRenderGlobalsList = 513
    
    
    kRenderLayer = 772
    
    
    kRenderLayerManager = 773
    
    
    kRenderPass = 770
    
    
    kRenderPassSet = 771
    
    
    kRenderQuality = 514
    
    
    kRenderRect = 277
    
    
    kRenderSetup = 511
    
    
    kRenderSphere = 298
    
    
    kRenderTarget = 776
    
    
    kRenderUtilityList = 456
    
    
    kRenderedImageSource = 777
    
    
    kRenderingList = 1055
    
    
    kResolution = 515
    
    
    kResultCurve = 16
    
    
    kResultCurveTimeToAngular = 17
    
    
    kResultCurveTimeToDistance = 18
    
    
    kResultCurveTimeToTime = 19
    
    
    kResultCurveTimeToUnitless = 20
    
    
    kReverse = 457
    
    
    kReverseCrvManip = 182
    
    
    kReverseCurve = 92
    
    
    kReverseCurveManip = 181
    
    
    kReverseSurface = 93
    
    
    kReverseSurfaceManip = 183
    
    
    kRevolve = 94
    
    
    kRevolveManip = 184
    
    
    kRevolvedPrimitive = 95
    
    
    kRevolvedPrimitiveManip = 185
    
    
    kRgbToHsv = 458
    
    
    kRigid = 314
    
    
    kRigidConstraint = 313
    
    
    kRigidDeform = 340
    
    
    kRigidSolver = 459
    
    
    kRock = 503
    
    
    kRotateBoxManip = 214
    
    
    kRotateLimitsManip = 217
    
    
    kRotateManip = 215
    
    
    kRotateUVManip2D = 694
    
    
    kRoundConstantRadius = 632
    
    
    kRoundConstantRadiusManip = 635
    
    
    kRoundRadiusCrvManip = 634
    
    
    kRoundRadiusManip = 633
    
    
    kSCsolver = 358
    
    
    kSPbirailSrf = 52
    
    
    kSamplerInfo = 467
    
    
    kScaleConstraint = 244
    
    
    kScaleLimitsManip = 218
    
    
    kScaleManip = 219
    
    
    kScalePointManip = 817
    
    
    kScaleUVManip2D = 695
    
    
    kScalingBoxManip = 220
    
    
    kScreenAlignedCircleManip = 127
    
    
    kScript = 626
    
    
    kScriptManip = 221
    
    
    kSculpt = 341
    
    
    kSectionManip = 804
    
    
    kSelectionItem = 550
    
    
    kSelectionList = 595
    
    
    kSelectionListData = 662
    
    
    kSelectionListOperator = 670
    
    
    kSequenceManager = 1031
    
    
    kSequencer = 1032
    
    
    kSet = 460
    
    
    kSetGroupComponent = 548
    
    
    kSetRange = 463
    
    
    kSfRevolveManip = 827
    
    
    kShaderGlow = 464
    
    
    kShaderList = 465
    
    
    kShadingEngine = 320
    
    
    kShadingMap = 466
    
    
    kShape = 248
    
    
    kShapeFragment = 468
    
    
    kShot = 1033
    
    
    kSimpleVolumeShader = 469
    
    
    kSingleIndexedComponent = 700
    
    
    kSingleShadingSwitch = 605
    
    
    kSketchPlane = 289
    
    
    kSkin = 100
    
    
    kSkinBinding = 1044
    
    
    kSkinClusterFilter = 673
    
    
    kSkinShader = 660
    
    
    kSl60 = 470
    
    
    kSmear = 902
    
    
    kSmoothCurve = 687
    
    
    kSmoothTangentSrf = 769
    
    
    kSnapshot = 471
    
    
    kSnapshotPath = 908
    
    
    kSnapshotShape = 845
    
    
    kSnow = 504
    
    
    kSoftMod = 252
    
    
    kSoftModFilter = 345
    
    
    kSoftModManip = 624
    
    
    kSolidFractal = 505
    
    
    kSphere = 99
    
    
    kSphereData = 591
    
    
    kSphericalProjectionManip = 222
    
    
    kSplineSolver = 360
    
    
    kSpotCylinderManip = 187
    
    
    kSpotLight = 310
    
    
    kSpotManip = 186
    
    
    kSpring = 315
    
    
    kSprite = 292
    
    
    kSquareSrf = 704
    
    
    kSquareSrfManip = 705
    
    
    kStateManip = 145
    
    
    kStencil = 494
    
    
    kStereoCameraMaster = 1030
    
    
    kStitchAsNurbsShell = 678
    
    
    kStitchSrf = 101
    
    
    kStitchSrfManip = 681
    
    
    kStoryBoard = 472
    
    
    kStringArrayData = 593
    
    
    kStringData = 592
    
    
    kStringShadingSwitch = 903
    
    
    kStroke = 751
    
    
    kStrokeGlobals = 753
    
    
    kStucco = 506
    
    
    kStudioClearCoat = 904
    
    
    kStyleCurve = 886
    
    
    kSubCurve = 102
    
    
    kSubSurface = 768
    
    
    kSubVertexComponent = 546
    
    
    kSubdAddTopology = 878
    
    
    kSubdAutoProj = 863
    
    
    kSubdBlindData = 789
    
    
    kSubdBoolean = 813
    
    
    kSubdCleanTopology = 879
    
    
    kSubdCloseBorder = 850
    
    
    kSubdDelFace = 844
    
    
    kSubdExtrudeFace = 825
    
    
    kSubdHierBlind = 788
    
    
    kSubdLayoutUV = 859
    
    
    kSubdMapCut = 858
    
    
    kSubdMapSewMove = 860
    
    
    kSubdMappingManip = 871
    
    
    kSubdMergeVert = 851
    
    
    kSubdModifier = 840
    
    
    kSubdModifyEdge = 814
    
    
    kSubdMoveEdge = 842
    
    
    kSubdMoveFace = 843
    
    
    kSubdMoveVertex = 841
    
    
    kSubdPlanProj = 868
    
    
    kSubdProjectionManip = 870
    
    
    kSubdSplitFace = 855
    
    
    kSubdSubdivideFace = 864
    
    
    kSubdTweak = 869
    
    
    kSubdTweakUV = 857
    
    
    kSubdiv = 671
    
    
    kSubdivCVComponent = 689
    
    
    kSubdivCollapse = 792
    
    
    kSubdivCompId = 785
    
    
    kSubdivData = 798
    
    
    kSubdivEdgeComponent = 690
    
    
    kSubdivFaceComponent = 691
    
    
    kSubdivGeom = 799
    
    
    kSubdivMapComponent = 846
    
    
    kSubdivReverseFaces = 802
    
    
    kSubdivSurfaceVarGroup = 826
    
    
    kSubdivToNurbs = 806
    
    
    kSubdivToPoly = 706
    
    
    kSummaryObject = 473
    
    
    kSuper = 474
    
    
    kSurface = 293
    
    
    kSurfaceCVComponent = 531
    
    
    kSurfaceEPComponent = 532
    
    
    kSurfaceEdManip = 764
    
    
    kSurfaceFaceComponent = 765
    
    
    kSurfaceInfo = 103
    
    
    kSurfaceKnotComponent = 533
    
    
    kSurfaceLuminance = 476
    
    
    kSurfaceRangeComponent = 536
    
    
    kSurfaceShader = 477
    
    
    kSurfaceVarGroup = 118
    
    
    kSymmetryConstraint = 241
    
    
    kSymmetryLocator = 819
    
    
    kSymmetryMapCurve = 821
    
    
    kSymmetryMapVector = 820
    
    
    kTangentConstraint = 245
    
    
    kTexLattice = 200
    
    
    kTexLatticeDeformManip = 199
    
    
    kTexSmoothManip = 201
    
    
    kTexSmudgeUVManip = 198
    
    
    kTextButtonManip = 638
    
    
    kTextCurves = 104
    
    
    kTextManip = 913
    
    
    kTexture2d = 485
    
    
    kTexture3d = 496
    
    
    kTextureBakeSet = 461
    
    
    kTextureEnv = 479
    
    
    kTextureList = 478
    
    
    kTextureManip3D = 223
    
    
    kThreadedDevice = 1058
    
    
    kThreePointArcManip = 636
    
    
    kTime = 509
    
    
    kTimeAttribute = 560
    
    
    kTimeFunction = 926
    
    
    kTimeToUnitConversion = 510
    
    
    kTimeWarp = 1062
    
    
    kToggleManip = 224
    
    
    kToggleOnLineManip = 144
    
    
    kToonLineAttributes = 956
    
    
    kTorus = 603
    
    
    kTowPointManip = 139
    
    
    kTowPointOnCurveManip = 209
    
    
    kTowPointOnSurfaceManip = 763
    
    
    kTransferAttributes = 974
    
    
    kTransform = 110
    
    
    kTransformBoxManip = 818
    
    
    kTransformGeometry = 596
    
    
    kTranslateBoxManip = 225
    
    
    kTranslateLimitsManip = 226
    
    
    kTranslateManip = 227
    
    
    kTranslateManip2D = 206
    
    
    kTranslateUVManip = 213
    
    
    kTranslateUVManip2D = 693
    
    
    kTriadManip = 237
    
    
    kTrim = 105
    
    
    kTrimLocator = 287
    
    
    kTrimManip = 228
    
    
    kTrimWithBoundaries = 918
    
    
    kTriplanarProjectionManip = 188
    
    
    kTripleIndexedComponent = 702
    
    
    kTripleShadingSwitch = 607
    
    
    kTrsInsertManip = 203
    
    
    kTrsManip = 189
    
    
    kTrsTransManip = 202
    
    
    kTrsXformManip = 204
    
    
    kTurbulence = 262
    
    
    kTweak = 342
    
    
    kTwoPointArcManip = 637
    
    
    kTxSl = 507
    
    
    kTypedAttribute = 563
    
    
    kUInt64ArrayData = 800
    
    
    kUVManip2D = 692
    
    
    kUint64SingleIndexedComponent = 1022
    
    
    kUnderWorld = 109
    
    
    kUniform = 263
    
    
    kUnitAttribute = 562
    
    
    kUnitConversion = 518
    
    
    kUnitToTimeConversion = 519
    
    
    kUnknown = 521
    
    
    kUnknownDag = 316
    
    
    kUnknownTransform = 246
    
    
    kUntrim = 106
    
    
    kUnused1 = 829
    
    
    kUnused2 = 830
    
    
    kUnused3 = 831
    
    
    kUnused4 = 832
    
    
    kUnused5 = 833
    
    
    kUnused6 = 834
    
    
    kUseBackground = 520
    
    
    kUvChooser = 784
    
    
    kVectorArrayData = 594
    
    
    kVectorProduct = 522
    
    
    kVertexBakeSet = 462
    
    
    kVertexWeightSet = 1046
    
    
    kViewColorManager = 658
    
    
    kViewManip = 914
    
    
    kVolumeAxis = 786
    
    
    kVolumeBindManip = 1045
    
    
    kVolumeFog = 856
    
    
    kVolumeLight = 883
    
    
    kVolumeNoise = 862
    
    
    kVolumeShader = 523
    
    
    kVortex = 264
    
    
    kWater = 495
    
    
    kWeightGeometryFilt = 343
    
    
    kWire = 347
    
    
    kWood = 508
    
    
    kWorld = 247
    
    
    kWrapFilter = 731
    
    
    kWriteToColorBuffer = 1026
    
    
    kWriteToDepthBuffer = 1028
    
    
    kWriteToFrameBuffer = 1025
    
    
    kWriteToLabelBuffer = 1029
    
    
    kWriteToVectorBuffer = 1027
    
    
    kXformManip = 915
    
    
    kXsectionSubdivEdit = 805


class MGlobal(object):
    """
    Static class providing common API global functions.
    """
    
    
    
    def displayError(*args, **kwargs):
        """
        displayError(msg) -> None
        
        Display an error in the script editor.
        """
    
        pass
    
    
    def displayInfo(*args, **kwargs):
        """
        displayInfo(msg) -> None
        
        Display an informational message in the script editor.
        """
    
        pass
    
    
    def displayWarning(*args, **kwargs):
        """
        displayWarning(msg) -> None
        
        Display a warning in the script editor.
        """
    
        pass
    
    
    def getActiveSelectionList(*args, **kwargs):
        """
        getActiveSelectionList() -> MSelectionList
        
        Return an MSelectionList containing the nodes, components and
        plugs currently selected in Maya.
        """
    
        pass
    
    
    def getFunctionSetList(*args, **kwargs):
        """
        getFunctionSetList(MObject) -> (string, string, ...)
        
        Returns a tuple of strings that represent the type of each function
        set that will accept this object.
        """
    
        pass
    
    
    def getSelectionListByName(*args, **kwargs):
        """
        getSelectionListByName(name) -> MSelectionList
        
        Returns an MSelectionList with all of the objects that match the
        specified name. The name may use the same type of regular expressions
        as can be used in MEL commands. For example, the pattern 'pCube*' will
        match all occurrences of objects whose names begin with 'pCube'.
        """
    
        pass
    
    
    kAddToHeadOfList = 4
    
    
    kAddToList = 2
    
    
    kBaseUIMode = 3
    
    
    kBatch = 1
    
    
    kInteractive = 0
    
    
    kLibraryApp = 2
    
    
    kRemoveFromList = 3
    
    
    kReplaceList = 0
    
    
    kSelectComponentMode = 1
    
    
    kSelectLeafMode = 3
    
    
    kSelectObjectMode = 0
    
    
    kSelectRootMode = 2
    
    
    kSelectTemplateMode = 4
    
    
    kSurfaceSelectMethod = 0
    
    
    kWireframeSelectMethod = 1
    
    
    kXORWithList = 1


class MArgList(object):
    """
    Argument list for passing to commands.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def addArg(*args, **kwargs):
        """
        addArg(arg) -> self , 'arg' is a numeric value, MAngle, MDistance,
        MTime, MPoint or        MVector.
        
        Add an argument to the end of the arg list.
        """
    
        pass
    
    
    def asAngle(*args, **kwargs):
        """
        asAngle(index) -> MAngle
        
        Return an argument as an MAngle.
        """
    
        pass
    
    
    def asBool(*args, **kwargs):
        """
        asBool(index) -> bool
        
        Return an argument as a boolean.
        """
    
        pass
    
    
    def asDistance(*args, **kwargs):
        """
        asDistance(index) -> MDistance
        
        Return an argument as an MDistance.
        """
    
        pass
    
    
    def asDouble(*args, **kwargs):
        """
        asDouble(index) -> float
        
        Alias for asFloat().
        """
    
        pass
    
    
    def asDoubleArray(*args, **kwargs):
        """
        asDoubleArray(index) -> MDoubleArray
        
        Return a sequence of arguments as an MDoubleArray.
        """
    
        pass
    
    
    def asFloat(*args, **kwargs):
        """
        asFloat(index) -> float
        
        Return an argument as a float.
        """
    
        pass
    
    
    def asInt(*args, **kwargs):
        """
        asInt(index) -> int
        
        Return an argument as an integer.
        """
    
        pass
    
    
    def asIntArray(*args, **kwargs):
        """
        asIntArray(index) -> MIntArray
        
        Return a sequence of arguments as an MIntArray.
        """
    
        pass
    
    
    def asMatrix(*args, **kwargs):
        """
        asMatrix(index) -> MMatrix
        
        Return a sequence of arguments as an MMatrix.
        """
    
        pass
    
    
    def asPoint(*args, **kwargs):
        """
        asPoint(index) -> MPoint
        
        Return a sequence of arguments as an MPoint.
        """
    
        pass
    
    
    def asString(*args, **kwargs):
        """
        asString(index) -> string
        
        Return an argument as a string.
        """
    
        pass
    
    
    def asStringArray(*args, **kwargs):
        """
        asStringArray(index) -> list of strings
        
        Return a sequence of arguments as a list of strings.
        """
    
        pass
    
    
    def asTime(*args, **kwargs):
        """
        asTime(index) -> MTime
        
        Return an argument as an MTime.
        """
    
        pass
    
    
    def asVector(*args, **kwargs):
        """
        asVector(index) -> MVector
        
        Return a sequence of arguments as an MVector.
        """
    
        pass
    
    
    def flagIndex(*args, **kwargs):
        """
        flagIndex(shortFlag, longFlag=None) -> int
        
        Return index of first occurrence of specified flag.
        """
    
        pass
    
    
    def lastArgUsed(*args, **kwargs):
        """
        lastArgUsed() -> int
        
        Return index of last argument used by the most recent as*() method.
        """
    
        pass
    
    
    __new__ = None
    
    
    kInvalidArgIndex = 4294967295


class MFloatPointArray(object):
    """
    Array of MFloatPoint values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MRampAttribute(object):
    """
    Functionset for creating and working with ramp attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addEntries(*args, **kwargs):
        """
        Adds entries to the ramp.
        """
    
        pass
    
    
    def deleteEntries(*args, **kwargs):
        """
        Removes from the ramp those entries with the specified indices.
        """
    
        pass
    
    
    def getEntries(*args, **kwargs):
        """
        Returns a tuple containing all of the entries in the ramp.
        """
    
        pass
    
    
    def getValueAtPosition(*args, **kwargs):
        """
        Returns the value of the entry at the given position.
        """
    
        pass
    
    
    def hasIndex(*args, **kwargs):
        """
        Return true if an entry is defined at this index.
        """
    
        pass
    
    
    def numEntries(*args, **kwargs):
        """
        Returns the number of entries in the ramp.
        """
    
        pass
    
    
    def pack(*args, **kwargs):
        """
        Change the indices numbering by re-ordering them from 0.
        """
    
        pass
    
    
    def setInterpolationAtIndex(*args, **kwargs):
        """
        Sets the interpolation of the entry at the given index.
        """
    
        pass
    
    
    def setPositionAtIndex(*args, **kwargs):
        """
        Sets the position of the entry at the given index.
        """
    
        pass
    
    
    def setRamp(*args, **kwargs):
        """
        Set this ramp with one or multiple entries. Current entries are removed before adding the new one(s).
        """
    
        pass
    
    
    def setValueAtIndex(*args, **kwargs):
        """
        Sets the value of the entry at the given index.
        """
    
        pass
    
    
    def sort(*args, **kwargs):
        """
        Sort the ramp by position. Indices are also re-ordered during sort.
        """
    
        pass
    
    
    def createColorRamp(*args, **kwargs):
        """
        Creates and returns a new color ramp attribute.
        """
    
        pass
    
    
    def createCurveRamp(*args, **kwargs):
        """
        Creates and returns a new curve ramp attribute.
        """
    
        pass
    
    
    def createRamp(*args, **kwargs):
        """
        Creates and returns a new color or curve ramp attribute initialized with values.
        """
    
        pass
    
    
    isColorRamp = None
    
    isCurveRamp = None
    
    __new__ = None
    
    
    kLinear = 1
    
    
    kNone = 0
    
    
    kSmooth = 2
    
    
    kSpline = 3


class MObject(object):
    """
    Opaque wrapper for internal Maya objects.
    """
    
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def apiType(*args, **kwargs):
        """
        Returns the function set type for the object.
        """
    
        pass
    
    
    def hasFn(*args, **kwargs):
        """
        Tests whether object is compatible with the specified function set.
        """
    
        pass
    
    
    def isNull(*args, **kwargs):
        """
        Tests whether there is an internal Maya object.
        """
    
        pass
    
    
    apiTypeStr = None
    
    __new__ = None
    
    
    kNullObj = None


class MWeight(object):
    """
    Methods for accessing component weight data. This class is currently
    only used to access soft select and symmetry selection weights.
    Other weight data (e.g. deformer weights) does not use this class
    and can be accessed through the corresponding MFn class or directly
    from the node's attributes.
    
    __init__()
    Initializes a new MWeight object with influence weight of 1 and seam
    weight of 0.
    __init__(MWeight src)
    Initializes a new MWeight object with the same value as src.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    influence = None
    
    seam = None
    
    __new__ = None


class MFloatVector(object):
    """
    3D vector with single-precision coordinates.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __div__(*args, **kwargs):
        """
        x.__div__(y) <==> x/y
        """
    
        pass
    
    
    def __eq__(*args, **kwargs):
        """
        x.__eq__(y) <==> x==y
        """
    
        pass
    
    
    def __ge__(*args, **kwargs):
        """
        x.__ge__(y) <==> x>=y
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __gt__(*args, **kwargs):
        """
        x.__gt__(y) <==> x>y
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __idiv__(*args, **kwargs):
        """
        x.__idiv__(y) <==> x/=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __isub__(*args, **kwargs):
        """
        x.__isub__(y) <==> x-=y
        """
    
        pass
    
    
    def __le__(*args, **kwargs):
        """
        x.__le__(y) <==> x<=y
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __lt__(*args, **kwargs):
        """
        x.__lt__(y) <==> x<y
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(y) <==> x*y
        """
    
        pass
    
    
    def __ne__(*args, **kwargs):
        """
        x.__ne__(y) <==> x!=y
        """
    
        pass
    
    
    def __neg__(*args, **kwargs):
        """
        x.__neg__() <==> -x
        """
    
        pass
    
    
    def __radd__(*args, **kwargs):
        """
        x.__radd__(y) <==> y+x
        """
    
        pass
    
    
    def __rdiv__(*args, **kwargs):
        """
        x.__rdiv__(y) <==> y/x
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(y) <==> y*x
        """
    
        pass
    
    
    def __rsub__(*args, **kwargs):
        """
        x.__rsub__(y) <==> y-x
        """
    
        pass
    
    
    def __rxor__(*args, **kwargs):
        """
        x.__rxor__(y) <==> y^x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def __sub__(*args, **kwargs):
        """
        x.__sub__(y) <==> x-y
        """
    
        pass
    
    
    def __xor__(*args, **kwargs):
        """
        x.__xor__(y) <==> x^y
        """
    
        pass
    
    
    def angle(*args, **kwargs):
        """
        Returns the angle, in radians, between this vector and another.
        """
    
        pass
    
    
    def isEquivalent(*args, **kwargs):
        """
        Returns True if this vector and another are within a given tolerance of being equal.
        """
    
        pass
    
    
    def isParallel(*args, **kwargs):
        """
        Returns True if this vector and another are within the given tolerance of being parallel.
        """
    
        pass
    
    
    def length(*args, **kwargs):
        """
        Returns the magnitude of this vector.
        """
    
        pass
    
    
    def normal(*args, **kwargs):
        """
        Returns a new vector containing the normalized version of this one.
        """
    
        pass
    
    
    def normalize(*args, **kwargs):
        """
        Normalizes this vector in-place and returns a new reference to it.
        """
    
        pass
    
    
    def transformAsNormal(*args, **kwargs):
        """
        Returns a new vector which is calculated by postmultiplying this vector by the transpose of the given matrix and then normalizing the result.
        """
    
        pass
    
    
    x = None
    
    y = None
    
    z = None
    
    __new__ = None
    
    
    kOneVector = None
    
    
    kTolerance = 9.999999747378752e-06
    
    
    kXaxisVector = None
    
    
    kXnegAxisVector = None
    
    
    kYaxisVector = None
    
    
    kYnegAxisVector = None
    
    
    kZaxisVector = None
    
    
    kZeroVector = None
    
    
    kZnegAxisVector = None


class MPlugArray(object):
    """
    Array of MPlug values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MCallbackIdArray(object):
    """
    Array of MCallbackId values.
    """
    
    
    
    def __add__(*args, **kwargs):
        """
        x.__add__(y) <==> x+y
        """
    
        pass
    
    
    def __contains__(*args, **kwargs):
        """
        x.__contains__(y) <==> y in x
        """
    
        pass
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __delslice__(*args, **kwargs):
        """
        x.__delslice__(i, j) <==> del x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __getslice__(*args, **kwargs):
        """
        x.__getslice__(i, j) <==> x[i:j]
        
        Use of negative indices is not supported.
        """
    
        pass
    
    
    def __iadd__(*args, **kwargs):
        """
        x.__iadd__(y) <==> x+=y
        """
    
        pass
    
    
    def __imul__(*args, **kwargs):
        """
        x.__imul__(y) <==> x*=y
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __mul__(*args, **kwargs):
        """
        x.__mul__(n) <==> x*n
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __rmul__(*args, **kwargs):
        """
        x.__rmul__(n) <==> n*x
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def __setslice__(*args, **kwargs):
        """
        x.__setslice__(i, j, y) <==> x[i:j]=y
        
        Use  of negative indices is not supported.
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def append(*args, **kwargs):
        """
        Add a value to the end of the array.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        Remove all elements from the array.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        Replace the array contents with that of another or of a compatible Python sequence.
        """
    
        pass
    
    
    def insert(*args, **kwargs):
        """
        Insert a new value into the array at the given index.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        Remove an element from the array.
        """
    
        pass
    
    
    def setLength(*args, **kwargs):
        """
        Grow or shrink the array to contain a specific number of elements.
        """
    
        pass
    
    
    sizeIncrement = None
    
    __new__ = None


class MNodeClass(object):
    """
    A class for performing node class-level operations in the dependency graph.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __repr__(*args, **kwargs):
        """
        x.__repr__() <==> repr(x)
        """
    
        pass
    
    
    def __str__(*args, **kwargs):
        """
        x.__str__() <==> str(x)
        """
    
        pass
    
    
    def addExtensionAttribute(*args, **kwargs):
        """
        Adds an extension attribute to the node class. An extension attribute is a class-level attribute which has been added dynamically to a node class. Because it is added at the class level, all nodes of that class will have the given attribute, and will only store the attribute's value if it differs from the default. Returns the type of the object at the end of the path.
        """
    
        pass
    
    
    def attribute(*args, **kwargs):
        """
        If passed an int: Returns the node class's i'th attribute. Raises IndexError if index is out of bounds.  If passed a string, Returns the node class's attribute having the given name. Returns MObject.kNullObj if the class does not have an attribute with that name.
        """
    
        pass
    
    
    def getAttributes(*args, **kwargs):
        """
        Returns an MObjectArray array containing all of the node class's attributes.
        """
    
        pass
    
    
    def hasAttribute(*args, **kwargs):
        """
        Returns True if the node class has an attribute of the given name, False otherwise.
        """
    
        pass
    
    
    def removeExtensionAttribute(*args, **kwargs):
        """
        Removes an extension attribute from the node class. Raises ValueError if attr is not an extension attribute of this node class.
        """
    
        pass
    
    
    def removeExtensionAttributeIfUnset(*args, **kwargs):
        """
        Removes an extension attribute from the node class, but only if there are no nodes in the graph with non-default values for this attribute. Returns True if the attribute was removed, False otherwise. Raises ValueError if attr is not an extension attribute of this node class.
        """
    
        pass
    
    
    attributeCount = None
    
    classification = None
    
    pluginName = None
    
    typeId = None
    
    typeName = None
    
    __new__ = None


class MPxCommand(object):
    """
    Base class for custom commands.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def doIt(*args, **kwargs):
        """
        Called by Maya to execute the command.
        """
    
        pass
    
    
    def hasSyntax(*args, **kwargs):
        """
        Called by Maya to determine if the command provides an MSyntax object describing its syntax.
        """
    
        pass
    
    
    def isUndoable(*args, **kwargs):
        """
        Called by Maya to determine if the command supports undo.
        """
    
        pass
    
    
    def redoIt(*args, **kwargs):
        """
        Called by Maya to redo a previously undone command.
        """
    
        pass
    
    
    def syntax(*args, **kwargs):
        """
        Returns the command's MSyntax object, if it has one.
        """
    
        pass
    
    
    def undoIt(*args, **kwargs):
        """
        Called by Maya to undo a previously executed command.
        """
    
        pass
    
    
    def appendToResult(*args, **kwargs):
        """
        Append a value to the result to be returned by the command.
        """
    
        pass
    
    
    def clearResult(*args, **kwargs):
        """
        Clears the command's result.
        """
    
        pass
    
    
    def currentResult(*args, **kwargs):
        """
        Returns the command's current result.
        """
    
        pass
    
    
    def currentResultType(*args, **kwargs):
        """
        Returns the type of the current result.
        """
    
        pass
    
    
    def displayError(*args, **kwargs):
        """
        Display an error message.
        """
    
        pass
    
    
    def displayInfo(*args, **kwargs):
        """
        Display an informational message.
        """
    
        pass
    
    
    def displayWarning(*args, **kwargs):
        """
        Display a warning message.
        """
    
        pass
    
    
    def isCurrentResultArray(*args, **kwargs):
        """
        Returns true if the command's current result is an array of values.
        """
    
        pass
    
    
    def setResult(*args, **kwargs):
        """
        Set the value of the result to be returned by the command.
        """
    
        pass
    
    
    commandString = None
    
    historyOn = None
    
    __new__ = None
    
    
    kDouble = 1
    
    
    kLong = 0
    
    
    kNoArg = 3
    
    
    kString = 2


class MFnComponent(MFnBase):
    """
    This is the base class for all function sets which deal with
    component objects.
    
    __init__()
    Initializes a new, empty MFnComponent object
    __init__(MObject component)
    Initializes a new MFnComponent function set, attached to the specified component.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def isEqual(*args, **kwargs):
        """
        isEqual(MObject other) -> bool
        
        Returns True if other refers to the same component as the
        one to which the function set is currently attached.
        """
    
        pass
    
    
    def weight(*args, **kwargs):
        """
        weight(index) -> MWeight
        
        Returns the weight associated with the specified element,
        where index can range from 0 to elementCount-1.
        """
    
        pass
    
    
    componentType = None
    
    elementCount = None
    
    hasWeights = None
    
    isComplete = None
    
    isEmpty = None
    
    __new__ = None


class MDagModifier(MDGModifier):
    """
    Used to change the structure of the DAG
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def createNode(*args, **kwargs):
        """
        createNode(typeName, parent=MObject.kNullObj) -> new DAG node MObject
        createNode(typeId,   parent=MObject.kNullObj) -> new DAG node MObject
        
        Adds an operation to the modifier to create a DAG node of the specified
        type. If a parent DAG node is provided the new node will be parented
        under it. If no parent is provided and the new DAG node is a transform
        type then it will be parented under the world. In both of these cases
        the method returns the new DAG node.
        
        If no parent is provided and the new DAG node is not a transform type
        then a transform node will be created and the child parented under that. The new transform will be parented under the world and it is the
        transform node which will be returned by the method, not the child.
        
        None of the newly created nodes will be added to the DAG until the
        modifier's doIt() method is called.
        """
    
        pass
    
    
    def reparentNode(*args, **kwargs):
        """
        reparentNode(MObject node, newParent=MObject.kNullObj) -> self
        
        Adds an operation to the modifier to reparent a DAG node under a
        specified parent.
        
        If no parent is provided then the DAG node will be reparented under the
        world, so long as it is a transform type. If it is not a transform type
        then the doIt() will raise a RuntimeError.
        """
    
        pass
    
    
    __new__ = None


class MFnData(MFnBase):
    """
    Base class for dependency graph data function sets.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    __new__ = None
    
    
    kAny = 23
    
    
    kComponentList = 12
    
    
    kDoubleArray = 7
    
    
    kDynArrayAttrs = 18
    
    
    kDynSweptGeometry = 19
    
    
    kFloatArray = 8
    
    
    kIntArray = 9
    
    
    kInvalid = 0
    
    
    kLast = 24
    
    
    kLattice = 14
    
    
    kMatrix = 5
    
    
    kMesh = 13
    
    
    kNId = 22
    
    
    kNObject = 21
    
    
    kNumeric = 1
    
    
    kNurbsCurve = 15
    
    
    kNurbsSurface = 16
    
    
    kPlugin = 2
    
    
    kPluginGeometry = 3
    
    
    kPointArray = 10
    
    
    kSphere = 17
    
    
    kString = 4
    
    
    kStringArray = 6
    
    
    kSubdSurface = 20
    
    
    kVectorArray = 11


class MFnPlugin(MFnBase):
    """
    Register and deregister plug-in services with Maya.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def apiVersion(*args, **kwargs):
        """
        Return the API version required by the plug-in.
        """
    
        pass
    
    
    def deregisterAttributePatternFactory(*args, **kwargs):
        """
        Deregister a user defined attribute pattern factory type from Maya.
        """
    
        pass
    
    
    def deregisterCommand(*args, **kwargs):
        """
        Deregister a user defined command from Maya.
        """
    
        pass
    
    
    def loadPath(*args, **kwargs):
        """
        Return the full path name of the file from which the plug-in was loaded.
        """
    
        pass
    
    
    def name(*args, **kwargs):
        """
        Return the plug-in's name.
        """
    
        pass
    
    
    def registerAttributePatternFactory(*args, **kwargs):
        """
        Register a new attribute pattern factory type with Maya.
        """
    
        pass
    
    
    def registerCommand(*args, **kwargs):
        """
        Register a new command with Maya.
        """
    
        pass
    
    
    def setName(*args, **kwargs):
        """
        Set the plug-in's name.
        """
    
        pass
    
    
    def vendor(*args, **kwargs):
        """
        Return the plug-in's vendor string.
        """
    
        pass
    
    
    version = None
    
    __new__ = None


class MArgDatabase(MArgParser):
    """
    Command argument list parser which extends MArgParser with the
    ability to return arguments and objects as MSelectionLists
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def commandArgumentMSelectionList(*args, **kwargs):
        """
        commandArgumentMSelectionList(argIndex) -> MSelectionList
        
        Returns the specified command argument as an MSelectionList.
        """
    
        pass
    
    
    def flagArgumentMSelectionList(*args, **kwargs):
        """
        flagArgumentMSelectionList(flagName, argIndex) -> MSelectionList
        
        Returns the specified argument of the specified single-use flag as
        an MSelectionList.
        """
    
        pass
    
    
    def getObjectList(*args, **kwargs):
        """
        getObjectList() -> MSelectionList
        
        If the command's MSyntax has set the object format to kSelectionList
        then this method will return the objects passed to the command as an
        MSelectionList. If any other object format is set then an empty
        selection list will be returned.
        """
    
        pass
    
    
    __new__ = None


class MFnDependencyNode(MFnBase):
    """
    Function set for operating on dependency nodes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addAttribute(*args, **kwargs):
        """
        Adds a new dynamic attribute to the node.
        """
    
        pass
    
    
    def attribute(*args, **kwargs):
        """
        Returns an attribute of the node, given either its index or name.
        """
    
        pass
    
    
    def attributeClass(*args, **kwargs):
        """
        Returns the class of the specified attribute.
        """
    
        pass
    
    
    def attributeCount(*args, **kwargs):
        """
        Returns the number of attributes on the node.
        """
    
        pass
    
    
    def canBeWritten(*args, **kwargs):
        """
        Returns true if the node will be written to file.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new node of the given type.
        """
    
        pass
    
    
    def dgCallbackIds(*args, **kwargs):
        """
        Returns DG timing information for a specific callback type, broken down by callbackId.
        """
    
        pass
    
    
    def dgCallbacks(*args, **kwargs):
        """
        Returns DG timing information broken down by callback type.
        """
    
        pass
    
    
    def dgTimer(*args, **kwargs):
        """
        Returns a specific DG timer metric for a given timer type.
        """
    
        pass
    
    
    def dgTimerOff(*args, **kwargs):
        """
        Turns DG timing off for this node.
        """
    
        pass
    
    
    def dgTimerOn(*args, **kwargs):
        """
        Turns DG timing on for this node.
        """
    
        pass
    
    
    def dgTimerQueryState(*args, **kwargs):
        """
        Returns the current DG timer state for this node.
        """
    
        pass
    
    
    def dgTimerReset(*args, **kwargs):
        """
        Resets all DG timers for this node.
        """
    
        pass
    
    
    def findAlias(*args, **kwargs):
        """
        Returns the attribute which has the given alias.
        """
    
        pass
    
    
    def findPlug(*args, **kwargs):
        """
        Returns a plug for the given attribute.
        """
    
        pass
    
    
    def getAffectedAttributes(*args, **kwargs):
        """
        Returns all of the attributes which are affected by the specified attribute.
        """
    
        pass
    
    
    def getAffectingAttributes(*args, **kwargs):
        """
        Returns all of the attributes which affect the specified attribute.
        """
    
        pass
    
    
    def getAliasAttr(*args, **kwargs):
        """
        Returns the node's alias attribute, which is a special attribute used to store information about the node's attribute aliases.
        """
    
        pass
    
    
    def getAliasList(*args, **kwargs):
        """
        Returns all of the node's attribute aliases.
        """
    
        pass
    
    
    def getConnections(*args, **kwargs):
        """
        Returns all the plugs which are connected to attributes of this node.
        """
    
        pass
    
    
    def hasAttribute(*args, **kwargs):
        """
        Returns True if the node has an attribute with the given name.
        """
    
        pass
    
    
    def hasUniqueName(*args, **kwargs):
        """
        Returns True if the node's name is unique.
        """
    
        pass
    
    
    def isFlagSet(*args, **kwargs):
        """
        Returns the state of the specified node flag.
        """
    
        pass
    
    
    def isNewAttribute(*args, **kwargs):
        """
        Returns True if the specified attribute was added in the current scene, and not by by one of its referenced files.
        """
    
        pass
    
    
    def isTrackingEdits(*args, **kwargs):
        """
        Returns True if the node is referenced or in an assembly that is tracking edits.
        """
    
        pass
    
    
    def name(*args, **kwargs):
        """
        Returns the node's name.
        """
    
        pass
    
    
    def plugsAlias(*args, **kwargs):
        """
        Returns the alias for a plug's attribute.
        """
    
        pass
    
    
    def removeAttribute(*args, **kwargs):
        """
        Removes a dynamic attribute from the node.
        """
    
        pass
    
    
    def reorderedAttribute(*args, **kwargs):
        """
        Returns one of the node's attribute, based on the order in which they are written to file.
        """
    
        pass
    
    
    def setAlias(*args, **kwargs):
        """
        Adds or removes an attribute alias.
        """
    
        pass
    
    
    def setDoNotWrite(*args, **kwargs):
        """
        Used to prevent the node from being written to file.
        """
    
        pass
    
    
    def setFlag(*args, **kwargs):
        """
        Sets the state of the specified node flag.
        """
    
        pass
    
    
    def setName(*args, **kwargs):
        """
        Sets the node's name.
        """
    
        pass
    
    
    def userNode(*args, **kwargs):
        """
        Returns the MPxNode object for a plugin node.
        """
    
        pass
    
    
    def allocateFlag(*args, **kwargs):
        """
        Allocates a flag on all nodes for use by the named plugin and returns the flag's index.
        """
    
        pass
    
    
    def classification(*args, **kwargs):
        """
        Returns the classification string for the named node type.
        """
    
        pass
    
    
    def deallocateAllFlags(*args, **kwargs):
        """
        Deallocates all node flags which are currently allocated to the named plugin.
        """
    
        pass
    
    
    def deallocateFlag(*args, **kwargs):
        """
        Deallocates the specified node flag, which was previously allocated by the named plugin using allocateFlag().
        """
    
        pass
    
    
    isDefaultNode = None
    
    isFromReferencedFile = None
    
    isLocked = None
    
    isShared = None
    
    namespace = None
    
    pluginName = None
    
    typeId = None
    
    typeName = None
    
    __new__ = None
    
    
    kExtensionAttr = 3
    
    
    kInvalidAttr = 4
    
    
    kLocalDynamicAttr = 1
    
    
    kNormalAttr = 2
    
    
    kTimerInvalidState = 3
    
    
    kTimerMetric_callback = 0
    
    
    kTimerMetric_callbackNotViaAPI = 6
    
    
    kTimerMetric_callbackViaAPI = 5
    
    
    kTimerMetric_compute = 1
    
    
    kTimerMetric_computeDuringCallback = 7
    
    
    kTimerMetric_computeNotDuringCallback = 8
    
    
    kTimerMetric_dirty = 2
    
    
    kTimerMetric_draw = 3
    
    
    kTimerMetric_fetch = 4
    
    
    kTimerOff = 0
    
    
    kTimerOn = 1
    
    
    kTimerType_count = 2
    
    
    kTimerType_inclusive = 1
    
    
    kTimerType_self = 0
    
    
    kTimerUninitialized = 2


class MFnAttribute(MFnBase):
    """
    Base class for attribute functionsets.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def accepts(*args, **kwargs):
        """
        Returns True if this attribute can accept a connection of the given type.
        """
    
        pass
    
    
    def addToCategory(*args, **kwargs):
        """
        Adds the attribute to a category
        """
    
        pass
    
    
    def getAddAttrCmd(*args, **kwargs):
        """
        Returns a string containing a MEL 'addAttr' command capable of recreating the attribute.
        """
    
        pass
    
    
    def hasCategory(*args, **kwargs):
        """
        Checks to see if the attribute has a given category
        """
    
        pass
    
    
    def setNiceNameOverride(*args, **kwargs):
        """
        Sets a nice UI name for this attribute rather than using the default derived from it's long name.
        """
    
        pass
    
    
    affectsAppearance = None
    
    affectsWorldSpace = None
    
    array = None
    
    cached = None
    
    channelBox = None
    
    connectable = None
    
    disconnectBehavior = None
    
    dynamic = None
    
    extension = None
    
    hidden = None
    
    indeterminant = None
    
    indexMatters = None
    
    internal = None
    
    keyable = None
    
    name = None
    
    parent = None
    
    readable = None
    
    renderSource = None
    
    shortName = None
    
    storable = None
    
    usedAsColor = None
    
    usedAsFilename = None
    
    usesArrayDataBuilder = None
    
    worldSpace = None
    
    writable = None
    
    __new__ = None
    
    
    kDelete = 0
    
    
    kNothing = 2
    
    
    kReset = 1


class MFnEnumAttribute(MFnAttribute):
    """
    Functionset for creating and working with enumeration attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addField(*args, **kwargs):
        """
        Add an item to the enumeration with a specified UI name and corresponding attribute value.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new enumeration attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    def fieldName(*args, **kwargs):
        """
        Returns the name of the enumeration item which has a given value.
        """
    
        pass
    
    
    def fieldValue(*args, **kwargs):
        """
        Returns the value of the enumeration item which has a given name.
        """
    
        pass
    
    
    def getMax(*args, **kwargs):
        """
        Returns the maximum value of all the enumeration items.
        """
    
        pass
    
    
    def getMin(*args, **kwargs):
        """
        Returns the minimum value of all the enumeration items.
        """
    
        pass
    
    
    def setDefaultByName(*args, **kwargs):
        """
        Set the default value using the name of an enumeration item. Equivalent to: attr.default = attr.fieldValue(name)
        """
    
        pass
    
    
    default = None
    
    __new__ = None


class MFnDoubleIndexedComponent(MFnComponent):
    """
    This function set allows you to create, edit, and query double indexed
    components. Double indexed components store 2 dimensional index values.
    
    __init__()
    Initializes a new, empty MFnDoubleIndexedComponent object
    
    __init__(MObject component)
    Initializes a new MFnDoubleIndexedComponent function set, attached
    to the specified component.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addElement(*args, **kwargs):
        """
        addElement(uIndex, vIndex) -> self
        addElement([uIndex, vIndex]) -> self
        
        Adds the element identified by (uIndex, vIndex) to the component.
        """
    
        pass
    
    
    def addElements(*args, **kwargs):
        """
        addElements(sequence of [uIndex, vIndex]) -> self
        
        Adds the specified elements to the component. Each item in the
        elements sequence is itself a sequence of two ints which are the U and
        V indices of an element to be added.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create(MFn Type constant) -> MObject
        
        Creates a new, empty component, attaches it to the function set and
        returns an MObject which references it.
        """
    
        pass
    
    
    def getCompleteData(*args, **kwargs):
        """
        getCompleteData() -> (numU, numV)
        
        Returns a tuple containing the number of U and V indices in the complete
        component, or (0,0) if the component is not complete.
        """
    
        pass
    
    
    def getElement(*args, **kwargs):
        """
        getElement(index) -> (uIndex, vIndex)
        
        Returns the index'th element of the component as a tuple containing the
        element's U and V indices.
        """
    
        pass
    
    
    def getElements(*args, **kwargs):
        """
        getElements() -> list of (uIndex, vIndex)
        
        Returns all of the component's elements as a list of tuples with each
        tuple containing the U and V indices of a single element.
        """
    
        pass
    
    
    def setCompleteData(*args, **kwargs):
        """
        setCompleteData(numU, numV) -> self
        
        Marks the component as complete (i.e. contains all possible elements).
        numU and numV indicate the number of U and V indices in the complete
        component (i.e. the max U index is numU-1 and the max V index is numV-1).
        """
    
        pass
    
    
    __new__ = None


class MFnGenericAttribute(MFnAttribute):
    """
    Functionset for creating and working with attributes which can accept several different types of data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addDataType(*args, **kwargs):
        """
        Adds the specified Maya data type to the list of those accepted by the attribute.
        """
    
        pass
    
    
    def addNumericType(*args, **kwargs):
        """
        Adds the specified numeric type to the list of those accepted by the attribute.
        """
    
        pass
    
    
    def addTypeId(*args, **kwargs):
        """
        Adds the specified data typeId to the list of those accepted by the attribute.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new generic attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    def removeDataType(*args, **kwargs):
        """
        Removes the specified Maya data type from the list of those accepted by the attribute.
        """
    
        pass
    
    
    def removeNumericType(*args, **kwargs):
        """
        Removes the specified numeric type from the list of those accepted by the attribute.
        """
    
        pass
    
    
    def removeTypeId(*args, **kwargs):
        """
        Removes the specified data typeId from the list of those accepted by the attribute.
        """
    
        pass
    
    
    __new__ = None


class MFnLightDataAttribute(MFnAttribute):
    """
    Functionset for creating and working with light data attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        Returns one of the attribute's children, specified by index.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new light data attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    default = None
    
    __new__ = None


class MFnMatrixAttribute(MFnAttribute):
    """
    Functionset for creating and working with matrix attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new matrix attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    default = None
    
    __new__ = None
    
    
    kDouble = 1
    
    
    kFloat = 0


class MFnPointArrayData(MFnData):
    """
    Function set for node data consisting of an array of MPoints.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as an MPointArray.
        """
    
        pass
    
    
    def copyTo(*args, **kwargs):
        """
        Replaces the elements of an array with those in the encapsulated array.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new MPoint array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnMessageAttribute(MFnAttribute):
    """
    Functionset for creating and working with message attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new message attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    __new__ = None


class MFnTripleIndexedComponent(MFnComponent):
    """
    This function set allows you to create, edit, and query triple indexed
    components. Triple indexed components store 3 dimensional index values.
    
    __init__()
    Initializes a new, empty MFnTripleIndexedComponent object
    
    __init__(MObject component)
    Initializes a new MFnTripleIndexedComponent function set, attached
    to the specified component.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addElement(*args, **kwargs):
        """
        addElement(sIndex, tIndex, uIndex) -> self
        addElement([sIndex, tIndex, uIndex]) -> self
        
        Adds the element identified by (sIndex, tIndex, uIndex) to the component.
        """
    
        pass
    
    
    def addElements(*args, **kwargs):
        """
        addElements(sequence of [sIndex, tIndex, uIndex]) -> self
        
        Adds the specified elements to the component. Each item in the
        elements sequence is itself a sequence of three ints which are the
        S, T and U indices of an element to be added.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create(MFn Type constant) -> MObject
        
        Creates a new, empty component, attaches it to the function set and
        returns an MObject which references it.
        """
    
        pass
    
    
    def getCompleteData(*args, **kwargs):
        """
        getCompleteData() -> (numS, numT, numU)
        
        Returns a tuple containing the number of S, T and U indices in
        the complete component, or (0,0,0) if the component is not complete.
        """
    
        pass
    
    
    def getElement(*args, **kwargs):
        """
        getElement(index) -> (sIndex, tIndex, uIndex)
        
        Returns the index'th element of the component as a tuple containing the
        element's S, T and U indices.
        """
    
        pass
    
    
    def getElements(*args, **kwargs):
        """
        getElements() -> list of (sIndex, tIndex, uIndex)
        
        Returns all of the component's elements as a list of tuples with each
        tuple containing the S, T and U indices of a single element.
        """
    
        pass
    
    
    def setCompleteData(*args, **kwargs):
        """
        setCompleteData(numS, numT, numU) -> self
        
        Marks the component as complete (i.e. contains all possible elements).
        numS, numT and numU indicate the number of S, T and U indices
        in the complete component (i.e. the max S index is numS-1, the max T
        index is numT-1 and the max U index is numU-1).
        """
    
        pass
    
    
    __new__ = None


class MFnNumericAttribute(MFnAttribute):
    """
    Functionset for creating and working with numeric attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        Returns the specified child attribute of the parent attribute currently attached to the function set.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new simple or compound numeric attribute, attaches it to the function set and returns it in an MObject.
        """
    
        pass
    
    
    def createAddr(*args, **kwargs):
        """
        Creates a new address attribute, attaches it to the function set and returns it in an MObject.
        """
    
        pass
    
    
    def createColor(*args, **kwargs):
        """
        Creates a new color attribute, attaches it to the function set and returns it in an MObject.
        """
    
        pass
    
    
    def createPoint(*args, **kwargs):
        """
        Creates a new 3D point attribute, attaches it to the function set and returns it in an MObject.
        """
    
        pass
    
    
    def getMax(*args, **kwargs):
        """
        Returns the attribute's hard maximum value(s).
        """
    
        pass
    
    
    def getMin(*args, **kwargs):
        """
        Returns the attribute's hard minimum value(s).
        """
    
        pass
    
    
    def getSoftMax(*args, **kwargs):
        """
        Returns the attribute's soft maximum value.
        """
    
        pass
    
    
    def getSoftMin(*args, **kwargs):
        """
        Returns the attribute's soft minimum value.
        """
    
        pass
    
    
    def hasMax(*args, **kwargs):
        """
        Returns True if a hard maximum value has been specified for the attribute.
        """
    
        pass
    
    
    def hasMin(*args, **kwargs):
        """
        Returns True if a hard minimum value has been specified for the attribute.
        """
    
        pass
    
    
    def hasSoftMax(*args, **kwargs):
        """
        Returns True if a soft maximum value has been specified for the attribute.
        """
    
        pass
    
    
    def hasSoftMin(*args, **kwargs):
        """
        Returns True if a soft minimum value has been specified for the attribute.
        """
    
        pass
    
    
    def numericType(*args, **kwargs):
        """
        Returns the numeric type of the attribute currently attached to the function set.
        """
    
        pass
    
    
    def setMax(*args, **kwargs):
        """
        Sets the attribute's hard maximum value(s).
        """
    
        pass
    
    
    def setMin(*args, **kwargs):
        """
        Sets the attribute's hard minimum value(s).
        """
    
        pass
    
    
    def setSoftMax(*args, **kwargs):
        """
        Sets the attribute's soft maximum value.
        """
    
        pass
    
    
    def setSoftMin(*args, **kwargs):
        """
        Sets the attribute's soft minimum value.
        """
    
        pass
    
    
    default = None
    
    __new__ = None


class MFnStringData(MFnData):
    """
    Function set for string node data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new string data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets the value of the encapsulated string.
        """
    
        pass
    
    
    def string(*args, **kwargs):
        """
        Returns the encapsulated string as a unicode object.
        """
    
        pass
    
    
    __new__ = None


class MFnStringArrayData(MFnData):
    """
    Function set for node data consisting of an array of string.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as a list of unicode objects.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new string array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnComponentListData(MFnData):
    """
    MFnComponentListData allows the creation and manipulation of component list
    (represented as MObjects) data objects for use in the dependency graph.
    
    __init__()
    Initializes a new, empty MFnComponentListData object.
    
    __init__(MObject)
    Initializes a new MFnComponentListData function set, attached
    to the specified object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def add(*args, **kwargs):
        """
        add(MObject) -> self
        
        Adds the specified component to the end of the list.
        """
    
        pass
    
    
    def clear(*args, **kwargs):
        """
        clear() -> self
        
        Removes all of the components from the list.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create() -> MObject
        
        Creates a new, empty component list, attaches it to the
        function set and returns an MObject which references it.
        """
    
        pass
    
    
    def get(*args, **kwargs):
        """
        get(index) -> MObject
        
        Returns a copy of the component at the specified index.
        Raises IndexError if the index is out of range.
        """
    
        pass
    
    
    def has(*args, **kwargs):
        """
        has(MObject) -> bool
        
        Returns True if the list contains the specified
        component, False otherwise.
        """
    
        pass
    
    
    def length(*args, **kwargs):
        """
        length() -> int
        
        Returns the number of components in the list.
        """
    
        pass
    
    
    def remove(*args, **kwargs):
        """
        remove(MObject) -> self
        remove(index) -> self
        
        Removes the specified component from the list.
        No exception is raised if the component is not in the list,
        raises IndexError if index is out of range
        """
    
        pass
    
    
    __new__ = None


class MFnTypedAttribute(MFnAttribute):
    """
    Functionset for creating and working typed attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def attrType(*args, **kwargs):
        """
        Returns the type of data handled by the attribute.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new type attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    default = None
    
    __new__ = None


class MFnUInt64ArrayData(MFnData):
    """
    Function set for node data consisting of an array of MUint64.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as an MUint64Array.
        """
    
        pass
    
    
    def copyTo(*args, **kwargs):
        """
        Replaces the elements of an array with those in the encapsulated array.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new MUint64 array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnSingleIndexedComponent(MFnComponent):
    """
    This function set allows you to create, edit, and query single indexed components.
    Single indexed components store 1 dimensional index values.
    
    __init__()
    Initializes a new, empty MFnSingleIndexedComponent object
    
    __init__(MObject component)
    Initializes a new MFnSingleIndexedComponent function set, attached to the specified component.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addElement(*args, **kwargs):
        """
        addElement(int element) -> self
        
        Adds the specified element to the component.
        """
    
        pass
    
    
    def addElements(*args, **kwargs):
        """
        addElements([int]) -> self
        addElements(MIntArray) -> self
        
        Adds the specified elements to the component.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create(MFn Type constant) -> MObject
        
        Creates a new, empty component, attaches it to the function set and
        returns an MObject which references it.
        """
    
        pass
    
    
    def element(*args, **kwargs):
        """
        element(index) -> int
        
        Returns the index'th element of the component.
        """
    
        pass
    
    
    def getCompleteData(*args, **kwargs):
        """
        getCompleteData() -> int
        
        Returns the number of elements in the complete component, or 0 if the component is not complete.
        """
    
        pass
    
    
    def getElements(*args, **kwargs):
        """
        getElements() -> MIntArray
        
        Returns all of the component's elements.
        """
    
        pass
    
    
    def setCompleteData(*args, **kwargs):
        """
        setCompleteData(numElements) -> self
        
        Marks the component as complete (i.e. contains all possible elements).
        numElements indicates the number of elements in the complete component.
        """
    
        pass
    
    
    __new__ = None


class MFnDagNode(MFnDependencyNode):
    """
    Function set for operating on DAG nodes.
    
    __init__()
    Initializes a new, empty MFnDagNode functionset.
    
    __init__(MObject)
    Initializes a new MFnDagNode functionset and attaches it to a
    DAG node.
    
    __init__(MDagPath)
    Initializes a new MFnDagNode functionset and attaches it to a
    DAG path.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addChild(*args, **kwargs):
        """
        addChild(node, index=kNextPos, keepExistingParents=False) -> self
        
        Makes a node a child of this one.
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        child(index) -> MObject
        
        Returns the specified child of this node.
        """
    
        pass
    
    
    def childCount(*args, **kwargs):
        """
        childCount() -> int
        
        Returns the number of nodes which are children of this one.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create(type, name=None, parent=MObject.kNullObj) -> MObject
        
        Creates a new DAG node of the specified type, with the given name.
        The type may be either a type name or a type ID. If no name is given
        then a unique name will be generated by combining the type name with
        an integer.
        
        If a parent is given then the new node will be parented under it and
        the functionset will be attached to the newly-created node. The
        newly-created node will be returned.
        
        If no parent is given and the new node is a transform, it will be
        parented under the world and the functionset will be attached to the
        newly-created transform. The newly-created transform will be returned.
        
        If no parent is given and the new node is not a transform then a
        transform node will be created under the world, the new node will be
        parented under it, and the functionset will be attached to the
        transform. The transform will be returned.
        """
    
        pass
    
    
    def dagPath(*args, **kwargs):
        """
        dagPath() -> MDagPath
        
        Returns the DAG path to which this function set is attached. Raises a TypeError if the function set is attached to an MObject rather than a path.
        """
    
        pass
    
    
    def dagRoot(*args, **kwargs):
        """
        dagRoot() -> MObject
        
        Returns the root node of the first path leading to this node.
        """
    
        pass
    
    
    def duplicate(*args, **kwargs):
        """
        duplicate(instance=False, instanceLeaf=False) -> MObject
        
        Duplicates the DAG hierarchy rooted at the current node.
        """
    
        pass
    
    
    def fullPathName(*args, **kwargs):
        """
        fullPathName() -> string
        
        Returns the full path of the attached object, from the root of the DAG on down.
        """
    
        pass
    
    
    def getAllPaths(*args, **kwargs):
        """
        getAllPaths() -> MDagPathArray
        
        Returns all of the DAG paths which lead to the object to which this function set is attached.
        """
    
        pass
    
    
    def getPath(*args, **kwargs):
        """
        getPath() -> MDagPath
        
        Returns the DAG path to which this function set is attached, or the first path to the node if the function set is attached to an MObject.
        """
    
        pass
    
    
    def hasChild(*args, **kwargs):
        """
        hasChild(node) -> bool
        
        Returns True if the specified node is a child of this one.
        """
    
        pass
    
    
    def hasParent(*args, **kwargs):
        """
        hasParent(node) -> bool
        
        Returns True if the specified node is a parent of this one.
        """
    
        pass
    
    
    def instanceCount(*args, **kwargs):
        """
        instanceCount(indirect) -> int
        
        Returns the number of instances for this node.
        """
    
        pass
    
    
    def isChildOf(*args, **kwargs):
        """
        isChildOf(node) -> bool
        
        Returns True if the specified node is a parent of this one.
        """
    
        pass
    
    
    def isInstanced(*args, **kwargs):
        """
        isInstanced(indirect=True) -> bool
        
        Returns True if this node is instanced.
        """
    
        pass
    
    
    def isInstancedAttribute(*args, **kwargs):
        """
        isInstancedAttribute(attr) -> bool
        
        Returns True if the specified attribute is an instanced attribute of this node.
        """
    
        pass
    
    
    def isParentOf(*args, **kwargs):
        """
        isParentOf(node) -> bool
        
        Returns True if the specified node is a child of this one.
        """
    
        pass
    
    
    def parent(*args, **kwargs):
        """
        parent(index) -> MObject
        
        Returns the specified parent of this node.
        """
    
        pass
    
    
    def parentCount(*args, **kwargs):
        """
        parentCount() -> int
        
        Returns the number of parents this node has.
        """
    
        pass
    
    
    def partialPathName(*args, **kwargs):
        """
        partialPathName() -> string
        
        Returns the minimum path string necessary to uniquely identify the attached object.
        """
    
        pass
    
    
    def removeChild(*args, **kwargs):
        """
        removeChild(node) -> self
        
        Removes the child, specified by MObject, reparenting it under the world.
        """
    
        pass
    
    
    def removeChildAt(*args, **kwargs):
        """
        removeChildAt(index) -> self
        
        Removes the child, specified by index, reparenting it under the world.
        """
    
        pass
    
    
    def setObject(*args, **kwargs):
        """
        setObject(MObject or MDagPath) -> self
        
        Attaches the function set to the specified node or DAG path.
        """
    
        pass
    
    
    def transformationMatrix(*args, **kwargs):
        """
        transformationMatrix() -> MMatrix
        
        Returns the object space transformation matrix for this DAG node.
        """
    
        pass
    
    
    boundingBox = None
    
    inModel = None
    
    inUnderWorld = None
    
    isInstanceable = None
    
    isIntermediateObject = None
    
    objectColor = None
    
    useObjectColor = None
    
    __new__ = None
    
    
    kNextPos = 255


class MFnDoubleArrayData(MFnData):
    """
    Function set for node data consisting of an array of doubles.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as an MDoubleArray.
        """
    
        pass
    
    
    def copyTo(*args, **kwargs):
        """
        Replaces the elements of an array with those in the encapsulated array.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new double array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnVectorArrayData(MFnData):
    """
    Function set for node data consisting of an array of MVectors.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as an MVectorArray.
        """
    
        pass
    
    
    def copyTo(*args, **kwargs):
        """
        Replaces the elements of an array with those in the encapsulated array.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new MVector array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnNumericData(MFnData):
    """
    Function set for non-simple numeric node data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new numeric data object.
        """
    
        pass
    
    
    def getData(*args, **kwargs):
        """
        Returns a list containing the attached data object's data.
        """
    
        pass
    
    
    def numericType(*args, **kwargs):
        """
        Returns the type of data in the attached data object.
        """
    
        pass
    
    
    def setData(*args, **kwargs):
        """
        Sets the value of the data in the attached data object.
        """
    
        pass
    
    
    __new__ = None
    
    
    k2Double = 14
    
    
    k2Float = 11
    
    
    k2Int = 8
    
    
    k2Long = 8
    
    
    k2Short = 5
    
    
    k3Double = 15
    
    
    k3Float = 12
    
    
    k3Int = 9
    
    
    k3Long = 9
    
    
    k3Short = 6
    
    
    k4Double = 16
    
    
    kAddr = 17
    
    
    kBoolean = 1
    
    
    kByte = 2
    
    
    kChar = 3
    
    
    kDouble = 13
    
    
    kFloat = 10
    
    
    kInt = 7
    
    
    kInvalid = 0
    
    
    kLast = 18
    
    
    kLong = 7
    
    
    kShort = 4


class MFnGeometryData(MFnData):
    """
    This class is the function set for geometry data.
    
    Geometry data adds matrix and grouping (set) information to regular
    data and is used to pass geometry types such as mesh, lattice, and
    NURBS shape data through DG connections.
    
    __init__()
    Initializes a new, empty MFnGeometryData object
    
    __init__(MObject)
    Initializes a new MFnGeometryData function set, attached
    to the specified object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addObjectGroup(*args, **kwargs):
        """
        addObjectGroup(id) -> self
        
        Adds an object group with the given id to the object.
        """
    
        pass
    
    
    def addObjectGroupComponent(*args, **kwargs):
        """
        addObjectGroupComponent(id, MObject component) -> self
        
        Adds the members of the given component to the object group
        with the given id.
        """
    
        pass
    
    
    def changeObjectGroupId(*args, **kwargs):
        """
        changeObjectGroupId(sourceId, destId) -> self
        
        Changes the id of the object group with the given id to the new id.
        """
    
        pass
    
    
    def copyObjectGroups(*args, **kwargs):
        """
        copyObjectGroups(MObject inGeom) -> self
        
        Copies the object groups from the given geometry data object.
        """
    
        pass
    
    
    def hasObjectGroup(*args, **kwargs):
        """
        hasObjectGroup(id) -> self
        
        Returns True if an object group with the given id is
        contained in the data.
        """
    
        pass
    
    
    def objectGroup(*args, **kwargs):
        """
        objectGroup(index) -> int
        
        Returns the id of the index'th object group contained by the object.
        """
    
        pass
    
    
    def objectGroupComponent(*args, **kwargs):
        """
        objectGroupComponent(id) -> MObject
        
        Returns a component which contains the members of the object group
        with the given id.
        """
    
        pass
    
    
    def objectGroupType(*args, **kwargs):
        """
        objectGroupType(id) -> MFn Type constant
        
        Returns the type of the component that the object group with the
        given id contains.
        """
    
        pass
    
    
    def removeObjectGroup(*args, **kwargs):
        """
        removeObjectGroup(id) -> self
        
        Removes an object group with the given id from the object.
        """
    
        pass
    
    
    def removeObjectGroupComponent(*args, **kwargs):
        """
        removeObjectGroupComponent(id, MObject component) -> self
        
        Removes the members of the given component from the object group
        with the given id.
        """
    
        pass
    
    
    def setObjectGroupComponent(*args, **kwargs):
        """
        setObjectGroupComponent(id, MObject component) -> self
        
        Sets the members of the object group with the given id
        to be only those in the given component.
        """
    
        pass
    
    
    isIdentity = None
    
    isNotIdentity = None
    
    matrix = None
    
    objectGroupCount = None
    
    __new__ = None


class MFnUnitAttribute(MFnAttribute):
    """
    Functionset for creating and working with angle, distance and time attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new unit attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    def getMax(*args, **kwargs):
        """
        Returns the attribute's hard maximum value.
        """
    
        pass
    
    
    def getMin(*args, **kwargs):
        """
        Returns the attribute's hard minimum value.
        """
    
        pass
    
    
    def getSoftMax(*args, **kwargs):
        """
        Returns the attribute's soft maximum value.
        """
    
        pass
    
    
    def getSoftMin(*args, **kwargs):
        """
        Returns the attribute's soft minimum value.
        """
    
        pass
    
    
    def hasMax(*args, **kwargs):
        """
        Returns True if the attribute has a hard maximum value.
        """
    
        pass
    
    
    def hasMin(*args, **kwargs):
        """
        Returns True if the attribute has a hard minimum value.
        """
    
        pass
    
    
    def hasSoftMax(*args, **kwargs):
        """
        Returns True if the attribute has a soft maximum value.
        """
    
        pass
    
    
    def hasSoftMin(*args, **kwargs):
        """
        Returns True if the attribute has a soft minimum value.
        """
    
        pass
    
    
    def setMax(*args, **kwargs):
        """
        Sets the attribute's hard maximum value.
        """
    
        pass
    
    
    def setMin(*args, **kwargs):
        """
        Sets the attribute's hard minimum value.
        """
    
        pass
    
    
    def setSoftMax(*args, **kwargs):
        """
        Sets the attribute's soft maximum value.
        """
    
        pass
    
    
    def setSoftMin(*args, **kwargs):
        """
        Sets the attribute's soft minimum value.
        """
    
        pass
    
    
    def unitType(*args, **kwargs):
        """
        Returns the type of data handled by the attribute.
        """
    
        pass
    
    
    default = None
    
    __new__ = None
    
    
    kAngle = 1
    
    
    kDistance = 2
    
    
    kInvalid = 0
    
    
    kLast = 4
    
    
    kTime = 3


class MFnIntArrayData(MFnData):
    """
    Function set for node data consisting of an array of ints.
    """
    
    
    
    def __delitem__(*args, **kwargs):
        """
        x.__delitem__(y) <==> del x[y]
        """
    
        pass
    
    
    def __getitem__(*args, **kwargs):
        """
        x.__getitem__(y) <==> x[y]
        """
    
        pass
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def __len__(*args, **kwargs):
        """
        x.__len__() <==> len(x)
        """
    
        pass
    
    
    def __setitem__(*args, **kwargs):
        """
        x.__setitem__(i, y) <==> x[i]=y
        """
    
        pass
    
    
    def array(*args, **kwargs):
        """
        Returns the encapsulated array as an MIntArray.
        """
    
        pass
    
    
    def copyTo(*args, **kwargs):
        """
        Replaces the elements of an array with those in the encapsulated array.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new int array data object.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets values in the encapsulated array.
        """
    
        pass
    
    
    __new__ = None


class MFnCompoundAttribute(MFnAttribute):
    """
    Functionset for creating and working with compound attributes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addChild(*args, **kwargs):
        """
        Add a child attribute.
        """
    
        pass
    
    
    def child(*args, **kwargs):
        """
        Returns one of the attribute's children, specified by index.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new compound attribute, attaches it to the function set and returns it as an MObject.
        """
    
        pass
    
    
    def getAddAttrCmds(*args, **kwargs):
        """
        Returns a list of MEL 'addAttr' commands capable of recreating the attribute and all of its children.
        """
    
        pass
    
    
    def numChildren(*args, **kwargs):
        """
        Returns number of child attributes currently parented under the compound attribute.
        """
    
        pass
    
    
    def removeChild(*args, **kwargs):
        """
        Remove a child attribute.
        """
    
        pass
    
    
    __new__ = None


class MFnMatrixData(MFnData):
    """
    Function set for matrix node data.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new matrix data object.
        """
    
        pass
    
    
    def isTransformation(*args, **kwargs):
        """
        Returns True if the attached object is an MTransformationMatrix, False if it is an MMatrix.
        """
    
        pass
    
    
    def matrix(*args, **kwargs):
        """
        Returns the encapsulated matrix as an MMatrix.
        """
    
        pass
    
    
    def set(*args, **kwargs):
        """
        Sets the value of the encapsulated matrix.
        """
    
        pass
    
    
    def transformation(*args, **kwargs):
        """
        Returns the encapsulated matrix as an MTransformationMatrix.
        """
    
        pass
    
    
    __new__ = None


class MFnMeshData(MFnGeometryData):
    """
    MFnMeshData allows the creation and manipulation of Mesh
    data objects for use in the dependency graph.
    
    __init__()
    Initializes a new, empty MFnMeshData object
    
    __init__(MObject)
    Initializes a new MFnMeshData function set, attached
    to the specified object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create() -> MObject
        
        Creates a new mesh data object, attaches it to this function set
        and returns an MObject which references it.
        """
    
        pass
    
    
    __new__ = None


class MFnTransform(MFnDagNode):
    """
    Function set for operating on transform nodes.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def clearRestPosition(*args, **kwargs):
        """
        Clears the transform's rest position matrix.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        Creates a new transform node and attaches it to the function set.
        """
    
        pass
    
    
    def enableLimit(*args, **kwargs):
        """
        Enables or disables a specified limit type.
        """
    
        pass
    
    
    def isLimited(*args, **kwargs):
        """
        Returns True if the specified limit type is enabled.
        """
    
        pass
    
    
    def limitValue(*args, **kwargs):
        """
        Returns the value of the specified limit.
        """
    
        pass
    
    
    def resetFromRestPosition(*args, **kwargs):
        """
        Resets the transform from its rest position matrix.
        """
    
        pass
    
    
    def restPosition(*args, **kwargs):
        """
        Returns the transform's rest position matrix.
        """
    
        pass
    
    
    def rotateBy(*args, **kwargs):
        """
        Adds an MEulerRotation or MQuaternion to the transform's rotation.
        """
    
        pass
    
    
    def rotateByComponents(*args, **kwargs):
        """
        Adds to the transform's rotation using the individual components of an MEulerRotation or MQuaternion.
        """
    
        pass
    
    
    def rotateOrientation(*args, **kwargs):
        """
        Returns the MQuaternion which orients the local rotation space.
        """
    
        pass
    
    
    def rotatePivot(*args, **kwargs):
        """
        Returns the transform's rotate pivot.
        """
    
        pass
    
    
    def rotatePivotTranslation(*args, **kwargs):
        """
        Returns the transform's rotate pivot translation.
        """
    
        pass
    
    
    def rotation(*args, **kwargs):
        """
        Returns the transform's rotation as an MEulerRotation or MQuaternion.
        """
    
        pass
    
    
    def rotationComponents(*args, **kwargs):
        """
        Returns the transform's rotation as the individual components of an MEulerRotation or MQuaternion.
        """
    
        pass
    
    
    def rotationOrder(*args, **kwargs):
        """
        Returns the order of rotations when the transform's rotation is expressed as an MEulerRotation.
        """
    
        pass
    
    
    def scale(*args, **kwargs):
        """
        Returns a list containing the transform's XYZ scale components.
        """
    
        pass
    
    
    def scaleBy(*args, **kwargs):
        """
        Multiplies the transform's XYZ scale components by a sequence of three floats.
        """
    
        pass
    
    
    def scalePivot(*args, **kwargs):
        """
        Returns the transform's scale pivot.
        """
    
        pass
    
    
    def scalePivotTranslation(*args, **kwargs):
        """
        Returns the transform's scale pivot translation.
        """
    
        pass
    
    
    def setLimit(*args, **kwargs):
        """
        Sets the value of the specified limit.
        """
    
        pass
    
    
    def setRestPosition(*args, **kwargs):
        """
        Sets the transform's rest position matrix.
        """
    
        pass
    
    
    def setRotateOrientation(*args, **kwargs):
        """
        Sets the MQuaternion which orients the local rotation space.
        """
    
        pass
    
    
    def setRotatePivot(*args, **kwargs):
        """
        Sets the transform's rotate pivot.
        """
    
        pass
    
    
    def setRotatePivotTranslation(*args, **kwargs):
        """
        Sets the transform's rotate pivot translation.
        """
    
        pass
    
    
    def setRotation(*args, **kwargs):
        """
        Sets the transform's rotation using an MEulerRotation or MQuaternion.
        """
    
        pass
    
    
    def setRotationComponents(*args, **kwargs):
        """
        Sets the transform's rotation using the individual components of an MEulerRotation or MQuaternion.
        """
    
        pass
    
    
    def setRotationOrder(*args, **kwargs):
        """
        Sets the transform's rotation order.
        """
    
        pass
    
    
    def setScale(*args, **kwargs):
        """
        Sets the transform's scale components.
        """
    
        pass
    
    
    def setScalePivot(*args, **kwargs):
        """
        Sets the transform's scale pivot.
        """
    
        pass
    
    
    def setScalePivotTranslation(*args, **kwargs):
        """
        Sets the transform's scale pivot translation.
        """
    
        pass
    
    
    def setShear(*args, **kwargs):
        """
        Sets the transform's shear.
        """
    
        pass
    
    
    def setTransformation(*args, **kwargs):
        """
        Sets the transform's attribute values to represent the given transformation matrix.
        """
    
        pass
    
    
    def setTranslation(*args, **kwargs):
        """
        Sets the transform's translation.
        """
    
        pass
    
    
    def shear(*args, **kwargs):
        """
        Returns a list containing the transform's shear components.
        """
    
        pass
    
    
    def shearBy(*args, **kwargs):
        """
        Multiplies the transform's shear components by a sequence of three floats.
        """
    
        pass
    
    
    def transformation(*args, **kwargs):
        """
        Returns the transformation matrix represented by this transform.
        """
    
        pass
    
    
    def translateBy(*args, **kwargs):
        """
        Adds an MVector to the transform's translation.
        """
    
        pass
    
    
    def translation(*args, **kwargs):
        """
        Returns the transform's translation as an MVector.
        """
    
        pass
    
    
    __new__ = None
    
    
    kRotateMaxX = 13
    
    
    kRotateMaxY = 15
    
    
    kRotateMaxZ = 17
    
    
    kRotateMinX = 12
    
    
    kRotateMinY = 14
    
    
    kRotateMinZ = 16
    
    
    kScaleMaxX = 1
    
    
    kScaleMaxY = 3
    
    
    kScaleMaxZ = 5
    
    
    kScaleMinX = 0
    
    
    kScaleMinY = 2
    
    
    kScaleMinZ = 4
    
    
    kShearMaxXY = 7
    
    
    kShearMaxXZ = 9
    
    
    kShearMaxYZ = 11
    
    
    kShearMinXY = 6
    
    
    kShearMinXZ = 8
    
    
    kShearMinYZ = 10
    
    
    kTranslateMaxX = 19
    
    
    kTranslateMaxY = 21
    
    
    kTranslateMaxZ = 23
    
    
    kTranslateMinX = 18
    
    
    kTranslateMinY = 20
    
    
    kTranslateMinZ = 22


class MFnNurbsCurveData(MFnGeometryData):
    """
    MFnNurbsCurveData allows the creation and manipulation of Nurbs Curve
    data objects for use in the dependency graph.
    
    __init__()
    Initializes a new, empty MFnNurbsCurveData object
    
    __init__(MObject)
    Initializes a new MFnNurbsCurveData function set, attached
    to the specified object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create() -> MObject
        
        Creates a new nurbs curve data object, attaches it to this function set
        and returns an MObject which references it.
        """
    
        pass
    
    
    __new__ = None


class MFnMesh(MFnDagNode):
    """
    Function set for operation on meshes (polygonal surfaces).
    
    __init__()
    Initializes a new, empty MFnMesh object.
    
    __init__(MDagPath path)
    Initializes a new MFnMesh object and attaches it to the DAG path
    of a mesh node.
    
    __init__(MObject nodeOrData)
    Initializes a new MFnMesh object and attaches it to a mesh
    node or mesh data object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def addHoles(*args, **kwargs):
        """
        addHoles(faceIndex, vertices, loopCounts, mergeVertices=True, pointTolerance=kPointTolerance) -> self
        
        Adds holes to a mesh polygon.
        loopCounts is an array of vertex counts.
        The first entry gives the count of vertices that make up the
        first hole to add to the polygon (using that many entries in vertexArray). The following
        entries in loopCounts give the count of vertices that make up each remaining hole,
        using the following entries in vertexArray.
        Therefore the sum of the entries of loopCounts should equal the total
        length of vertexArray.
        Note that holes should normally be specified with the opposite winding order
        to the exterior polygon.
        """
    
        pass
    
    
    def addPolygon(*args, **kwargs):
        """
        addPolygon(vertices, mergeVertices=True, pointTolerance=kPointTolerance, loopCounts=None) -> faceId
        
        Adds a new polygon to the mesh, returning the index of the new
        polygon. If mergeVertices is True and a new vertex is within
        pointTolerance of an existing one, then they are 'merged' by reusing
        the existing vertex and discarding the new one.
        
        loopCounts allows for polygons with holes. If supplied, it is an array of integer vertex
        counts. The first entry gives the count of vertices that make up the
        exterior of the polygon (using that many entries in vertexArray). The following
        entries in loopCounts give the count of vertices that make up each hole,
        using the following entries in vertexArray.
        Therefore the sum of the entries of loopCounts should equal the total
        length of vertexArray.
        Note that holes should normally be specified with the opposite winding order
        to the exterior polygon.
        """
    
        pass
    
    
    def allIntersections(*args, **kwargs):
        """
        allIntersections(raySource, rayDirection, space, maxParam,
            testBothDirections, faceIds=None, triIds=None, idsSorted=False,
            accelParams=None, tolerance=kIntersectTolerance, sortHits=False)
          -> (hitPoints, hitRayParams, hitFaces, hitTriangles, hitBary1s, hitBary2s)
        
        Finds all intersection of a ray starting at raySource and travelling
        in rayDirection with the mesh.
        
        If faceIds is specified, then only those faces will be considered
        for intersection. If both faceIds and triIds are given, then the
        triIds will be interpreted as face-relative and each pair of entries
        will be taken as a (face, triangle) pair to be considered for
        intersection. Thus, the face-triangle pair (10, 0) means the first
        triangle on face 10. If neither faceIds nor triIds is given, then
        all face-triangles in the mesh will be considered.
        
        The maxParam and testBothDirections flags can be used to control the
        radius of the search around the raySource point.
        
        The search proceeds by testing all applicable face-triangles looking
        for intersections. If the accelParams parameter is given then the
        mesh builds an intersection acceleration structure based on it. This
        acceleration structure is used to speed up the intersection
        operation, sometimes by a factor of several hundred over the non-
        accelerated case. Once created, the acceleration structure is cached
        and will be reused the next time this method (or anyIntersection()
        or allIntersections()) is called with an identically-configured
        MMeshIsectAccelParams object. If a different MMeshIsectAccelParams
        object is used, then the acceleration structure will be deleted and
        re-created according to the new settings. Once created, the
        acceleration structure will persist until either the object is
        destroyed (or rebuilt by a construction history operation), or the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.
        If the ray hits the mesh, the details of the intersection points
        will be returned as a tuple containing the following:
        * hitPoints (MFloatPointArray) - coordinates of the points hit, in
          the space specified by the caller.* hitRayParams (MFloatArray) - parametric distances along the ray to
          the points hit.* hitFaces (MIntArray) - IDs of the faces hit
        * hitTriangles (MIntArray) - face-relative IDs of the triangles hit
        * hitBary1s (MFloatArray) - first barycentric coordinate of the
          points hit. If the vertices of the hitTriangle are (v1, v2, v3)
          then the barycentric coordinates are such that the hitPoint =
          (*hitBary1)*v1 + (*hitBary2)*v2 + (1-*hitBary1-*hitBary2)*v3.* hitBary2s (MFloatArray) - second barycentric coordinate of the
          points hit.
        If no point was hit then the arrays will all be empty.
        """
    
        pass
    
    
    def anyIntersection(*args, **kwargs):
        """
        anyIntersection(raySource, rayDirection, space, maxParam,
            testBothDirections, faceIds=None, triIds=None, idsSorted=False,
            accelParams=None, tolerance=kIntersectTolerance)
          -> (hitPoint, hitRayParam, hitFace, hitTriangle, hitBary1, hitBary2)
        
        Finds any intersection of a ray starting at raySource and travelling
        in rayDirection with the mesh.
        
        If faceIds is specified, then only those faces will be considered
        for intersection. If both faceIds and triIds are given, then the
        triIds will be interpreted as face-relative and each pair of entries
        will be taken as a (face, triangle) pair to be considered for
        intersection. Thus, the face-triangle pair (10, 0) means the first
        triangle on face 10. If neither faceIds nor triIds is given, then
        all face-triangles in the mesh will be considered.
        
        The maxParam and testBothDirections flags can be used to control the
        radius of the search around the raySource point.
        
        The search proceeds by testing all applicable face-triangles looking
        for intersections. If the accelParams parameter is given then the
        mesh builds an intersection acceleration structure based on it. This
        acceleration structure is used to speed up the intersection
        operation, sometimes by a factor of several hundred over the non-
        accelerated case. Once created, the acceleration structure is cached
        and will be reused the next time this method (or anyIntersection()
        or allIntersections()) is called with an identically-configured
        MMeshIsectAccelParams object. If a different MMeshIsectAccelParams
        object is used, then the acceleration structure will be deleted and
        re-created according to the new settings. Once created, the
        acceleration structure will persist until either the object is
        destroyed (or rebuilt by a construction history operation), or the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.
        If the ray hits the mesh, the details of the intersection point
        will be returned as a tuple containing the following:
        * hitPoint (MFloatPoint) - coordinates of the point hit, in
          the space specified by the caller.* hitRayParam (float) - parametric distance along the ray to
          the point hit.* hitFace (int) - ID of the face hit
        * hitTriangle (int) - face-relative ID of the triangle hit
        * hitBary1 (float) - first barycentric coordinate of the
          point hit. If the vertices of the hitTriangle are (v1, v2, v3)
          then the barycentric coordinates are such that the hitPoint =
          (*hitBary1)*v1 + (*hitBary2)*v2 + (1-*hitBary1-*hitBary2)*v3.* hitBary2 (float) - second barycentric coordinate of the point hit.
        If no point was hit then the arrays will all be empty.
        """
    
        pass
    
    
    def assignColor(*args, **kwargs):
        """
        assignColor(faceId, vertexIndex, colorId, colorSet='') -> self
        
        Assigns a color from a colorSet to a specified vertex of a face.
        """
    
        pass
    
    
    def assignColors(*args, **kwargs):
        """
        assignColors(colorIds, colorSet=') -> self
        
        Assigns colors to all of the mesh's face-vertices. The colorIds
        sequence must contain an entry for every vertex of every face, in
        face order, meaning that the entries for all the vertices of face 0
        come first, followed by the entries for the vertices of face 1, etc.
        """
    
        pass
    
    
    def assignUV(*args, **kwargs):
        """
        assignUV(faceId, vertexIndex, uvId, uvSet='') -> self
        
        Assigns a UV coordinate from a uvSet to a specified vertex of a face.
        """
    
        pass
    
    
    def assignUVs(*args, **kwargs):
        """
        assignUVs(uvCounts, uvIds, uvSet='') -> self
        
        Assigns UV coordinates to the mesh's face-vertices.
        
        uvCounts contains the number of UVs to assign for each of the mesh's
        faces. That number must equal the number of vertices in the
        corresponding face or be 0 to indicate that no UVs will be assigned
        to that face.
        """
    
        pass
    
    
    def booleanOp(*args, **kwargs):
        """
        booleanOp(Boolean Operation constant, MFnMesh, MFnMesh) -> self
        
        Replaces this mesh's geometry with the result of a boolean operation
        on the two specified meshes.
        """
    
        pass
    
    
    def cachedIntersectionAcceleratorInfo(*args, **kwargs):
        """
        cachedIntersectionAcceleratorInfo() -> string
        
        Retrieves a string that describes the intersection acceleration
        structure for this object, if any. The string will be of the
        following form:
        
          10x10x10 uniform grid, (build time 0.5s), (memory footprint 2000KB)
        
        It describes the configuration of the cached intersection
        accelerator, as well as how long it took to build it, and how much
        memory it is currently occupying. If the mesh has no cached
        intersection accelerator, the empty string is returned.
        """
    
        pass
    
    
    def cleanupEdgeSmoothing(*args, **kwargs):
        """
        cleanupEdgeSmoothing() -> self
        
        Updates the mesh after setEdgeSmoothing has been done. This should
        be called only once, after all the desired edges have been had their
        smoothing set. If you don't call this method, the normals may not be
        correct, and the object will look odd in shaded mode.
        """
    
        pass
    
    
    def clearBlindData(*args, **kwargs):
        """
        clearBlindData(compType) -> self
        clearBlindData(compType, blindDataId, compId=None, attr='') -> self
        
        
        The first version deletes all blind data from all the mesh's
        components of the given type (an MFn Type constant).
        
        The second version deletes values of the specified blind data type
        from the mesh's components of a given type. If a component ID is
        provided then the data is only deleted from that component,
        otherwise it is deleted from all of the mesh's components of the
        specified type. If a blind data attribute name is provided then only
        data for that attribute is deleted, otherwise data for all of the
        blind data type's attributes is deleted.
        """
    
        pass
    
    
    def clearColors(*args, **kwargs):
        """
        clearColors(colorSet='') -> self
        
        Clears out all colors from a colorSet, and leaves behind an empty
        colorset. This method should be used if it is needed to shrink the
        actual size of the color set. In this case, the user should call
        clearColors(), setColors() and then assignColors() to rebuild the
        mapping info.
        
        When called on mesh data, the colors are removed. When called on a
        shape with no history, the colors are removed and the attributes are
        set on the shape. When called on a shape with history, the
        polyColorDel command is invoked and a polyColorDel node is created.
        
        If no colorSet is specified the mesh's current color set will be used.
        """
    
        pass
    
    
    def clearUVs(*args, **kwargs):
        """
        clearUVs(uvSet='') -> self
        
        Clears out all uvs from a uvSet, and leaves behind an empty
        uvset. This method should be used if it is needed to shrink the
        actual size of the uv set. In this case, the user should call
        clearUVs(), setUVs() and then assignUVs() to rebuild the
        mapping info.
        
        When called on mesh data, the uvs are removed. When called on a
        shape with no history, the uvs are removed and the attributes are
        set on the shape. When called on a shape with history, the
        polyMapDel command is invoked and a polyMapDel node is created.
        
        If no uvSet is specified the mesh's current uv set will be used.
        """
    
        pass
    
    
    def closestIntersection(*args, **kwargs):
        """
        closestIntersection(raySource, rayDirection, space, maxParam,
            testBothDirections, faceIds=None, triIds=None, idsSorted=False,
            accelParams=None, tolerance=kIntersectTolerance)
          -> (hitPoint, hitRayParam, hitFace, hitTriangle, hitBary1, hitBary2)
        
        Finds the closest intersection of a ray starting at raySource and
        travelling in rayDirection with the mesh.
        
        If faceIds is specified, then only those faces will be considered
        for intersection. If both faceIds and triIds are given, then the
        triIds will be interpreted as face-relative and each pair of entries
        will be taken as a (face, triangle) pair to be considered for
        intersection. Thus, the face-triangle pair (10, 0) means the first
        triangle on face 10. If neither faceIds nor triIds is given, then
        all face-triangles in the mesh will be considered.
        
        The maxParam and testBothDirections flags can be used to control the
        radius of the search around the raySource point.
        
        The search proceeds by testing all applicable face-triangles looking
        for intersections. If the accelParams parameter is given then the
        mesh builds an intersection acceleration structure based on it. This
        acceleration structure is used to speed up the intersection
        operation, sometimes by a factor of several hundred over the non-
        accelerated case. Once created, the acceleration structure is cached
        and will be reused the next time this method (or anyIntersection()
        or allIntersections()) is called with an identically-configured
        MMeshIsectAccelParams object. If a different MMeshIsectAccelParams
        object is used, then the acceleration structure will be deleted and
        re-created according to the new settings. Once created, the
        acceleration structure will persist until either the object is
        destroyed (or rebuilt by a construction history operation), or the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.
        If the ray hits the mesh, the details of the intersection point
        will be returned as a tuple containing the following:
        * hitPoint (MFloatPoint) - coordinates of the point hit, in
          the space specified by the caller.* hitRayParam (float) - parametric distance along the ray to
          the point hit.* hitFace (int) - ID of the face hit
        * hitTriangle (int) - face-relative ID of the triangle hit
        * hitBary1 (float) - first barycentric coordinate of the
          point hit. If the vertices of the hitTriangle are (v1, v2, v3)
          then the barycentric coordinates are such that the hitPoint =
          (*hitBary1)*v1 + (*hitBary2)*v2 + (1-*hitBary1-*hitBary2)*v3.* hitBary2 (float) - second barycentric coordinate of the point hit.
        If no point was hit then the arrays will all be empty.
        """
    
        pass
    
    
    def collapseEdges(*args, **kwargs):
        """
        collapseEdges(seq of int) -> self
        
        Collapses edges into vertices. The two vertices that create each
        given edge are replaced in turn by one vertex placed at the average
        of the two initial vertex.
        """
    
        pass
    
    
    def collapseFaces(*args, **kwargs):
        """
        collapseFaces(seq of int) -> self
        
        Collapses faces into vertices. Adjacent faces will be collapsed
        together into a single vertex. Non-adjacent faces will be collapsed
        into their own, separate vertices.
        """
    
        pass
    
    
    def copy(*args, **kwargs):
        """
        copy(MObject, parent=kNullObj) -> MObject
        
        Creates a new mesh with the same geometry as the source. Raises
        TypeError if the source is not a mesh node or mesh data object or it
        contains an empty mesh.
        
        If the parent is a kMeshData wrapper (e.g. from MFnMeshData.create())
        then a mesh data object will be created and returned and the wrapper
        will be set to reference it.
        
        If the parent is a transform type node then a mesh node will be
        created and parented beneath it and the return value will be the
        mesh node.
        
        If the parent is any other type of node a TypeError will be raised.
        
        If no parent is provided then a transform node will be created and
        returned and a mesh node will be created and parented under the
        transform.
        """
    
        pass
    
    
    def copyInPlace(*args, **kwargs):
        """
        copyInPlace(MObject) -> self
        
        Replaces the current mesh's geometry with that from the source.
        Raises TypeError if the source is not a mesh node or mesh data
        object or it contains an empty mesh.
        """
    
        pass
    
    
    def copyUVSet(*args, **kwargs):
        """
        copyUVSet(fromName, toName, modifier=None) -> string
        
        Copies the contents of one UV set into another.
        
        If the source UV set does not exist, or if it has the same name as
        the destination, then no copy will be made.
        
        If the destination UV set exists then its contents will be replace
        by a copy of the source UV set.
        
        If the destination UV set does not exist then a new UV set will be
        created and the source UV set will be copied into it. The name of
        the UV set will be that provided with a number appended to the end
        to ensure uniqueness.
        The final name of the destination UV set will be returned.
        
        This method is only valid for functionsets which are attached to
        mesh nodes, not mesh data.
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create(vertices, polygonCounts, polygonConnects, uValues=None, vValues=None, parent=kNullObj) -> MObject
        
        Creates a new polygonal mesh and sets this function set to operate
        on it. This method is meant to be as efficient as possible and thus
        assumes that all the given data is topologically correct.
        If UV values are supplied both parameters must be given and they
        must contain the same number of values, otherwise IndexError will be
        raised. Note that the UVs are simply stored in the mesh, not
        assigned to any vertices. To assign them use assignUVs().
        If the parent is a kMeshData wrapper (e.g. from MFnMeshData.create())
        then a mesh data object will be created and returned and the wrapper
        will be set to reference it.
        If the parent is a transform type node then a mesh node will be
        created and parented beneath it and the return value will be the
        mesh node.
        If the parent is any other type of node a TypeError will be raised.
        
        If no parent is provided then a transform node will be created and
        returned and a mesh node will be created and parented under the
        transform.
        """
    
        pass
    
    
    def createBlindDataType(*args, **kwargs):
        """
        createBlindDataType(blindDataId, ((longName, shortName, typeName), ...)) -> self
        
        Create a new blind data type with the specified attributes.
        
        Each element of the attrs sequence is a tuple containing the long
        name, short name and type name of the attribute. Valid type names
        are 'int', 'float', 'double', 'boolean', 'string' or 'binary'.
        
        Raises RuntimeError if the blind data id is already in use or an
        invalid format was specified.
        """
    
        pass
    
    
    def createColorSet(*args, **kwargs):
        """
        createColorSet(name, clamped, rep=kRGBA, modifier=None, instances=None) -> string
        
        Creates a new, empty color set for this mesh.
        
        If no name is provided 'colorSet#' will be used, where # is a number
        that makes the name unique for this mesh. If a name is provided but
        it conflicts with that of an existing color set then a number will
        be appended to the proposed name to make it unique.
        The return value is the final name used for the new color set.
        
        This method will only work when the functionset is attached to a
        mesh node, not mesh data.
        """
    
        pass
    
    
    def createInPlace(*args, **kwargs):
        """
        createInPlace(vertices, polygonCounts, polygonConnects) -> self
        
        Replaces the existing polygonal mesh with a new one. This method is
        meant to be as efficient as possible and thus assumes that all the
        given data is topologically correct.
        
        The vertices may be given as a sequence of MFloatPoint's or a
        sequence of MPoint's, but not a mix of the two.
        """
    
        pass
    
    
    def createUVSet(*args, **kwargs):
        """
        createUVSet(name, modifier=None, instances=None) -> string
        
        Creates a new, empty UV set for this mesh.
        
        If a UV set with proposed name already exists then a number will be
        appended to the proposed name to name it unique.
        
        If the proposed name is empty then a name of the form uvSet# will be
        used where '#' is a number chosen to ensure that the name is unique.
        
        The name used for the UV set will be returned.
        
        This method is only valid for functionsets which are attached to
        mesh nodes, not mesh data.
        """
    
        pass
    
    
    def currentColorSetName(*args, **kwargs):
        """
        currentColorSetName(instance=kInstanceUnspecified) -> string
        
        Get the name of the 'current' color set. The current color set is
        the one used for color operations when no color set is explicitly
        specified.
        On instanced meshes, color sets may be applied on a per-instance
        basis or may be shared across all instances. When the color sets are
        per-instance, the concept of the current color set has two levels of
        granularity. Namely, the current color set applies to one or more
        instances, plus there are other color sets in the same color set
        family that apply to different instances. The instance arguement is
        used to indicate that if this is a per-instance color set, you are
        interested in the name of the color set that applies to the
        specified instance. When the index is not specified, the current
        color set will be returned regardless of which instance it is for.
        If there is no current color set, then an empty string will be
        returned.
        """
    
        pass
    
    
    def currentUVSetName(*args, **kwargs):
        """
        currentUVSetName(instance=kInstanceUnspecified) -> string
        
        Get the name of the 'current' uv set. The current uv set is
        the one used for uv operations when no uv set is explicitly
        specified.
        On instanced meshes, uv sets may be applied on a per-instance
        basis or may be shared across all instances. When the uv sets are
        per-instance, the concept of the current uv set has two levels of
        granularity. Namely, the current uv set applies to one or more
        instances, plus there are other uv sets in the same uv set
        family that apply to different instances. The instance arguement is
        used to indicate that if this is a per-instance uv set, you are
        interested in the name of the uv set that applies to the
        specified instance. When the index is not specified, the current
        uv set will be returned regardless of which instance it is for.
        If there is no current uv set, then an empty string will be
        returned.
        """
    
        pass
    
    
    def deleteColorSet(*args, **kwargs):
        """
        deleteColorSet(colorSet, modifier=None, currentSelection=None) -> self
        
        Deletes a color set from the mesh.
        
        This method is only valid for functionsets which are attached to
        mesh nodes, not mesh data.
        """
    
        pass
    
    
    def deleteEdge(*args, **kwargs):
        """
        deleteEdge(edgeId, modifier=None) -> self
        
        Deletes the specified edge.
        """
    
        pass
    
    
    def deleteFace(*args, **kwargs):
        """
        deleteFace(faceId, modifier=None) -> self
        
        Deletes the specified face.
        """
    
        pass
    
    
    def deleteUVSet(*args, **kwargs):
        """
        deleteUVSet(uvSet, modifier=None, currentSelection=None) -> self
        
        Deletes a uv set from the mesh.
        
        This method is only valid for functionsets which are attached to
        mesh nodes, not mesh data.
        """
    
        pass
    
    
    def deleteVertex(*args, **kwargs):
        """
        deleteVertex(vertexId, modifier=None) -> self
        
        Deletes the specified vertex.
        """
    
        pass
    
    
    def duplicateFaces(*args, **kwargs):
        """
        duplicateFaces(faces, translation=None) -> self
        
        Duplicates a set of faces and detaches them from the rest of the
        mesh. The resulting mesh will contain one more independant piece of
        geometry.
        """
    
        pass
    
    
    def extractFaces(*args, **kwargs):
        """
        extractFaces(faces, translation=None) -> self
        
        Detaches a set of faces from the rest of the mesh. The resulting
        mesh will contain one more independant piece of geometry.
        """
    
        pass
    
    
    def extrudeEdges(*args, **kwargs):
        """
        extrudeEdges(edges, extrusionCount=1, translation=None, extrudeTogether=True) -> self
        
        Extrude the given edges along a vector. The resulting mesh will have
        extra parallelograms coming out of the given edges and going to the
        new extruded edges. The length of the new polygon is determined by
        the length of the vector. The extrusionCount parameter is the number
        of subsequent extrusions per edges and represents the number of
        polygons that will be created from each given edge to the extruded
        edges.
        """
    
        pass
    
    
    def extrudeFaces(*args, **kwargs):
        """
        extrudeFaces(faces, extrusionCount=1, translation=None, extrudeTogether=True) -> self
        
        Extrude the given faces along a vector. The resulting mesh will have
        extra parallelograms coming out of the given faces and going to the
        new extruded faces. The length of the new polygon is determined by
        the length of the vector. The extrusionCount parameter is the number
        of subsequent extrusions per faces and represents the number of
        polygons that will be created from each given face to the extruded
        faces.
        """
    
        pass
    
    
    def freeCachedIntersectionAccelerator(*args, **kwargs):
        """
        freeCachedIntersectionAccelerator() -> self
        
        If the mesh has a cached intersection accelerator structure, then
        this routine forces it to be deleted. Ordinarily, these structures
        are cached so that series of calls to the closestIntersection(),
        allIntersections(), and anyIntersection() methods can reuse the same
        structure. Once the client is finished with these intersection
        operations, however, they are responsible for freeing the acceleration
        structure, which is what this method does.
        """
    
        pass
    
    
    def generateSmoothMesh(*args, **kwargs):
        """
        generateSmoothMesh(parent=kNullObj, options=None) -> MObject
        
        Creates a new polygonal mesh which is a smoothed version of the one
        to which the functionset is attached. If an options object is supplied
        it will be used to direct the smoothing operation, otherwise the
        mesh's Smooth Mesh Preview attributes will be used.
        
        If the parent is a kMeshData wrapper (e.g. from MFnMeshData.create())
        then a mesh data object will be created and returned.
        If the parent is a transform type node then a mesh node will be
        created and parented beneath it and the return value will be the
        mesh node.
        If the parent is any other type of node a TypeError will be raised.
        
        If no parent is provided then a transform node will be created and
        returned and a mesh node will be created and parented under the
        transform.
        
        Note that, unlike the create functions, this function does not set
        the functionset to operate on the new mesh, but leaves it attached
        to the original mesh.
        """
    
        pass
    
    
    def getAssignedUVs(*args, **kwargs):
        """
        getAssignedUVs(uvSet='') -> (counts, uvIds)
        
        Returns a tuple containing all of the UV assignments for the specified
        UV set. The first element of the tuple is an array of counts giving
        the number of UVs assigned to each face of the mesh. The count will
        either be zero, indicating that that face's vertices do not have UVs
        assigned, or else it will equal the number of the face's vertices.
        The second element of the tuple is an array of UV IDs for all of the
        face-vertices which have UVs assigned.
        """
    
        pass
    
    
    def getAssociatedColorSetInstances(*args, **kwargs):
        """
        getAssociatedColorSetInstances(colorSet) -> MIntArray
        
        Returns the instance numbers associated with the specified Color set.
        If the color map is shared across all instances, an empty array will
        be returned.
        
        This method will only work if the functionset is attached to a mesh
        node. It will raise RuntimeError if the functionset is attached to
        mesh data.
        """
    
        pass
    
    
    def getAssociatedUVSetInstances(*args, **kwargs):
        """
        getAssociatedUVSetInstances(uvSet) -> MIntArray
        
        Returns the instance numbers associated with the specified UV set.
        If the uv map is shared across all instances, an empty array will be
        returned.
        
        This method will only work if the functionset is attached to a mesh
        node. It will raise RuntimeError if the functionset is attached to
        mesh data.
        """
    
        pass
    
    
    def getAssociatedUVSetTextures(*args, **kwargs):
        """
        getAssociatedUVSetTextures(uvSet) -> MObjectArray
        
        Returns the texture nodes which are using the specified UV set. If
        the texture has a 2d texture placement, the texture, and not the
        placement will be returned.
        
        This method will only work if the functionset is attached to a mesh
        node. It will raise RuntimeError if the functionset is attached to
        mesh data.
        """
    
        pass
    
    
    def getBinaryBlindData(*args, **kwargs):
        """
        getBinaryBlindData(compId, compType, blindDataId, attr) -> string
        getBinaryBlindData(compType, blindDataId, attr)
          -> (MIntArray, [string, string, ...])
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of 'binary'
        type.
        """
    
        pass
    
    
    def getBinormals(*args, **kwargs):
        """
        getBinormals(space=MSpace.kObject, uvSet='') -> MFloatVectorArray
        
        Returns the binormal vectors for all face-vertices.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getBlindDataAttrNames(*args, **kwargs):
        """
        getBlindDataAttrNames(blindDataId) -> ((longName, shortName, typeName), ...)
        
        Returns a tuple listing the attributes of the given blind data type.
        Each element of the tuple is itself a tuple containing the long
        name, short name and type name of the attribute. Type names can be
        'int', 'float', 'double', 'boolean', 'string' or 'binary'.
        """
    
        pass
    
    
    def getBlindDataTypes(*args, **kwargs):
        """
        getBlindDataTypes(MFn Type constant) -> MIntArray
        
        Returns all the blind data ID's associated with the given component
        type on this mesh.
        """
    
        pass
    
    
    def getBoolBlindData(*args, **kwargs):
        """
        getBoolBlindData(compId, compType, blindDataId, attr) -> bool
        getBoolBlindData(compType, blindDataId, attr) -> (MIntArray, MIntArray)
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of
        'boolean' type.
        """
    
        pass
    
    
    def getClosestNormal(*args, **kwargs):
        """
        getClosestNormal(MPoint, space=MSpace.kObject) -> (MVector, int)
        
        Returns a tuple containing the normal at the closest point on the
        mesh to the given point and the ID of the face in which that closest
        point lies.
        """
    
        pass
    
    
    def getClosestPoint(*args, **kwargs):
        """
        getClosestPoint(MPoint, space=MSpace.kObject) -> (MPoint, int)
        
        Returns a tuple containing the closest point on the mesh to the
        given point and the ID of the face in which that closest point lies.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getClosestPointAndNormal(*args, **kwargs):
        """
        getClosestPointAndNormal(MPoint, space=MSpace.kObject)
          -> (MPoint, MVector, int)
        
        Returns a tuple containing the closest point on the mesh to the
        given point, the normal at that point, and the ID of the face in
        which that point lies.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getColor(*args, **kwargs):
        """
        getColor(colorId, colorSet='') -> MColor
        
        Returns a color from a colorSet. Raises IndexError if the colorId is
        out of range.
        """
    
        pass
    
    
    def getColorIndex(*args, **kwargs):
        """
        getColorIndex(faceId, localVertexId, colorSet='') -> int
        
        Returns the index into the specified colorSet of the color used by a
        specific face-vertex. This can be used to index into the sequence
        returned by getColors().
        """
    
        pass
    
    
    def getColorRepresentation(*args, **kwargs):
        """
        getColorRepresentation(colorSet) -> Color Representation constant
        
        Returns the Color Representation used by the specified color set.
        """
    
        pass
    
    
    def getColorSetFamilyNames(*args, **kwargs):
        """
        getColorSetFamilyNames() -> (string, ...)
        
        Returns the names of all of the color set families on this object. A
        color set family is a set of per-instance sets with the same name
        with each individual set applying to one or more instances. A set
        which is shared across all instances will be the sole member of its
        family.
        
        Given a color set family name, getColorSetsInFamily() may be used to
        determine the names of the associated individual sets.
        """
    
        pass
    
    
    def getColorSetNames(*args, **kwargs):
        """
        getColorSetNames() -> (string, ...)
        
        Returns the names of all the color sets on this object.
        """
    
        pass
    
    
    def getColorSetsInFamily(*args, **kwargs):
        """
        getColorSetsInFamily(familyName) -> (string, ...)
        
        Returns the names of all of the color sets that belong to the
        specified family. Per-instance sets will have multiple sets in a
        family, with each individual set applying to one or more instances.
        A set which is shared across all instances will be the sole member
        of its family and will share the same name as its family.
        """
    
        pass
    
    
    def getColors(*args, **kwargs):
        """
        getColors(colorSet='') -> MColorArray
        
        Returns all of the colors in a colorSet. If no colorSet is specified
        then the default colorSet is used.
        
        Use the index returned by getColorIndex() to access the returned
        array.
        """
    
        pass
    
    
    def getConnectedSetsAndMembers(*args, **kwargs):
        """
        getConnectedSetsAndMembers(instance, renderableSetsOnly) -> (MObjectArray, MObjectArray)
        
        Returns a tuple containing an array of sets and an array of the
        components of the mesh which are in those sets. If a component has
        no elements in it that means that the entire mesh is in the set.
        
        This method will only work if the functionset is attached to a mesh
        node. It will raise RuntimeError if the functionset is attached to
        mesh data.
        """
    
        pass
    
    
    def getConnectedShaders(*args, **kwargs):
        """
        getConnectedShaders(instance) -> (MObjectArray, MIntArray)
        
        Returns a tuple containing an array of shaders (sets) and an array
        of ints mapping the mesh's polygons onto those shaders. For each
        polygon in the mesh there will be corresponding value in the second
        array. If it is -1 that means that the polygon is not assigned to a
        shader, otherwise it indicates the index into the first array of the
        shader to which that polygon is assigned.
        
        This method will only work if the functionset is attached to a mesh
        node. It will raise RuntimeError if the functionset is attached to
        mesh data.
        """
    
        pass
    
    
    def getCreaseEdges(*args, **kwargs):
        """
        getCreaseEdges() -> (MUintArray, MDoubleArray)
        
        Returns a tuple containing two arrays. The first contains the mesh-
        relative/global IDs of the mesh's creased edges and the second
        contains the associated crease data.
        
        Please note that to make effective use of the creasing variable in
        software outside of Maya may require a license under patents owned
        by Pixar(R).
        """
    
        pass
    
    
    def getCreaseVertices(*args, **kwargs):
        """
        getCreaseVertices() -> (MUintArray, MDoubleArray)
        
        Returns a tuple containing two arrays. The first contains the mesh-
        relative/global IDs of the mesh's creased vertices and the second
        contains the associated crease data.
        
        Please note that to make effective use of the creasing variable in
        software outside of Maya may require a license under patents owned
        by Pixar(R).
        """
    
        pass
    
    
    def getDoubleBlindData(*args, **kwargs):
        """
        getDoubleBlindData(compId, compType, blindDataId, attr) -> float
        getDoubleBlindData(compType, blindDataId, attr) -> (MIntArray, MDoubleArray)
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of
        'double' type.
        """
    
        pass
    
    
    def getEdgeVertices(*args, **kwargs):
        """
        getEdgeVertices(edgeId) -> (int, int)
        
        Returns a tuple containing the mesh-relative/global IDs of the
        edge's two vertices. The indices can be used to refer to the
        elements in the array returned by the getPoints() method.
        """
    
        pass
    
    
    def getFaceAndVertexIndices(*args, **kwargs):
        """
        getFaceAndVertexIndices(faceVertexIndex, localVertex=True) -> (int, int)
        
        Returns a tuple containg the faceId and vertexIndex represented by
        the given face-vertex index. This is the reverse of the operation
        performed by getFaceVertexIndex().
        
        If localVertex is True then the returned vertexIndex is the face-
        relative/local index, otherwise it is the mesh-relative/global index.
        """
    
        pass
    
    
    def getFaceNormalIds(*args, **kwargs):
        """
        getFaceNormalIds(faceId) -> MIntArray
        
        Returns the IDs of the normals for all the vertices of a given face.
        These IDs can be used to index into the arrays returned by getNormals().
        """
    
        pass
    
    
    def getFaceUVSetNames(*args, **kwargs):
        """
        getFaceUVSetNames(faceId) -> (string, ...)
        
        Returns the names of all of the uv sets mapped to the specified face.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexBinormal(*args, **kwargs):
        """
        getFaceVertexBinormal(faceId, vertexId, space=MSpace.kObject, uvSet='') -> MVector
        
        Returns the binormal vector at a given face vertex.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexBinormals(*args, **kwargs):
        """
        getFaceVertexBinormals(faceId, space=MSpace.kObject, uvSet='') -> MFloatVectorArray
        
        Returns all the per-vertex-per-face binormals for a given face.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexColors(*args, **kwargs):
        """
        getFaceVertexColors(colorSet='', defaultUnsetColor=None) -> MColorArray
        
        Returns colors for all the mesh's face-vertices.
        
        The colors are returned in face order: e.g. F0V0, F0V1.. F0Vn, F1V0,
        etc... Use the index returned by getFaceVertexIndex() if you wish to
        index directly into the returned color array.
        
        If no face has color for that vertex, the entry returned will be
        defaultUnsetColor. If a color was set for some but not all the faces
        for that vertex, the ones where the color has not been explicitly set
        will return (0,0,0). If a vertex has shared color, the same value
        will be set for all its vertes/faces.
        
        If the colorSet is not specified, the default color set will be used.
        If the defaultUnsetColor is not given, then (-1, -1, -1, -1) will be
        used.
        """
    
        pass
    
    
    def getFaceVertexIndex(*args, **kwargs):
        """
        getFaceVertexIndex(faceId, vertexIndex, localVertex=True) -> int
        
        Returns the index for a specific face-vertex into an array of face-
        vertex values, such as those returned by getFaceVertexBinormals(),
        getFaceVertexColors(), getFaceVertexNormals(), etc.
        
        The values in the target arrays are presumed to be in face order:
        F0V0, F0V1.. F0Vn, F1V0, etc...
        If localVertex is True then vertexIndex must be a face-relative/local
        index. If localVertex is False then vertexIndex must be a mesh-
        relative/global index.
        
        The opposite operation is performed by the getFaceAndVertexIndices()
        method.
        """
    
        pass
    
    
    def getFaceVertexNormal(*args, **kwargs):
        """
        getFaceVertexNormal(faceId, vertexId, space=MSpace.kObject) -> MVector
        
        Returns the per-vertex-per-face normal for a given face and vertex.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexNormals(*args, **kwargs):
        """
        getFaceVertexNormals(faceId, space=MSpace.kObject) -> MFloatVectorArray
        
        Returns the normals for a given face.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexTangent(*args, **kwargs):
        """
        getFaceVertexTangent(faceId, vertexId, space=MSpace.kObject, uvSet='') -> MVector
        
        Return the normalized tangent vector at a given face vertex.
        
        The tangent is defined as the surface tangent of the polygon running
        in the U direction defined by the uv map.
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFaceVertexTangents(*args, **kwargs):
        """
        getFaceVertexTangents(faceId, space=MSpace.kObject, uvSet='') -> MFloatVectorArray
        
        Returns all the per-vertex-per-face tangents for a given face.
        
        The tangent is defined as the surface tangent of the polygon running
        in the U direction defined by the uv map.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getFloatBlindData(*args, **kwargs):
        """
        getFloatBlindData(compId, compType, blindDataId, attr) -> float
        getFloatBlindData(compType, blindDataId, attr) -> (MIntArray, MFloatArray)
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of
        'float' type.
        """
    
        pass
    
    
    def getFloatPoints(*args, **kwargs):
        """
        getFloatPoints(space=MSpace.kObject) -> MFloatPointArray
        
        Returns an MFloatPointArray containing the mesh's vertices.
        """
    
        pass
    
    
    def getHoles(*args, **kwargs):
        """
        getHoles() -> ((face, (v1, v2, ...)), (face, (v1, v2, ...)), ...)
        
        Returns a tuple describing the holes in the mesh. Each element of the
        tuple is itself a tuple. The first element of the sub-tuple is the
        integer ID of the face in which the hole occurs. The second element
        of the sub-tuple is another tuple containing the mesh-relative/global
        IDs of the vertices which make up the hole.
        
        Take the following return value as an example:
        
            ((3, (7, 2, 6)), (5, (11, 10, 3, 4)))
        
        This says that the mesh has two holes. The first hole is in face 3
        and consists of vertices 7, 2 and 6. The second hole is in face 5 and
        consists of vertices 11, 10, 3 and 4.
        """
    
        pass
    
    
    def getIntBlindData(*args, **kwargs):
        """
        getIntBlindData(compId, compType, blindDataId, attr) -> int
        getIntBlindData(compType, blindDataId, attr) -> (MIntArray, MIntArray)
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of
        'int' type.
        """
    
        pass
    
    
    def getInvisibleFaces(*args, **kwargs):
        """
        getInvisibleFaces() -> MUintArray
        
        Returns the invisible faces of the mesh. Invisible faces are like
        lightweight holes in that they are not rendered but do not require
        additional geometry the way that holes do. They have the advantage
        over holes that if the mesh is smoothed then their edges will be
        smoothed as well, while holes will retain their hard edges.
        
        Invisible faces can be set using the setInvisibleFaces() method or
        the polyHole command.
        """
    
        pass
    
    
    def getNormalIds(*args, **kwargs):
        """
        getNormalIds() -> (MIntArray, MIntArray)
        
        Returns the normal IDs for all of the mesh's polygons as a tuple of
        two int arrays. The first array contains the number of vertices for
        each polygon and the second contains the normal IDs for each polygon-
        vertex. These IDs can be used to index into the array returned by
        getNormals().
        """
    
        pass
    
    
    def getNormals(*args, **kwargs):
        """
        getNormals(space=MSpace.kObject) -> MFloatVectorArray
        
        Returns a copy of the mesh's normals. The normals are the per-polygon
        per-vertex normals. To find the normal for a particular vertex-face,
        use getFaceNormalIds() to get the index into the array.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getPoint(*args, **kwargs):
        """
        getPoint(vertexId, space=MSpace.kObject) -> MPoint
        
        Returns the position of specified vertex.
        """
    
        pass
    
    
    def getPointAtUV(*args, **kwargs):
        """
        getPointAtUV(faceId, u, v, space=MSpace.kObject, uvSet='', tolerance=0.0) -> MPoint
        
        Returns the position of the point at the give UV value in the
        specified face.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getPoints(*args, **kwargs):
        """
        getPoints(space=MSpace.kObject) -> MPointArray
        
        Returns a copy of the mesh's vertex positions as an MPointArray.
        """
    
        pass
    
    
    def getPolygonNormal(*args, **kwargs):
        """
        getPolygonNormal(polygonId, space=MSpace.kObject) -> MVector
        
        Returns the per-polygon normal for the given polygon.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getPolygonTriangleVertices(*args, **kwargs):
        """
        getPolygonTriangleVertices(polygonId, triangleId) -> (int, int, int)
        
        Returns the mesh-relative/global IDs of the 3 vertices of the
        specified triangle of the specified polygon. These IDs can be used
        to index into the arrays returned by getPoints() and getFloatPoints().
        """
    
        pass
    
    
    def getPolygonUV(*args, **kwargs):
        """
        getPolygonUV(polygonId, vertexId, uvSet='') -> (float, float)
        
        Returns a tuple containing the U and V values at a specified vertex
        of a specified polygon.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getPolygonUVid(*args, **kwargs):
        """
        getPolygonUVid(polygonId, vertexId, uvSet='') -> int
        
        Returns the ID of the UV at a specified vertex of a specified polygon.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getPolygonVertices(*args, **kwargs):
        """
        getPolygonVertices(polygonId) -> MIntArray
        
        Returns the mesh-relative/global vertex IDs the specified polygon.
        These IDs can be used to index into the arrays returned by getPoints()
        and getFloatPoints().
        """
    
        pass
    
    
    def getSmoothMeshDisplayOptions(*args, **kwargs):
        """
        getSmoothMeshDisplayOptions() -> MMeshSmoothOptions
        
        Returns the options currently in use when smoothing the mesh for display.
        """
    
        pass
    
    
    def getStringBlindData(*args, **kwargs):
        """
        getStringBlindData(compId, compType, blindDataId, attr) -> string
        getStringBlindData(compType, blindDataId, attr)
          -> (MIntArray, [string, string, ...])
        
        The first version returns the value of the specified blind data
        attribute from the specified mesh component.
        
        The second version returns a tuple containing an array of component
        IDs and an array of values for the specified blind data attribute
        for all of the mesh's components of the specified type.
        
        Both versions raise RuntimeError if the attribute is not of 'string'
        type.
        """
    
        pass
    
    
    def getTangentId(*args, **kwargs):
        """
        getTangentId(faceId, vertexId) -> int
        
        Returns the ID of the tangent for a given face and vertex.
        """
    
        pass
    
    
    def getTangents(*args, **kwargs):
        """
        getTangents(space=MSpace.kObject, uvSet='') -> MFloatVectorArray
        
        Return the tangent vectors for all face vertices. The tangent is
        defined as the surface tangent of the polygon running in the U
        direction defined by the uv map.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getTriangles(*args, **kwargs):
        """
        getTriangles() -> (MIntArray, MIntArray)
        
        Returns a tuple describing the mesh's triangulation. The first
        element of the tuple is an array giving the number of triangles for
        each of the mesh's polygons. The second tuple gives the ids of the
        vertices of all the triangles.
        """
    
        pass
    
    
    def getUV(*args, **kwargs):
        """
        getUV(uvId, uvSet='') -> (float, float)
        
        Returns a tuple containing the u and v values of the specified UV.
        """
    
        pass
    
    
    def getUVAtPoint(*args, **kwargs):
        """
        getUVAtPoint(point, space=MSpace.kObject, uvSet='') -> (float, float, int)
        
        Returns a tuple containing the u and v coordinates of the point on
        the mesh closest to the given point, and the ID of the face
        containing that closest point.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getUVSetFamilyNames(*args, **kwargs):
        """
        getUVSetFamilyNames() -> (string, ...)
        
        Returns the names of all of the uv set families on this object. A
        uv set family is a set of per-instance sets with the same name
        with each individual set applying to one or more instances. A set
        which is shared across all instances will be the sole member of its
        family.
        
        Given a uv set family name, getUVSetsInFamily() may be used to
        determine the names of the associated individual sets.
        """
    
        pass
    
    
    def getUVSetNames(*args, **kwargs):
        """
        getUVSetNames() -> (string, ...)
        
        Returns the names of all the uv sets on this object.
        """
    
        pass
    
    
    def getUVSetsInFamily(*args, **kwargs):
        """
        getUVSetsInFamily(familyName) -> (string, ...)
        
        Returns the names of all of the uv sets that belong to the
        specified family. Per-instance sets will have multiple sets in a
        family, with each individual set applying to one or more instances.
        A set which is shared across all instances will be the sole member
        of its family and will share the same name as its family.
        """
    
        pass
    
    
    def getUVs(*args, **kwargs):
        """
        getUVs(uvSet='') -> (MFloatArray, MFloatArray)
        
        Returns a tuple containing an array of U values and an array of V
        values, representing all of the UVs for the given UV set.
        """
    
        pass
    
    
    def getUvShellsIds(*args, **kwargs):
        """
        getUvShellsIds(uvSet='') -> (int, MIntArray)
        
        Returns a tuple containing describing how the specified UV set's UVs
        are grouped into shells. The first element of the tuple is the number
        of distinct shells. The second element of the tuple is an array of
        shell indices, one per uv, indicating which shell that uv is part of.
        """
    
        pass
    
    
    def getVertexColors(*args, **kwargs):
        """
        getVertexColors(colorSet='', defaultUnsetColor=None) -> MColorArray
        
        Gets colors for all vertices of the given colorSet. If no face has
        color for that vertex, the entry returned will be defaultUnsetColor.
        If a color was set for some or all the faces for that vertex, an
        average of those vertex/face values where the color has been set will
        be returned.
        
        If the colorSet is not specified, the default color set will be used.
        If the defaultUnsetColor is not given, then (-1, -1, -1, -1) will be
        used.
        """
    
        pass
    
    
    def getVertexNormal(*args, **kwargs):
        """
        getVertexNormal(vertexId, angleWeighted, space=MSpace.kObject) -> MVector
        
        Returns the normal at the given vertex. The returned normal is a
        single per-vertex normal, so unshared normals at a vertex will be
        averaged.
        
        If angleWeighted is set to true, the normals are computed by an
        average of surrounding face normals weighted by the angle subtended
        by the face at the vertex. If angleWeighted is set to false, a simple
        average of surround face normals is returned.
        
        The simple average evaluation is significantly faster than the angle-
        weighted average.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getVertexNormals(*args, **kwargs):
        """
        getVertexNormals(angleWeighted, space=MSpace.kObject) -> MFloatVectorArray
        
        Returns all the vertex normals. The returned normals are per-vertex
        normals, so unshared normals at a vertex will be averaged.
        
        If angleWeighted is set to True, the normals are computed by an
        average of surrounding face normals weighted by the angle subtended
        by the face at the vertex. If angleWeighted is set to false, a simple
        average of surround face normals is returned.
        
        The simple average evaluation is significantly faster than the angle-
        weighted average.
        
        This method is not threadsafe.
        """
    
        pass
    
    
    def getVertices(*args, **kwargs):
        """
        getVertices() -> (MIntArray, MIntArray)
        
        Returns the mesh-relative/global vertex IDs for all of the mesh's
        polygons as a tuple of two int arrays. The first array contains the
        number of vertices for each polygon and the second contains the mesh-
        relative IDs for each polygon-vertex. These IDs can be used to index
        into the arrays returned by getPoints() and getFloatPoints().
        """
    
        pass
    
    
    def hasAlphaChannels(*args, **kwargs):
        """
        hasAlphaChannels(colorSet) -> bool
        
        Returns True if the color set has an alpha channel.
        """
    
        pass
    
    
    def hasBlindData(*args, **kwargs):
        """
        hasBlindData(compType, compId=None, blindDataId=None) -> bool
        
        Returns true if any component of the given type on this mesh has
        blind data. If a component ID is provided then only that particular
        component is checked. If a blind data ID is provided then only blind
        data of that type is checked.
        """
    
        pass
    
    
    def hasColorChannels(*args, **kwargs):
        """
        hasColorChannels(colorSet) -> bool
        
        Returns True if the color set has RGB channels.
        """
    
        pass
    
    
    def isBlindDataTypeUsed(*args, **kwargs):
        """
        isBlindDataTypeUsed(blindDataId) -> bool
        
        Returns True if the blind data type is already in use anywhere in the scene.
        """
    
        pass
    
    
    def isColorClamped(*args, **kwargs):
        """
        isColorClamped(colorSet) -> bool
        
        Returns True if the color sets RGBA components are clamped to the
        range 0 to 1.
        """
    
        pass
    
    
    def isColorSetPerInstance(*args, **kwargs):
        """
        isColorSetPerInstance(colorSet) -> bool
        
        Returns True if the color set is per-instance, and False if it is
        shared across all instances.
        """
    
        pass
    
    
    def isEdgeSmooth(*args, **kwargs):
        """
        isEdgeSmooth(edgeId) -> bool
        
        Returns True if the edge is smooth, False if it is hard.
        """
    
        pass
    
    
    def isNormalLocked(*args, **kwargs):
        """
        isNormalLocked(normalId) -> bool
        
        Returns True if the normal is locked, False otherwise.
        """
    
        pass
    
    
    def isPolygonConvex(*args, **kwargs):
        """
        isPolygonConvex(faceId) -> bool
        
        Returns True if the polygon is convex, False if it is concave.
        """
    
        pass
    
    
    def isUVSetPerInstance(*args, **kwargs):
        """
        isUVSetPerInstance(uvSet) -> bool
        
        Returns True if the UV set is per-instance, and False if it is shared
        across all instances.
        """
    
        pass
    
    
    def lockFaceVertexNormals(*args, **kwargs):
        """
        lockFaceVertexNormals(seq of faceIds, seq of vertIds) -> self
        
        Locks the normals for the given face/vertex pairs.
        """
    
        pass
    
    
    def lockVertexNormals(*args, **kwargs):
        """
        lockVertexNormals(sequence of vertIds) -> self
        
        Locks the shared normals for the specified vertices.
        """
    
        pass
    
    
    def numColors(*args, **kwargs):
        """
        numColors(colorSet='') -> int
        
        Returns the number of colors in the given color set. If no color set
        is specified then the mesh's current color set will be used.
        """
    
        pass
    
    
    def numUVs(*args, **kwargs):
        """
        numUVs(uvSet='') -> int
        
        Returns the number of UVs (texture coordinates) in the given UV set.
        If no UV set is specified then the mesh's current UV set will be used.
        """
    
        pass
    
    
    def onBoundary(*args, **kwargs):
        """
        onBoundary(faceId) -> bool
        
        Returns true if the face is on the border of the mesh, meaning that
        one or more of its edges is a border edge.
        """
    
        pass
    
    
    def polygonVertexCount(*args, **kwargs):
        """
        polygonVertexCount(faceId) -> int
        
        Returns the number of vertices in the given polygon. Raises
        ValueError if the polygon ID is invalid.
        """
    
        pass
    
    
    def removeFaceColors(*args, **kwargs):
        """
        removeFaceColors(seq of faceIds) -> self
        
        Removes colors from all vertices of the specified faces.
        """
    
        pass
    
    
    def removeFaceVertexColors(*args, **kwargs):
        """
        removeFaceVertexColors(seq of faceIds, seq of vertexIds) -> self
        
        Removes colors from the specified face/vertex pairs.
        """
    
        pass
    
    
    def removeVertexColors(*args, **kwargs):
        """
        removeVertexColors(seq of vertexIds) -> self
        
        Removes colors from the specified vertices in all of the faces which
        share those vertices.
        """
    
        pass
    
    
    def renameUVSet(*args, **kwargs):
        """
        renameUVSet(origName, newName, modifier=None) -> self
        
        Renames a UV set. The set must exist and the new name cannot be the
        same as that of an existing set.
        
        This method is only valid for functionsets which are attached to mesh
        nodes, not mesh data.
        """
    
        pass
    
    
    def setBinaryBlindData(*args, **kwargs):
        """
        setBinaryBlindData(compId, compType, blindDataId, attr, data) -> self
        setBinaryBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'binary' blind data attribute
        on a single component of the mesh. The data must be a single string.
        
        The second version sets the value of a 'binary' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        strings then it must provide a value for each component in compIds.
        If it is a single string then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setBoolBlindData(*args, **kwargs):
        """
        setBoolBlindData(compId, compType, blindDataId, attr, data) -> self
        setBoolBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'boolean' blind data attribute
        on a single component of the mesh. The data must be a single boolean.
        
        The second version sets the value of a 'boolean' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        booleans then it must provide a value for each component in compIds.
        If it is a single boolean then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setColor(*args, **kwargs):
        """
        setColor(colorId, MColor, colorSet='', rep=kRGBA) -> self
        
        Sets a color in the specified colorSet. If no colorSet is given the
        current colorSet will be used. If the colorId is greater than or
        equal to numColors() then the colorSet will be grown to accommodate
        the specified color.
        """
    
        pass
    
    
    def setColors(*args, **kwargs):
        """
        setColors(seq of MColor, colorSet='', rep=kRGBA) -> self
        
        Sets all the colors of the specified colorSet. If no colorSet is
        given the current colorSet will be used. After using this method to
        set the color values, you can call assignColors() to assign the
        corresponding color ids to the geometry.
        
        The color sequence must be at least as large as the current color set
        size. You can determine the color set size by calling numColors() for
        the default color set, or numColors(colorSet) for a named color set.
        If the sequence is larger than the color set size, then the color set
        for this mesh will be expanded to accommodate the new color values.
        
        In order to shrink the colorSet you have to clear its existing
        colors. E.g: clearColors(), setColors( ... ), assignColors()
        """
    
        pass
    
    
    def setCreaseEdges(*args, **kwargs):
        """
        setCreaseEdges(edgeIds, seq of float) -> self
        
        
        Sets the specified edges of the mesh as crease edges.
        
        Please note that to make effective use of the creasing variable in
        software outside of Maya may require a license under patents owned by
        Pixar(R).
        """
    
        pass
    
    
    def setCreaseVertices(*args, **kwargs):
        """
        setCreaseVertices(edgeIds, seq of float) -> self
        
        
        Sets the specified edges of the mesh as crease edges.
        
        Please note that to make effective use of the creasing variable in
        software outside of Maya may require a license under patents owned by
        Pixar(R).
        """
    
        pass
    
    
    def setCurrentColorSetName(*args, **kwargs):
        """
        setCurrentColorSetName(colorSet, modifier=None, currentSelection=None) -> self
        
        Sets the 'current' color set for this object. The current color set
        is the one used when no color set name is specified for a color
        operation. If the specified color set does not exist then the current
        color set will not be changed.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        
        This method may change the current selection. If the 'currentSelection'
        (MSelectionList) parameter is provided then the current selection
        will be saved to it prior to the change. This is useful for
        supporting full undo of the change.
        
        This method is only valid for functionsets which are attached to mesh
        nodes, not mesh data.
        """
    
        pass
    
    
    def setCurrentUVSetName(*args, **kwargs):
        """
        setCurrentUVSetName(uvSet, modifier=None, currentSelection=None) -> self
        
        Sets the 'current' uv set for this object. The current uv set is the
        one used when no uv set name is specified for a uv operation. If the
        specified uv set does not exist then the current uv set will not be
        changed.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        
        This method may change the current selection. If the 'currentSelection'
        (MSelectionList) parameter is provided then the current selection
        will be saved to it prior to the change. This is useful for
        supporting full undo of the change.
        
        This method is only valid for functionsets which are attached to mesh
        nodes, not mesh data.
        """
    
        pass
    
    
    def setDoubleBlindData(*args, **kwargs):
        """
        setDoubleBlindData(compId, compType, blindDataId, attr, data) -> self
        setDoubleBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'double' blind data attribute
        on a single component of the mesh. The data must be a single float.
        
        The second version sets the value of a 'double' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        floats then it must provide a value for each component in compIds.
        If it is a single float then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setEdgeSmoothing(*args, **kwargs):
        """
        setEdgeSmoothing(edgeId, smooth=True) -> self
        
        Sets the specified edge to be hard or smooth. You must use the
        cleanupEdgeSmoothing() method after all the desired edges on your
        mesh have had setEdgeSmoothing() done. Use the updateSurface() method
        to indicate the mesh needs to be redrawn.
        """
    
        pass
    
    
    def setFaceColor(*args, **kwargs):
        """
        setFaceColor(color, faceId, rep=kRGBA) -> self
        
        Sets the face-vertex color for all vertices on this face.
        """
    
        pass
    
    
    def setFaceColors(*args, **kwargs):
        """
        setFaceColors(colors, faceIds, rep=kRGBA) -> self
        
        Sets the colors of the specified faces. For each face in the faceIds
        sequence the corresponding color from the colors sequence will be
        applied to all of its vertices.
        """
    
        pass
    
    
    def setFaceVertexColor(*args, **kwargs):
        """
        setFaceVertexColor(color, faceId, vertexId, modifier=None, rep=kRGBA) -> self
        
        Sets a face-specific normal at a vertex.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setFaceVertexColors(*args, **kwargs):
        """
        setFaceVertexColors(colors, faceIds, vertexIds, modifier=None, rep=kRGBA) -> self
        
        Sets the colors of the specified face/vertex pairs.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setFaceVertexNormal(*args, **kwargs):
        """
        setFaceVertexNormal(normal, faceId, vertexId, space=MSpace.kObject, modifier=None) -> self
        
        Sets a face-specific normal at a vertex.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setFaceVertexNormals(*args, **kwargs):
        """
        setFaceVertexNormal(normals, faceIds, vertexIds, space=MSpace.kObject) -> self
        
        Sets normals for the given face/vertex pairs.
        """
    
        pass
    
    
    def setFloatBlindData(*args, **kwargs):
        """
        setFloatBlindData(compId, compType, blindDataId, attr, data) -> self
        setFloatBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'float' blind data attribute
        on a single component of the mesh. The data must be a single float.
        
        The second version sets the value of a 'float' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        floats then it must provide a value for each component in compIds.
        If it is a single float then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setIntBlindData(*args, **kwargs):
        """
        setIntBlindData(compId, compType, blindDataId, attr, data) -> self
        setIntBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'int' blind data attribute
        on a single component of the mesh. The data must be a single int.
        
        The second version sets the value of a 'int' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        ints then it must provide a value for each component in compIds.
        If it is a single int then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setInvisibleFaces(*args, **kwargs):
        """
        setInvisibleFaces(faceIds, makeVisible=False) -> self
        
        Sets the specified faces of the mesh to be visible or invisible. See
        the getInvisibleFaces() method for a description of invisible faces.
        """
    
        pass
    
    
    def setIsColorClamped(*args, **kwargs):
        """
        setIsColorClamped(colorSet, clamped) -> self
        
        Sets whether the color set's RGBA components should be clamped to the
        range 0 to 1.
        """
    
        pass
    
    
    def setNormals(*args, **kwargs):
        """
        setNormals(normals, space=MSpace.kObject) -> self
        
        Sets the mesh's normals (user normals).
        """
    
        pass
    
    
    def setPoint(*args, **kwargs):
        """
        setPoint(vertexId, MPoint, space=MSpace.kObject) -> self
        
        Sets the position of specified vertex.
        
        Note that if you modify the position of a vertex for a mesh node (as
        opposed to mesh data), a tweak will be created. If you have a node
        with no history, the first time that a tweak is created, the
        underlying pointers under the MFnMesh object may change. You will
        need to call syncObject() to make sure that the object is valid.
        Subsequent calls to setPoint() on the same object do not require a
        syncObject() call.
        """
    
        pass
    
    
    def setPoints(*args, **kwargs):
        """
        setPoints(points, space=MSpace.kObject) -> self
        
        Sets the positions of the mesh's vertices. The positions may be
        given as a sequence of MFloatPoint's or a sequence of MPoint's, but
        not a mix of the two.
        """
    
        pass
    
    
    def setSmoothMeshDisplayOptions(*args, **kwargs):
        """
        setSmoothMeshDisplayOptions(MMeshSmoothOptions) -> self
        
        Sets the options to use when smoothing the mesh for display.
        """
    
        pass
    
    
    def setSomeColors(*args, **kwargs):
        """
        setSomeColors(colorIds, colors, colorSet='', rep=kRGBA) -> self
        
        Sets specific colors in a colorSet.
        
        If the largest colorId in the sequence is larger than numColors()
        then the colorSet will be grown to accommodate the new color values.
        If you have added new colorIds, you can call assignColors to assign
        the colorIds to the geometry. If you are modifying existing colors,
        they will already be referenced by the existing mesh data.
        """
    
        pass
    
    
    def setSomeUVs(*args, **kwargs):
        """
        setSomeUVs(uvIds, uValues, vValues, uvSet='') -> self
        
        Sets the specified texture coordinates (uv's) for this mesh. The uv
        value sequences and the uvIds sequence must all be of equal size. If
        the largest uvId in the array is larger than numUVs() then the uv
        list for this mesh will be grown to accommodate the new uv values.
        If a named uv set is given, the array will be grown when the largest
        uvId is larger than numUVs(uvSet).
        
        If you have added new uvIds, you must call one of the assignUV
        methods to assign the uvIds to the geometry. If you are modifying
        existing UVs, you do not need to call one of the assignUV methods.
        """
    
        pass
    
    
    def setStringBlindData(*args, **kwargs):
        """
        setStringBlindData(compId, compType, blindDataId, attr, data) -> self
        setStringBlindData(seq of compId, compType, blindDataId, attr, data) -> self
        
        The first version sets the value of a 'string' blind data attribute
        on a single component of the mesh. The data must be a single string.
        
        The second version sets the value of a 'string' blind data attribute
        on multiple components of the mesh. If the data is a sequence of
        strings then it must provide a value for each component in compIds.
        If it is a single string then all of the specified components will
        have their blind data set to that value.
        """
    
        pass
    
    
    def setUV(*args, **kwargs):
        """
        setUV(uvId, u, v, uvSet='') -> self
        
        Sets the specified texture coordinate.
        
        The uvId is the element in the uv list that will be set. If the uvId
        is greater than or equal to numUVs() then the uv list will be grown
        to accommodate the specified uv. If the UV being added is new, thenyou must call one of the assignUV methods in order to update the
        geometry.
        """
    
        pass
    
    
    def setUVs(*args, **kwargs):
        """
        setUVs(uValues, vValues, uvSet='') -> self
        
        Sets all of the texture coordinates (uv's) for this mesh. The uv
        value sequences must be of equal size and must be at least as large
        as the current UV set size. You can determine the UV set size by
        calling numUVs() for the default UV set, or numUVs(uvSet) for a
        named UV set.
        
        If the sequences are larger than the UV set size, then the uv list
        for this mesh will be grown to accommodate the new uv values.
        
        After using this method to set the UV values, you must call one of
        the assignUV methods to assign the corresponding UV ids to the
        geometry.
        
        In order to shrink the uvs array, do the following: clearUVs(),
        setUVs(...), assignUVs(). These steps will let you to create an
        array of uvs which is smaller than the original one.
        """
    
        pass
    
    
    def setVertexColor(*args, **kwargs):
        """
        setVertexColor(color, vertexId, modifier=None, rep=kRGBA) -> self
        
        Sets the color for a vertex in all the faces which share it.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setVertexColors(*args, **kwargs):
        """
        setVertexColors(colors, vertexIds, modifier=None, rep=kRGBA) -> self
        
        Sets the colors of the specified vertices. For each vertex in the
        vertexIds sequence, the corresponding color from the colors sequence
        will be applied to the vertex in all of the faces which share it.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setVertexNormal(*args, **kwargs):
        """
        setVertexNormal(normal, vertexId, space=MSpace.kObject, modifier=None) -> self
        
        Sets the shared normal at a vertex.
        
        If 'modifier' (MDGModifier) is provided then the operation will be
        added to the modifier and will not take effect until the modifier's
        doIt() is called. Otherwise it will take effect immediately.
        """
    
        pass
    
    
    def setVertexNormals(*args, **kwargs):
        """
        setVertexNormal(normals, vertexIds, space=MSpace.kObject) -> self
        
        Sets the shared normals for the given vertices.
        """
    
        pass
    
    
    def sortIntersectionFaceTriIds(*args, **kwargs):
        """
        sortIntersectionFaceTriIds(faceIds, triIds=none) -> self
        
        Convenience routine for sorting faceIds or face/triangle ids before
        passing them into the closestIntersection(), allIntersections(), or
        anyIntersection() methods. When using an acceleration structure with
        an intersection operation it is essential that any faceId or
        faceId/triId arrays be sorted properly to ensure optimal performance.
        
        Both arguments must be MIntArray's.
        """
    
        pass
    
    
    def split(*args, **kwargs):
        """
        split(((kOnEdge, int, float), (kInternalPoint, MFloatPoint), ...)) -> self
        
        Each tuple in the placements sequence consists of a Split Placement
        constant followed by one or two parameters.
        
        If the Split Placement is kOnEdge then the tuple will contain two
        more elements giving the int id of the edge to split, and a float
        value between 0 and 1 indicating how far along the edge to do the
        split. The same edge cannot be split more than once per call.
        
        If the Split Placement is kInternalPoint then the tuple will contain
        just one more element giving an MFloatPoint within the face.
        
        All splits must begin and end on an edge meaning that the first and
        last tuples in the placements sequence must be kOnEdge placements.
        """
    
        pass
    
    
    def subdivideEdges(*args, **kwargs):
        """
        subdivideEdges(edges, numDivisions) -> self
        
        Subdivides edges at regular intervals. For example, if numDivisions
        is 2 then two equally-spaced vertices will be added to each of the
        specified edges: one 1/3 of the way along the edge and a second 2/3
        of the way along the edge.
        """
    
        pass
    
    
    def subdivideFaces(*args, **kwargs):
        """
        subdivideFaces(faces, numDivisions) -> self
        
        Subdivides each specified face into a grid of smaller faces.
        Triangles are subdivided into a grid of smaller triangles and quads
        are subdivided into a grid of smaller quads. Faces with more than
        four edges are ignored.
        
        The numDivisions parameter tells how many times to subdivide each
        edge of the face. Internal points and edges are introduced as needed
        to create a grid of smaller faces.
        """
    
        pass
    
    
    def syncObject(*args, **kwargs):
        """
        syncObject() -> self
        
        If a non-api operation happens that many have changed the
        underlying Maya object attached to this functionset, calling this
        method will make sure that the functionset picks up those changes.
        In particular this call should be used after calling mel commands
        which might affect the mesh. Note that this only applies when the
        functionset is attached to a mesh node. If it's attached to mesh
        data the it is not necessary to call this method.
        """
    
        pass
    
    
    def unlockFaceVertexNormals(*args, **kwargs):
        """
        unlockFaceVertexNormals(seq of faceIds, seq of vertIds) -> self
        
        Unlocks the normals for the given face/vertex pairs.
        """
    
        pass
    
    
    def unlockVertexNormals(*args, **kwargs):
        """
        unlockVertexNormals(sequence of vertIds) -> self
        
        Unlocks the shared normals for the specified vertices.
        """
    
        pass
    
    
    def updateSurface(*args, **kwargs):
        """
        updateSurface() -> self
        
        Signal that this polygonal mesh has changed and needs to be redrawn.
        """
    
        pass
    
    
    def autoUniformGridParams(*args, **kwargs):
        """
        autoUniformGridParams() -> MMeshIsectAccelParams
        
        Creates an object which specifies a uniform voxel grid structure
        which can be used by the intersection routines to speed up their
        operation. The number of voxel cells to use will be determined
        automatically based on the density of triangles in the mesh. The
        grid acceleration structure will be cached with the mesh, so that
        if the same MMeshIsectAccelParams configuration is used on the next
        intersect call, the acceleration structure will not need to be rebuilt.
        """
    
        pass
    
    
    def clearGlobalIntersectionAcceleratorInfo(*args, **kwargs):
        """
        clearGlobalIntersectionAcceleratorInfo()
        
        Clears the 'total count', 'total build time', and 'peak memory'
        fields from the information string returned by
        globalIntersectionAcceleratorsInfo(). It will not cause information
        about currently existing accelerators to be lost.
        """
    
        pass
    
    
    def globalIntersectionAcceleratorsInfo(*args, **kwargs):
        """
        globalIntersectionAcceleratorsInfo() -> string
        
        Returns a string that describes the system-wide resource usage for
        cached mesh intersection accelerators. The string will be of the
        following form:
          total 10 accelerators created (2 currently active - total current memory = 10000KB), total build time = 10.2s, peak memory = 14567.1KB
        
        This means that:
        
        * a total of 10 intersection accelerators have been created as
          instructed by calls to closestIntersection(), allIntersections(),
          or anyIntersection() with non-NULL accelParams values. Thesen  structures are destroyed and re-created when intersection requests
          with differing acceleration parameters are passed in for the same
          mesh, so it is useful to see this value, which is the total count
          of how many have been created. In this case, 8 of the 10 created
          have been destroyed, either automatically or via calls to the
          freeCachedIntersectionAccelerator() method
        
        * the total memory footprint for the 2 accelerators currently in
          existence is 10,000KB
        
        * the total build time for all 10 structures that have been created
          is 10.2 seconds
        * the peak of total memory usage for all accelerators in the system
          was 14567.1KB
        Calling clearGlobalIntersectionAcceleratorInfo() will clear the
        'total count', 'total build time', and 'peak memory' fields from
        this information. It will not cause information about currently
        existing accelerators to be lost.
        """
    
        pass
    
    
    def uniformGridParams(*args, **kwargs):
        """
        uniformGridParams(xDiv, yDiv, zDiv) -> MMeshIsectAccelParams
        
        Creates an object which specifies a uniform voxel grid structure
        which can be used by the intersection routines to speed up their
        operation. This object specifies the number of voxel cells to be
        used in the x, y, and z dimensions. The grid acceleration structure
        will be cached with the mesh, so that if the same MMeshIsectAccelParams
        configuration is used on the next intersect call, the acceleration
        structure will not need to be rebuilt.
        """
    
        pass
    
    
    checkSamePointTwice = None
    
    displayColors = None
    
    numColorSets = None
    
    numEdges = None
    
    numFaceVertices = None
    
    numNormals = None
    
    numPolygons = None
    
    numUVSets = None
    
    numVertices = None
    
    __new__ = None
    
    
    kAlpha = 1
    
    
    kDifference = 2
    
    
    kInstanceUnspecified = -1
    
    
    kInternalPoint = 1
    
    
    kIntersectTolerance = 1e-06
    
    
    kIntersection = 3
    
    
    kInvalid = 2
    
    
    kOnEdge = 0
    
    
    kPointTolerance = 1e-10
    
    
    kRGB = 3
    
    
    kRGBA = 4
    
    
    kUnion = 1


class MFnNurbsSurfaceData(MFnGeometryData):
    """
    MFnNurbsSurfaceData allows the creation and manipulation of Nurbs Surface
    data objects for use in the dependency graph.
    
    __init__()
    Initializes a new, empty MFnNurbsSurfaceData object
    
    __init__(MObject)
    Initializes a new MFnNurbsSurfaceData function set, attached
    to the specified object.
    """
    
    
    
    def __init__(*args, **kwargs):
        """
        x.__init__(...) initializes x; see help(type(x)) for signature
        """
    
        pass
    
    
    def create(*args, **kwargs):
        """
        create() -> MObject
        
        Creates a new nurbs surface data object, attaches it to this function set
        and returns an MObject which references it.
        """
    
        pass
    
    
    __new__ = None



