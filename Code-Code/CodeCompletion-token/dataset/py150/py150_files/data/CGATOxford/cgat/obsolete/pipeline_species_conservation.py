################################################################################
#
#   MRC FGU Computational Genomics Group
#
#   $Id: pipeline_species_conservation.py 2900 2011-05-24 14:38:00Z david $
#
#   Copyright (C) 2011 David Sims
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
"""
==============================
Species Conservation Pipeline
==============================

:Author: David Sims 
:Release: $Id: pipeline_species_conservation.py 2900 2011-05-24 14:38:00Z david $
:Date: |today|
:Tags: Python

The species conservation pipeline imports lists of genes associated with paricular genomic features 
from multiple species along with a list of 1:1 orthologs from those species.
It then identifies sets of conserved genes that are associated with the same genomic feature.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline_species_configuration.ini` file. The pipeline looks for a configuration file in several places:

   1. The default configuration in the :term:`code directory`.
   2. A shared configuration file :file:`../pipeline.ini`.
   3. A local configuration :file:`pipeline.ini`.

The order is as above. Thus, a local configuration setting will
override a shared configuration setting and a default configuration
setting.

Configuration files follow the ini format (see the python
`ConfigParser <http://docs.python.org/library/configparser.html>` documentation).
The configuration file is organized by section and the variables are documented within 
the file. In order to get a local configuration file in the current directory, type::

    python <codedir>/pipeline_species_conservation.py config

The sphinxreport report requires a :file:`conf.py` and :file:`sphinxreport.ini` file 
(see :ref:`PipelineDocumenation`). To start with, use the files supplied with the
:ref:`Example` data.


Input
-----

Orthology Data
+++++++++++++++

A single text file containing groups of 1:1 orthologs across all species to be queried.
The format of the file is three column tab-separated:

1. Ortholog_group
2. Species
3. Gene ID

Gene Lists
+++++++++++

A set of text files containing lists of Ensembl gene or transcript ids (one per line) for each species and each condition (tissue).

Gene to Transcript Mapping
++++++++++++++++++++++++++

An annotation database generated by the pipeline_annotation.py for each species.

Requirements
------------

The pipeline requires the information from the following pipelines:

:doc:`pipeline_annotations`

set the configuration variables:
   :py:data:`annotations_database_<species>` 
   :py:data:`annotations_dir_<species>`

Pipline Output
==============

The results of the computation are all stored in an sqlite relational
database :file:`csvdb`.

"""
import sys
import tempfile
import optparse
import shutil
import itertools
import csv
import math
import random
import re
import glob
import os
import shutil
import collections
import gzip
import sqlite3
import CGAT.IOTools as IOTools
import CGAT.MAST as MAST
import CGAT.GTF as GTF
import CGAT.GFF as GFF
import CGAT.Bed as Bed
import cStringIO
import numpy
import fileinput
import CGAT.Experiment as E
import logging as L
from ruffus import *
from rpy2.robjects import r as R
USECLUSTER = True

###################################################
###################################################
###################################################
## Pipeline configuration
###################################################
import CGAT.Pipeline as P
P.getParameters(  ["%s.ini" % os.path.splitext(__file__)[0],  "../pipeline.ini", "pipeline.ini" ] )
PARAMS = P.PARAMS
#PARAMS_ANNOTATIONS = P.peekParameters( PARAMS["annotations_dir"],"pipeline_annotations.py" )

###################################################################
###################################################################
###################################################################
@files( "pipeline.ini", PARAMS["orthology_groups"] )
def getOrthologousGroups( infile, outfile ):
    '''Export list of orthologous genes from all species from postgres database'''
    statement = '''psql -h db -U andreas -d postgres -F "," -A -c "select s.set_id, m.schema, m.gene_id 
                   from cgat_proj007_v2.ortholog_sets_members m, cgat_proj007_v2.ortholog_sets s 
                   where m.set_id=s.set_id and s.nspecies=7;"
                   | sed s/,/\\\\t/g > %(outfile)s ''' % locals()
    P.run()

    
###################################################################
@transform( getOrthologousGroups, regex(PARAMS["orthology_groups"]), "sevenway_ortholog_groups.load" )
def loadOrthologousGroups( infile, outfile ):
    '''Load list of orthologous genes into sqlite3 database'''

    header="set_id,species,gene_id"
    statement = '''cat %(infile)s
                   | python %(scriptsdir)s/csv2db.py
                       --index=set_id
                       --index=species
                       --index=gene_id
                       --table=ortholog_groups 
                   > %(outfile)s '''
    P.run()

###################################################################
###################################################################    
###################################################################
@transform( "*.genelist", regex( r"(\S+).genelist"), r"\1.genelist.load" )
def loadGeneLists( infile, outfile ):
    '''Load list of genes associated with feature from each species into sqlite3 database'''

    track = P.snip( os.path.basename( infile), ".genelist" ).replace(".","_").replace("-","_")
    statement = '''cat %(infile)s
                   | python %(scriptsdir)s/csv2db.py
                       --header=gene_id
                       --index=gene_id
                       --table=%(track)s_genelist
                   > %(outfile)s '''
    P.run()

############################################################
@follows(loadOrthologousGroups)
@transform( loadGeneLists, suffix( ".genelist.load"), ".genelist.stats" )
def GeneListStats( infile, outfile ):

    track = P.snip( os.path.basename( infile), ".genelist.load" ).replace("-","_").replace(".","_")
    species = track[:2]
    #anno_base = PARAMS["annotations_dir"]
    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    #ensembl_version = PARAMS["orthology_ensembl_version"]
    species_lookup = dict(zip(species_list, anno_list))
    species_db = species_lookup[species]
    #species_db = anno_base + species_genome + "/" + PARAMS["database"]

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
    cc.execute( statement )
    cc.close()

    # Extract data from db
    cc = dbhandle.cursor()
    statement = '''SELECT count(distinct t.gene_id) as genes
                   FROM %(track)s_genelist g, %(species)s.transcript_info t
                   WHERE g.gene_id=t.transcript_id and t.gene_biotype='protein_coding' ''' % locals()
    cc.execute( statement )
    result = cc.fetchall()
    genes_with_feature = str(result[0][0])
    cc.close()
    #print track + " genes_with_feature=" + genes_with_feature + "\n"

    cc = dbhandle.cursor()
    statement = '''SELECT count(distinct gene_id) as genes
                   FROM %(species)s.transcript_info where gene_biotype='protein_coding' ''' % locals()
    cc.execute( statement )
    result = cc.fetchall()
    total_genes = str(result[0][0])
    cc.close()
    #print track + " total_protein_coding_genes =" + total_genes + "\n"

    proportion_with_feature = (float(genes_with_feature)/float(total_genes))*100
    #print track + " proportion_with_feature =" + str(proportion_with_feature) + "%\n"

    cc = dbhandle.cursor()
    statement = '''SELECT count(distinct set_id) as genes
                   FROM ortholog_groups''' % locals()
    cc.execute( statement )
    result = cc.fetchall()
    total_conserved_genes = str(result[0][0])
    cc.close()
    #print "total_conserved_genes =" + total_conserved_genes + "\n"

    proportion_conserved = (float(total_conserved_genes)/float(total_genes))*100
    #print track + " proportion_conserved =" + str(proportion_conserved) + "%\n"

    cc = dbhandle.cursor()
    statement = '''SELECT count(distinct t.gene_id) as genes
                   FROM %(track)s_genelist g, %(species)s.transcript_info t, ortholog_groups o
                   WHERE g.gene_id=t.transcript_id and t.gene_biotype='protein_coding' 
                   AND o.gene_id=t.gene_id''' % locals()
    cc.execute( statement )
    result = cc.fetchall()
    conserved_genes_with_feature = str(result[0][0])
    cc.close()
    #print track + " conserved_genes_with_feature=" + conserved_genes_with_feature + "\n"

    proportion_conserved_with_feature = (float(conserved_genes_with_feature)/float(total_conserved_genes))*100
    #print track + " proportion_conserved_with_feature =" + str(proportion_conserved_with_feature) + "%\n"

    # Write to file
    header = "genes_with_feature\ttotal_genes\ttotal_conserved_genes\tconserved_genes_with_feature\tproportion_with_feature\tproportion_conserved\tproportion_conserved_with_feature"
    outs = open( outfile, "w")
    outs.write( "%s\n" % (header) )
    outs.write( "%s\t%s\t%s\t%s\t%.2f\t%.2f\t%.2f\n" % (genes_with_feature, total_genes, total_conserved_genes, conserved_genes_with_feature, proportion_with_feature, proportion_conserved, proportion_conserved_with_feature) )
    outs.close()

############################################################
@merge( GeneListStats, "genelist_stats.load" )
def loadGeneListStats( infiles, outfile ):
    '''Merge gene list stats into single table and load into SQLite.'''

    tablename = P.toTable( outfile )
    outf = open("genelist_stats.txt","w")

    first = True
    for f in infiles:
        track = P.snip( os.path.basename(f), ".genelist.stats" )
        if not os.path.exists( f ): 
            E.warn( "File %s missing" % f )
            continue
        lines = [ x for x in open( f, "r").readlines() if not x.startswith("#") and x.strip() ]
        if first: outf.write( "%s\t%s" % ("track", lines[0] ) )
        first = False
        outf.write( "%s\t%s" % (track,lines[1] ))
    outf.close()
    tmpfilename = outf.name

    statement = '''cat %(tmpfilename)s
                   | python %(scriptsdir)s/csv2db.py
                      --index=track
                      --table=%(tablename)s 
                   > %(outfile)s '''
    P.run()

############################################################
@merge( loadGeneLists, "genelists_merged.load" )
def mergeGeneLists( infiles, outfile ):
    '''Merge gene lists into single table and load into SQLite.'''

    tablename = P.toTable( outfile )
    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    species_lookup = dict(zip(species_list, anno_list))

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_lookup.iterkeys():
        species_db = species_lookup[species]
        #species_db = anno_base + species_genome + "/" + db_name
        cc = dbhandle.cursor()
        statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
        print statement
        cc.execute( statement )
        cc.close()

    # Build union statement
    pre = "CREATE TABLE %s AS " % tablename
    statement = ""
    for f in infiles:
        track = P.snip( os.path.basename( f), ".genelist.load" ).replace("-","_").replace(".","_")
        species = track[:2]
        genelist_id=PARAMS["genelist_id"]
        statement += pre + '''SELECT distinct t.gene_id, t.gene_name, "%(species)s" AS species
                       FROM %(track)s_genelist g, %(species)s.transcript_info t
                       WHERE g.gene_id=t.%(genelist_id)s and t.gene_biotype='protein_coding' ''' % locals()
        pre = " UNION "

    print statement
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS %(tablename)s" % locals() )
    cc.execute( statement )
    cc.execute( '''CREATE INDEX "glm_idx1" ON "%s" ("gene_id" ASC) ''' % tablename )
    cc.execute( '''CREATE INDEX "glm_idx2" ON "%s" ("species" ASC) ''' % tablename )
    cc.close()

    statement = "touch %s" % outfile
    P.run()

############################################################
@follows(loadOrthologousGroups)
@transform( mergeGeneLists, suffix( "genelists_merged.load"), "genelists_merged.stats" )
def MergedGeneListStats( infile, outfile ):

    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    species_lookup = dict(zip(species_list, anno_list))
    
    # Write to file
    header = "species\tgenes_with_feature\ttotal_genes\ttotal_conserved_genes\tconserved_genes_with_feature\tproportion_with_feature\tproportion_conserved\tproportion_conserved_with_feature"
    outs = open( outfile, "w")
    outs.write( "%s\n" % (header) )

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_lookup.iterkeys():
        species_db = species_lookup[species]
        #species_db = anno_base + species_genome + "/" + db_name
        cc = dbhandle.cursor()
        statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
        print statement
        cc.execute( statement )
        cc.close()

        # Extract data from db
        cc = dbhandle.cursor()
        statement = '''SELECT count(distinct t.gene_id) as genes
                       FROM genelists_merged g, %(species)s.transcript_info t
                       WHERE g.gene_id=t.gene_id 
                       AND t.gene_biotype='protein_coding' ''' % locals()
        cc.execute( statement )
        result = cc.fetchall()
        genes_with_feature = str(result[0][0])
        cc.close()
        #print track + " genes_with_feature=" + genes_with_feature + "\n"

        cc = dbhandle.cursor()
        statement = '''SELECT count(distinct gene_id) as genes
                       FROM %(species)s.transcript_info where gene_biotype='protein_coding' ''' % locals()
        cc.execute( statement )
        result = cc.fetchall()
        total_genes = str(result[0][0])
        cc.close()
        #print track + " total_protein_coding_genes =" + total_genes + "\n"

        proportion_with_feature = (float(genes_with_feature)/float(total_genes))*100
        #print track + " proportion_with_feature =" + str(proportion_with_feature) + "%\n"

        cc = dbhandle.cursor()
        statement = '''SELECT count(distinct set_id) as genes
                       FROM ortholog_groups''' % locals()
        cc.execute( statement )
        result = cc.fetchall()
        total_conserved_genes = str(result[0][0])
        cc.close()
        #print "total_conserved_genes =" + total_conserved_genes + "\n"

        proportion_conserved = (float(total_conserved_genes)/float(total_genes))*100
        #print track + " proportion_conserved =" + str(proportion_conserved) + "%\n"

        cc = dbhandle.cursor()
        statement = '''SELECT count(distinct t.gene_id) as genes
                       FROM genelists_merged g, %(species)s.transcript_info t, ortholog_groups o
                       WHERE g.gene_id=t.gene_id and t.gene_biotype='protein_coding' 
                       AND o.gene_id=t.gene_id''' % locals()
        cc.execute( statement )
        result = cc.fetchall()
        conserved_genes_with_feature = str(result[0][0])
        cc.close()
        #print track + " conserved_genes_with_feature=" + conserved_genes_with_feature + "\n"

        proportion_conserved_with_feature = (float(conserved_genes_with_feature)/float(total_conserved_genes))*100
        #print track + " proportion_conserved_with_feature =" + str(proportion_conserved_with_feature) + "%\n"
        
        outs.write( "%s\t%s\t%s\t%s\t%s\t%.2f\t%.2f\t%.2f\n" % (species, genes_with_feature, total_genes, total_conserved_genes, conserved_genes_with_feature, proportion_with_feature, proportion_conserved, proportion_conserved_with_feature) )
        
    outs.close()

############################################################
@transform( MergedGeneListStats, suffix("genelists_merged.stats"), "genelists_merged.stats.load" )
def loadMergedGeneListStats( infile, outfile ):
    '''Load into SQLite.'''
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                       --index=species
                       --table=genelist_merged_stats 
                   > %(outfile)s '''
    P.run()

############################################################
@follows( mkdir("stats") )
@transform(MergedGeneListStats, suffix("genelists_merged.stats"), "nmi_conservation")
def nmiConservationFisherTest( infile, outfile ):
    '''Plot heatmap of pairwise scores in R'''
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R")'''  % locals() )
    #print '''nmi_conservation(infile="%(infile)s", outfile="%(outfile)s") '''  % locals()
    R('''nmi_conservation(infile="%(infile)s", outfile="%(outfile)s") '''  % locals() )       

############################################################
############################################################
############################################################
@transform(mergeGeneLists, regex(r"(\S+).load"), "ortholog_groups_with_feature.load") 
def orthologGroupsWithFeature( infile, outfile):
    '''Generate list of conserved genes associated with feature in all species '''

    tablename = "ortholog_groups_with_feature"
    #nno_base = PARAMS["annotations_dir"]
    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    #db_name = PARAMS["database"]
    #ensembl_version = PARAMS["orthology_ensembl_version"]
    species_lookup = dict(zip(species_list, anno_list))

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_lookup.iterkeys():
        species_db = species_lookup[species]
        #species_db = anno_base + species_genome + "/" + db_name
        cc = dbhandle.cursor()
        statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
        cc.execute( statement )
        cc.close()

    # Extract data from db
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS %(tablename)s" % locals() )
    statement = '''CREATE TABLE %(tablename)s AS 
                   SELECT count(distinct o.schema) as species_count, 
                   group_concat(o.gene_id,",") as gene_ids,
                   group_concat(g.gene_name,",") as gene_names,
                   group_concat(o.schema,",") as species_list, set_id
                   FROM genelists_merged g, ortholog_groups o
                   WHERE  g.gene_id=o.gene_id
                   GROUP BY set_id ''' % locals()
    cc.execute( statement )
    # add index
    #cc.execute( )
    cc.close()

    statement = "touch %s" % outfile
    P.run()
    
###################################################################
###################################################################
###################################################################
## Ortholog pairs
@files( "pipeline.ini", PARAMS["orthology_pairwise"] )
def getPairwiseOrthologs( infile, outfile ):
    '''Export list of pairwise orthologous genes from all species comparisons from postgres database'''
    statement = '''psql -h db -U andreas -d postgres -F "," -A -c "select s.set_id, m.schema, m.gene_id, s.pattern 
                   from cgat_proj007_v2.ortholog_sets_members m, cgat_proj007_v2.ortholog_sets s 
                   where m.set_id=s.set_id and s.nspecies=2"
                   | sed s/,/\\\\t/g
                   > %(outfile)s '''
    P.run()
    
###################################################################
@follows( getPairwiseOrthologs )
@files( PARAMS["orthology_pairwise"], "pairwise_ortholog_groups.load" )
def loadPairwiseOrthologs( infile, outfile ):
    '''Load list of orthologous genes into sqlite3 database'''
    header="set_id,species,gene_id,pattern"
    statement = '''cat %(infile)s
                   | python %(scriptsdir)s/csv2db.py
                       --index=set_id
                       --index=species
                       --index=gene_id
                       --index=pattern
                       --table=pairwise_ortholog_groups 
                   > %(outfile)s '''
    P.run()

###################################################################
@transform( loadPairwiseOrthologs, regex(r"pairwise_ortholog_groups.load"), "pattern_lookup.load" )
def loadPatternLookup( infile, outfile ):
    '''Load lookup of pattern to species pair'''
    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''create table pattern_lookup as 
                   select a.pattern as pattern, group_concat(a.species,"-") as species_pair from 
                   (select c.pattern, c.species from 
                   (SELECT distinct pattern, substr(schema,6,2) as species FROM pairwise_ortholog_groups) c
                   order by c.pattern asc,  c.species desc ) a
                   group by a.pattern'''
    cc.execute( "DROP TABLE IF EXISTS pattern_lookup" % locals() )
    cc.execute( statement )
    cc.execute( '''CREATE UNIQUE INDEX "pl_idx1" ON "pattern_lookup" ("pattern" ASC)''' )
    cc.execute( '''CREATE UNIQUE INDEX "pl_idx2" ON "pattern_lookup" ("species_pair" ASC)''' )
    cc.close()

    statement = "touch %s" % outfile
    P.run()
    
###################################################################
@follows( loadPatternLookup )
@transform(mergeGeneLists, regex(r"(\S+).load"), "ortholog_pairs_with_feature.load") 
def orthologPairsWithFeature( infile, outfile):
    '''Generate list of conserved genes associated with feature in all species '''
    tablename = "ortholog_pairs_with_feature"
    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    species_lookup = dict(zip(species_list, anno_list))

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_lookup.iterkeys():
        species_db = species_lookup[species]
        cc = dbhandle.cursor()
        statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
        cc.execute( statement )
        cc.close()

    # Extract data from db
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS %(tablename)s" % locals() )
    statement = '''CREATE TABLE %(tablename)s AS 
                   SELECT count(distinct o.schema) as species_count, 
                   group_concat(o.gene_id,",") as gene_ids,
                   group_concat(g.gene_name,",") as gene_names,
                   set_id, p.pattern as pattern, p.species_pair as species_pair
                   FROM genelists_merged g, pairwise_ortholog_groups o, pattern_lookup p
                   WHERE  g.gene_id=o.gene_id
                   AND p.pattern=o.pattern
                   GROUP BY set_id ''' % locals()
    cc.execute( statement )
    cc.close()
    statement = "touch %s" % outfile
    P.run()
    
############################################################
@transform( orthologPairsWithFeature, suffix( ".load"), ".stats" )
def pairsStats( infile, outfile ):
    '''Calculate conservation stats for each species pair '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS pairwise_ortholog_stats" )
    statement = '''CREATE table pairwise_ortholog_stats AS
                   SELECT a.species1 as species1, a.species2 as species2, a.species_pair as species_pair, conserved_genes,
                   conserved_nmis, conserved_genes_with_nmi_species1, conserved_genes_with_nmi_species2, 
                   (2.0*a.conserved_nmis)/(b.conserved_genes_with_nmi_species1+b.conserved_genes_with_nmi_species2) as score,
                   (1.0*a.conserved_nmis)/min(b.conserved_genes_with_nmi_species1,b.conserved_genes_with_nmi_species2) as score2
                   FROM
                   (SELECT substr(species_pair,1,2) as species1, substr(species_pair,4,2) as species2, 
                   species_pair, count(gene_ids) as conserved_nmis, pattern
                   FROM ortholog_pairs_with_feature 
                   WHERE species_count=2 group by species_pair) a,
                   (SELECT conserved_genes_with_nmi_species1, conserved_genes_with_nmi_species2, sp1.pattern as pattern FROM
                   (SELECT count(o.gene_id) as conserved_genes_with_nmi_species1, substr(schema,6,2) as species, p.pattern
                   FROM genelists_merged g, pairwise_ortholog_groups o, pattern_lookup p
                   WHERE g.gene_id=o.gene_id AND p.pattern=o.pattern
                   AND substr(species_pair,1,2)=substr(schema,6,2)
                   GROUP BY species, p.pattern) sp1,
                   (SELECT count(o.gene_id) as conserved_genes_with_nmi_species2, substr(schema,6,2) as species, p.pattern
                   FROM genelists_merged g, pairwise_ortholog_groups o, pattern_lookup p
                   WHERE g.gene_id=o.gene_id AND p.pattern=o.pattern
                   AND substr(species_pair,4,2)=substr(schema,6,2)
                   GROUP BY species, p.pattern) sp2
                   where sp1.pattern=sp2.pattern) b,
                   (SELECT count(distinct set_id) as conserved_genes, pattern FROM pairwise_ortholog_groups
                   GROUP BY pattern) c
                   WHERE a.pattern=b.pattern
                   AND b.pattern=c.pattern
                   order by score desc''' % locals()
    cc.execute( statement )
    cc.close()
    statement = "touch %s" % outfile
    P.run()

############################################################
@transform( pairsStats, suffix( ".stats"), ".hypergeom" )
def testGeneListOverlapSignificance( infile, outfile ):
    '''Use hypergeometric test to establish significance of conservation of NMIs'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT species_pair, conserved_genes,
                   conserved_nmis, conserved_genes_with_nmi_species1, conserved_genes_with_nmi_species2
                   FROM pairwise_ortholog_stats''' % locals()
    cc.execute( statement )
    
    # Calculate probability of overlap and write to file
    statement = '''printf "species_pair\\tconserved_genes\\tconserved_nmis\\tconserved_genes_with_nmi_species1\\tconserved_genes_with_nmi_species2\\tp-value\\n" > %(outfile)s;''' 
    P.run()
    for result in cc:
        species_pair, conserved_genes, conserved_nmis, conserved_genes_with_nmi_species1, conserved_genes_with_nmi_species2 = result
        statement = '''printf "%(species_pair)s\\t%(conserved_genes)s\\t%(conserved_nmis)s\\t%(conserved_genes_with_nmi_species1)s\\t%(conserved_genes_with_nmi_species2)s\\t" >> %(outfile)s; 
                       python %(scriptsdir)s/list_overlap.py %(conserved_nmis)i %(conserved_genes)i %(conserved_genes_with_nmi_species1)i %(conserved_genes_with_nmi_species2)i >> %(outfile)s;''' 
        P.run()
    #statement = '''sed -i '{N;s/\\n/\\t/g}' %(outfile)s; '''
    #P.run()
    cc.close()

############################################################
@transform(testGeneListOverlapSignificance, suffix(".hypergeom"), ".hypergeom.load" )
def loadGeneListOverlapSignificance( infile, outfile ):
    ''' load p-value to database'''
    statement = '''cat %(infile)s
                   | python %(scriptsdir)s/csv2db.py
                       --index=species_pair
                       --table=pairwise_ortholog_overlaps_pval 
                   > %(outfile)s '''
    P.run()
    
############################################################
@transform( pairsStats, suffix( ".stats"), ".matrix" )
def exportPairsScoreMatrix( infile, outfile ):
    species_list = P.asList(PARAMS["species"])
    outs = open( outfile, "w")
    first=True
    for species in species_list:
        dbhandle = sqlite3.connect( PARAMS["database"] )
        cc = dbhandle.cursor()
        statement = ''' SELECT species, score from (
                        SELECT species2 as species, score from pairwise_ortholog_stats where species1="%(species)s"
                        UNION SELECT species1 as species, score from pairwise_ortholog_stats where species2="%(species)s"
                        UNION SELECT "%(species)s" as species,  1.0 as score)
                        ORDER BY species desc''' % locals()
        # If first write headers
        if first: 
            cc.execute( statement )
            outs.write("species")
            for result in cc:
                outs.write("\t%s" % result[0] )
            outs.write("\n")
            first = False
        cc.execute( statement )
        outs.write(species)
        for result in cc:
            outs.write("\t%s" % result[1] )
        outs.write("\n")
        cc.close()
    outs.close()

############################################################
@transform( pairsStats, suffix( ".stats"), ".matrix2" )
def exportPairsScoreMatrix2( infile, outfile ):
    species_list = P.asList(PARAMS["species"])
    outs = open( outfile, "w")
    first=True
    for species in species_list:
        dbhandle = sqlite3.connect( PARAMS["database"] )
        cc = dbhandle.cursor()
        statement = ''' SELECT species, score from (
                        SELECT species2 as species, score2 as score from pairwise_ortholog_stats where species1="%(species)s"
                        UNION SELECT species1 as species, score2 as score from pairwise_ortholog_stats where species2="%(species)s"
                        UNION SELECT "%(species)s" as species,  1.0 as score)
                        ORDER BY species desc''' % locals()
        # If first write headers
        if first: 
            cc.execute( statement )
            outs.write("species")
            for result in cc:
                outs.write("\t%s" % result[0] )
            outs.write("\n")
            first = False
        cc.execute( statement )
        outs.write(species)
        for result in cc:
            outs.write("\t%s" % result[1] )
        outs.write("\n")
        cc.close()
    outs.close()

############################################################
@follows( mkdir("plots") )
@transform(exportPairsScoreMatrix, regex(r"(\S+).matrix"), r"plots/\1.pdf")
def plotPairwiseScoreHeatmap( infile, outfile ):
    '''Plot heatmap of pairwise scores in R'''
    R('''library(RColorBrewer)''')
    R('''library(gplots)''')
    R('''x=read.table("%(infile)s", header=TRUE)''' % locals() )
    R('''mat <- as.matrix(x[,2:dim(x)[2]])''')
    R('''rownames(mat) <- x[,1]''')
    R('''pdf("%(outfile)s", height=10, width=10)''' % locals() )
    R('''heatmap.2(mat, Rowv=TRUE, Colv=TRUE, dendrogram=c("none"), distfun=dist, hclustfun=hclust, xlab="", ylab="", key=TRUE, keysize=2, trace="none", density.info=c("none"), margins=c(10, 8), breaks=seq(0.55,1,0.05), col=brewer.pal(9,"Blues") )''')
    R('''dev.off()''')

############################################################
@follows( mkdir("plots") )
@transform(exportPairsScoreMatrix2, regex(r"(\S+).matrix2"), r"plots/\1.score2.pdf")
def plotPairwiseScoreHeatmap2( infile, outfile ):
    '''Plot heatmap of pairwise scores in R'''
    R('''library(RColorBrewer)''')
    R('''library(gplots)''')
    R('''x=read.table("%(infile)s", header=TRUE)''' % locals() )
    R('''mat <- as.matrix(x[,2:dim(x)[2]])''')
    R('''rownames(mat) <- x[,1]''')
    R('''pdf("%(outfile)s", height=10, width=10)''' % locals() )
    R('''heatmap.2(mat, Rowv=TRUE, Colv=TRUE, dendrogram=c("none"), distfun=dist, hclustfun=hclust, xlab="", ylab="", key=TRUE, keysize=2, trace="none", density.info=c("none"), margins=c(10, 8), breaks=seq(0.64,1,0.02), col=rev(heat.colors(18)),colsep=seq(1,7,1),rowsep=seq(1,7,1),sepcolor="black", sepwidth=c(0.01,0.01) )''')
    R('''dev.off()''')
        
###################################################################
###################################################################
###################################################################
## Human, mouse zebrafish threeway orthologs
@files( "pipeline.ini", PARAMS["orthology_triple"] )
def getTripleOrthologs( infile, outfile ):
    '''Export list of orthologous genes from human, mouse and zebrafish from postgres database'''
    statement = '''psql -h db -U andreas -d postgres -F "," -A -c "select s.set_id, m.schema, m.gene_id 
                   from cgat_proj007_v2.ortholog_sets_members m, cgat_proj007_v2.ortholog_sets s 
                   where m.set_id=s.set_id and s.pattern='1100001'"
                   | sed s/,/\\\\t/g
                   > %(outfile)s '''
    P.run()
    
###################################################################
@follows( getTripleOrthologs )
@files( PARAMS["orthology_triple"], "triple_ortholog_groups.load" )
def loadTripleOrthologs( infile, outfile ):
    '''Load list of orthologous genes into sqlite3 database'''
    statement = '''cat %(infile)s
                   | python %(scriptsdir)s/csv2db.py
                       --index=set_id
                       --index=species
                       --index=gene_id
                       --table=triple_ortholog_groups 
                   > %(outfile)s '''
    P.run()

###################################################################
@follows( loadTripleOrthologs )
@transform(mergeGeneLists, regex(r"(\S+).load"), "ortholog_triple_with_feature.load") 
def orthologTripleWithFeature( infile, outfile):
    '''Generate list of conserved genes associated with feature in all species '''
    tablename = "ortholog_triple_with_feature"
    #anno_base = PARAMS["annotations_dir"]
    species_list = P.asList(PARAMS["species"])
    anno_list = P.asList(PARAMS["annotations_db"])
    #db_name = PARAMS["database"]
    species_lookup = dict(zip(species_list, anno_list))

    # Connect to database and attach annotation databases
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_lookup.iterkeys():
        species_db = species_lookup[species]
        #species_db = anno_base + species_genome + "/" + db_name
        cc = dbhandle.cursor()
        statement = '''ATTACH DATABASE '%(species_db)s' as %(species)s''' % locals()
        cc.execute( statement )
        cc.close()

    # Extract data from db
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS %(tablename)s" % locals() )
    statement = '''CREATE TABLE %(tablename)s AS 
                   SELECT count(distinct o.schema) as species_count, 
                   group_concat(o.gene_id,",") as gene_ids,
                   group_concat(g.gene_name,",") as gene_names,
                   group_concat(o.schema,",") as species_list, set_id
                   FROM genelists_merged g, triple_ortholog_groups o
                   WHERE g.gene_id=o.gene_id
                   GROUP BY set_id ''' % locals()
    cc.execute( statement )
    cc.close()
    statement = "touch %s" % outfile
    P.run()

############################################################
@transform( orthologTripleWithFeature, suffix( ".load"), ".stats" )
def tripleStats( infile, outfile ):

    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    cc.execute( "DROP TABLE IF EXISTS triple_ortholog_stats" )
    # conserved in all three species
    statement = '''CREATE table triple_ortholog_stats AS
                   SELECT replace(replace(species_list,"cgat_",""),"62","") as species_list, count(gene_ids) as conserved_nmis 
                   FROM ortholog_triple_with_feature 
                   WHERE species_count=3 
                   UNION
                   SELECT replace(replace(species_list,"cgat_",""),"62","") as species_list, count(gene_ids) as conserved_nmis 
                   FROM ortholog_triple_with_feature 
                   WHERE species_count=2 group by species_list
                   UNION
                   SELECT replace(replace(species_list,"cgat_",""),"62","") as species_list, count(gene_ids) as conserved_nmis 
                   FROM ortholog_triple_with_feature 
                   WHERE species_count=1 group by species_list'''
    cc.execute( statement )
    cc.close()
    statement = "touch %s" % outfile
    P.run()

############################################################
@follows( mkdir("plots") )
@transform(tripleStats, regex(r"(\S+).stats"), r"plots/\1.pdf")
def plotThreeWayVenn( infile, outfile):
    '''Figure 3b: TSS profiles for CAPseq and non CAPseq genes'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT distinct set_id FROM ortholog_triple_with_feature WHERE species_list like "%%dr%%"'''
    cc.execute( statement )
    dr = ""
    pre = ""
    for result in cc:
        dr = dr+pre+str(result[0])
        pre=","
    statement = '''SELECT distinct set_id FROM ortholog_triple_with_feature WHERE species_list like "%%mm%%"'''
    cc.execute( statement )
    mm = ""
    pre = ""
    for result in cc:
        mm = mm+pre+str(result[0])
        pre=","
    statement = '''SELECT distinct set_id FROM ortholog_triple_with_feature WHERE species_list like "%%hs%%"'''
    cc.execute( statement )
    hs = ""
    pre = ""
    for result in cc:
        hs = hs+pre+str(result[0])
        pre=","
    cc.close()
    euler = outfile.replace(".pdf",".euler.pdf")
    R('''library(VennDiagram) ''')
    R('''dr <- c(%(dr)s)''' % locals() )
    R('''mm <- c(%(mm)s)''' % locals() )
    R('''hs <- c(%(hs)s)''' % locals() )
    R('''x <- list(Zebrafish=dr,Mouse=mm,Human=hs)''' )
    # Non-scaled threeway venn
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", alpha=0.75, cex=2.0, fontfamily="Helvetica", fontface="bold")''' )
    R('''grid.draw(venn)''')
    R('''dev.off()''')
            
############################################################
############################################################    
############################################################
## Export data
@transform(orthologGroupsWithFeature, suffix(".load"), ".export") 
def exportConservedGeneListPerSpecies( infile, outfile):
    '''Export list of conserved genes associated with feature for each species '''
    
    species_list = P.asList(PARAMS["species"])
    ensembl_version = PARAMS["orthology_ensembl_version"]
    
    # Get gene list from database
    dbhandle = sqlite3.connect( PARAMS["database"] )
    for species in species_list:
        cc = dbhandle.cursor()
        statement = '''SELECT distinct g.gene_id
                       FROM ortholog_groups g, ortholog_groups_with_feature f
                       WHERE f.set_id=g.set_id
                       AND f.species_count=6
                       AND g.schema LIKE "cgat_%(species)s%%"''' % locals()
        cc.execute( statement )
        
        # Write to file
        outfilename = species + ".conserved.export"
        outs = open( outfilename, "w")
        for result in cc:
            pre = ""
            for r in result:
              outs.write("%s%s" % (pre, str(r)) )
              pre = "\t"
            outs.write("\n")
        cc.close()
        outs.close()
        
    statement = "touch %s" % outfile
    P.run()

############################################################
@follows( exportConservedGeneListPerSpecies)
@transform( "*.conserved.export", regex(r"(\S+).conserved.export"), r"\1.conserved.bed" )
def exportConservedGeneBed( infile, outfile ):
    '''export bed file for each list of conserved CAPseq genes'''
    species_list = P.asList(PARAMS["species"])
    gtf_list = P.asList(PARAMS["annotations_gtf"])
    species_lookup = dict(zip(species_list, gtf_list))
    species = infile[0:2]
    species_gtf = species_lookup[species]
    track = P.snip( os.path.basename(infile),".export")
    
    #gtffile = os.path.join( PARAMS["annotations_dir"], species_genome, PARAMS["annotations_gtf"] )
    statement = '''zcat %(species_gtf)s | python %(scriptsdir)s/gtf2gtf.py --filter=gene --apply=%(infile)s --log=%(outfile)s.log
                   | python %(scriptsdir)s/gtf2gtf.py --merge-transcripts --with-utr --log=%(outfile)s.log
                   | python %(scriptsdir)s/gff2bed.py --is-gtf --name=gene_id --track=feature --log=%(outfile)s.log
                   | grep -v track > %(outfile)s;''' 
    P.run()

########################################################################################################################
########################################################################################################################
########################################################################################################################
## Plot GC content etc across species
@follows( mkdir("plots") )
@merge("/ifs/projects/proj007/web/capseq7/cpg/*testes-cap.replicated.cpg.export", ("plots/testes_capseq_cpg_obsexp.pdf","plots/testes_control_cpg_obsexp.pdf") )
def plotFigure1cCpGObsExp( infiles, outfiles):
    '''Figure 1c: density plots of CpG Observed / expected'''
    capseq_out, control_out = outfiles
    indir = os.path.dirname(infiles[0])
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals())
    R('''speciesPlot(dir="%(indir)s", pattern="*testes-cap.replicated.cpg.export", main="Testes CAPseq", xlab="CpG Observed/Expected", filename="%(capseq_out)s", plotcol=2, xlimit=c(0,2), ylimit=c(0,5))''' % locals() )
    R('''speciesPlot(dir="%(indir)s", pattern="*testes-cap.replicated.cpg.export", main="Testes Control", xlab="CpG Observed/Expected", filename="%(control_out)s", plotcol=3, xlimit=c(0,2), ylimit=c(0,5))''' % locals() )
   
############################################################
@follows( mkdir("plots") )
@merge("/ifs/projects/proj007/web/capseq7/gc/*testes-cap.replicated.gc.export", ("plots/testes_capseq_gc_content.pdf","plots/testes_control_gc_content.pdf") )
def plotFigure1cGCContent( infiles, outfiles):
    '''Figure 1c: density plots of GC content'''
    capseq_out, control_out = outfiles
    indir = os.path.dirname(infiles[0])
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals())
    R('''speciesPlot(dir="%(indir)s", pattern="*testes-cap.replicated.gc.export", main="Testes CAPseq", xlab="GC Content", filename="%(capseq_out)s", plotcol=2, xlimit=c(0,1), ylimit=c(0,15))''' % locals() )
    R('''speciesPlot(dir="%(indir)s", pattern="*testes-cap.replicated.gc.export", main="Testes Control", xlab="GC Content", filename="%(control_out)s", plotcol=3, xlimit=c(0,1), ylimit=c(0,15))''' % locals() )
  
  
############################################################
############################################################
############################################################
## Pipeline organisation
@follows( loadGeneLists, mergeGeneLists,
          GeneListStats, loadGeneListStats,
          MergedGeneListStats, loadMergedGeneListStats )
def loadNMIgenes():
    '''Load NMI data into database'''
    pass
    
@follows( getOrthologousGroups, loadOrthologousGroups,
          orthologGroupsWithFeature)
def allSpecies():
    '''Load all data into database'''
    pass

@follows( getPairwiseOrthologs, loadPairwiseOrthologs, loadPatternLookup,
          orthologPairsWithFeature, pairsStats, 
          testGeneListOverlapSignificance, loadGeneListOverlapSignificance,
          exportPairsScoreMatrix, plotPairwiseScoreHeatmap)
def orthologPairs():
    '''Find ortholog pairs with conserved features '''
    pass
    
@follows( getTripleOrthologs, loadTripleOrthologs,
          orthologTripleWithFeature, tripleStats,
          plotThreeWayVenn)
def orthologTriple():
    '''Load all data into database'''
    pass    
    
@follows( exportConservedGeneListPerSpecies, exportConservedGeneBed)
def export():
    '''Find orthologues genes with conserved features '''
    pass
    
@follows( plotFigure1cGCContent, plotFigure1cCpGObsExp)
def figures():
    '''Plot featue composition across species'''
    pass

@follows( loadNMIgenes, allSpecies, 
          orthologPairs, orthologTriple, 
          export)
def full():
    '''Run complete pipeline '''
    pass

############################################################
############################################################
############################################################
## REPORTS
@follows( mkdir( "report" ) )
def build_report():
    '''build report from scratch.'''
    E.info( "starting documentation build process from scratch" )
    P.run_report( clean = True )

############################################################
@follows( mkdir( "report" ) )
def update_report():
    '''update report.'''
    E.info( "updating documentation" )
    P.run_report( clean = False )

############################################################
@files( "report.log", "publish.log")
def publish_report(infile, outfile):
    '''Copy report to web '''
    publish_dir = PARAMS["publish_dir"]
    fig_dir = PARAMS["publish_figures"]
    working_dir = os.getcwd()
    statement = '''cp -rf report/html/* %(publish_dir)s 2>> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/plots/ortholog_pairs_with_feature*.pdf %(fig_dir)s/Fig2 2>> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/plots/ortholog_triple_with_feature.pdf %(fig_dir)s/Fig2 2>> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/plots/*_gc_content.pdf %(fig_dir)s/Fig1 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*_cpg_obsexp.pdf %(fig_dir)s/Fig1 2>> %(outfile)s; '''
    P.run()
    
if __name__== "__main__":
    sys.exit( P.main(sys.argv) )

