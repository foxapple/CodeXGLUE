################################################################################
#
#   MRC FGU Computational Genomics Group
#
#   $Id: pipeline_proj007.py 2900 2011-05-24 14:38:00Z david $
#
#   Copyright (C) 2012 David Sims
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
"""
===================
Project007 pipeline
===================

:Author: David Sims 
:Release: $Id: pipeline_proj007.py 2900 2011-05-24 14:38:00Z david $
:Date: |today|
:Tags: Python

The project007 pipeline annotates intervals generated by the CAPseq pipeline

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline_capseq.ini` file. The pipeline looks for a configuration file in several places:

   1. The default configuration in the :term:`code directory`.
   2. A shared configuration file :file:`../pipeline.ini`.
   3. A local configuration :file:`pipeline.ini`.

The order is as above. Thus, a local configuration setting will
override a shared configuration setting and a default configuration
setting.

Configuration files follow the ini format (see the python
`ConfigParser <http://docs.python.org/library/configparser.html>` documentation).
The configuration file is organized by section and the variables are documented within 
the file. In order to get a local configuration file in the current directory, type::

    python <codedir>/pipeline_cpg.py config

The sphinxreport report requires a :file:`conf.py` and :file:`sphinxreport.ini` file 
(see :ref:`PipelineDocumenation`). To start with, use the files supplied with the
:ref:`Example` data.


Input
-----

Reads
++++++

Input are :file:`.fastq.gz`-formatted files. The files should be
labeled in the following way::

   sample-condition-replicate.fastq.gz

Note that neither ``sample``, ``condition`` or ``replicate`` should contain 
``_`` (underscore) and ``.`` (dot) characters as these are used by the pipeline
to delineate tasks.

Requirements
------------

The pipeline requires the information from the following pipelines:

:doc:`pipeline_annotations`

set the configuration variables:
   :py:data:`annotations_database` 
   :py:data:`annotations_dir`

On top of the default CGAT setup, the pipeline requires the following software to be in the 
path:

+--------------------+-------------------+------------------------------------------------+
|*Program*           |*Version*          |*Purpose*                                       |
+--------------------+-------------------+------------------------------------------------+
|BEDTools            |                   |interval comparison                             |
+--------------------+-------------------+------------------------------------------------+


Pipline Output
==============

The results of the computation are all stored in an sqlite relational
database :file:`csvdb`.


Code
====

"""
import sys
import tempfile
import optparse
import shutil
import itertools
import csv
import math
import random
import re
import glob
import os
import shutil
import collections
import gzip
import sqlite3
import pysam
import CGAT.IndexedFasta as IndexedFasta
import CGAT.IndexedGenome as IndexedGenome
import CGAT.FastaIterator as FastaIterator
import CGAT.Genomics as Genomics
import CGAT.IOTools as IOTools
import CGAT.MAST as MAST
import CGAT.GTF as GTF
import CGAT.GFF as GFF
import CGAT.Bed as Bed
import cStringIO
import numpy
import CGAT.Masker as Masker
import fileinput
#import CGAT.gff2annotator
import CGAT.Experiment as E
#import CGAT.logging as L
import CGATPipelines.PipelinePeakcalling as PIntervals
import CGATPipelines.PipelineTracks as PipelineTracks
import CGATPipelines.PipelineMapping as PipelineMapping
import CGATPipelines.PipelineGO as PipelineGO
from ruffus import *
from rpy2.robjects import r as R
import rpy2.robjects as ro

USECLUSTER = True

###################################################
###################################################
###################################################
## Pipeline configuration
###################################################
import CGAT.Pipeline as P
P.getParameters(  ["pipeline_proj007.ini", ] )
PARAMS = P.PARAMS
PARAMS_ANNOTATIONS = [0,] #P.peekParameters( PARAMS["geneset_dir"],"pipeline_annotations.py" )

###################################################################
###################################################################
###################################################################
## Helper functions mapping tracks to conditions, etc
###################################################################
# load all tracks - exclude input/control tracks
Sample = PipelineTracks.Sample3

TRACKS = PipelineTracks.Tracks( Sample ).loadFromDirectory( 
    [ x.replace("../","") for x in glob.glob( "../*.export.txt.gz" ) if PARAMS["tracks_control"] not in x ],
      "(\S+).export.txt.gz" ) +\
      PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
          [ x.replace("../","") for x in glob.glob( "../*.sra" ) if PARAMS["tracks_control"] not in x ], 
          "(\S+).sra" ) +\
          PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
              [x.replace("../","") for x in glob.glob( "../*.fastq.gz" ) if PARAMS["tracks_control"] not in x], 
              "(\S+).fastq.gz" ) +\
              PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
                  [x.replace("../","") for x in glob.glob( "../*.fastq.1.gz" ) if PARAMS["tracks_control"] not in x], 
                  "(\S+).fastq.1.gz" ) +\
                  PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
                      [ x.replace("../","") for x in glob.glob( "../*.csfasta.gz" ) if PARAMS["track_control"] not in x], 
                        "(\S+).csfasta.gz" )
for X in TRACKS:
    print "TRACK=", X, "\n"

TRACKS_CONTROL = PipelineTracks.Tracks( Sample ).loadFromDirectory( 
    [ x.replace("../","") for x in glob.glob( "../*.export.txt.gz" ) if PARAMS["tracks_control"] in x ],
      "(\S+).export.txt.gz" ) +\
      PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
          [ x.replace("../","") for x in glob.glob( "../*.sra" ) if PARAMS["tracks_control"] in x ], 
          "(\S+).sra" ) +\
          PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
              [x.replace("../","") for x in glob.glob( "../*.fastq.gz" ) if PARAMS["tracks_control"] in x], 
              "(\S+).fastq.gz" ) +\
              PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
                  [x.replace("../","") for x in glob.glob( "../*.fastq.1.gz" ) if PARAMS["tracks_control"] in x], 
                  "(\S+).fastq.1.gz" ) +\
                  PipelineTracks.Tracks( PipelineTracks.Sample3 ).loadFromDirectory( 
                      [ x.replace("../","") for x in glob.glob( "../*.csfasta.gz" ) if PARAMS["track_control"] in x], 
                        "(\S+).csfasta.gz" )
for X in TRACKS_CONTROL:
    print "TRACK_CONTROL=", X, "\n"

def getControl( track ):
    '''return appropriate control for a track'''
    n = track.clone()
    n.condition = PARAMS["tracks_control"]
    return n

###################################################################
###################################################################
###################################################################
# aggregate per experiment
EXPERIMENTS = PipelineTracks.Aggregate( TRACKS, labels = ("condition", "tissue") )
# aggregate per condition
CONDITIONS = PipelineTracks.Aggregate( TRACKS, labels = ("condition",) )
# aggregate per tissue
TISSUES = PipelineTracks.Aggregate( TRACKS, labels = ("tissue",) )
# compound targets : all experiments
TRACKS_MASTER = EXPERIMENTS.keys() + CONDITIONS.keys()
# compound targets : correlation between tracks
TRACKS_CORRELATION = TRACKS_MASTER + list(TRACKS)

print "Expts=", EXPERIMENTS, "\n"

########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section1: Annotate CAPseq intervals using gene/transcript set
########################################################################################################################
########################################################################################################################
########################################################################################################################

############################################################    
############################################################
## Section 1a: measure overlap with gene/transcript TSS, protein-coding genes, non-coding genes, flanks and intergenic regions
@transform( "../replicated_intervals/*.replicated.bed", regex(r"../replicated_intervals/(\S+).replicated.bed"), r"\1.replicated.bed" )
def copyCapseqReplicatedBedFiles( infile, outfile ):
    '''Copy replicated Bed files generated by capseq pipline to geneset-specific output directory'''
    statement = '''cp %(infile)s .'''
    P.run()

############################################################    
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".geneset_overlap" )
def annotateCapseqGenesetOverlap( infile, outfile ):
    '''classify intervals according to their base pair overlap with respect to different genomic features (genes, TSS, upstream/downstream flanks) '''
    to_cluster = True
    feature_list = P.asList( PARAMS["geneset_feature_list"] )
    outfiles = ""
    first = True
    for feature in feature_list:
        feature_name = P.snip( os.path.basename( feature ), ".gtf" ).replace(".","_")
        outfiles += " %(outfile)s.%(feature_name)s " % locals()
        if first:
            cut_command = "cut -f1,4,5,6,8 "
            first = False
        else:
            cut_command = "cut -f4,5,6 "
        statement = """
                cat %(infile)s
                | python %(scriptsdir)s/bed2gff.py --as-gtf
                | python %(scriptsdir)s/gtf2table.py
		                --counter=overlap
		                --counter=length
		                --log=%(outfile)s.log
		                --filename-gff=%(geneset_dir)s/%(feature)s
		                --genome-file=%(genome_dir)s/%(genome)s
                | %(cut_command)s
                | sed s/nover/%(feature_name)s_nover/g
                | sed s/pover/%(feature_name)s_pover/g
                | sed s/min/length/
                > %(outfile)s.%(feature_name)s"""
        P.run()
    # Paste output together
    statement = '''paste  %(outfiles)s > %(outfile)s'''
    P.run()

############################################################
@transform( annotateCapseqGenesetOverlap, suffix(".geneset_overlap"), ".geneset_overlap.load" )
def loadCapseqGenesetOverlap( infile, outfile ):
    '''load interval annotations: genome architecture '''
    geneset_name = PARAMS["geneset_name"]
    track= P.snip( os.path.basename(infile), ".geneset_overlap").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_overlap
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################    
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".genes_capseq_overlap" )
def annotateGenesetCapseqOverlap( infile, outfile ):
    '''classify intervals according to their base pair overlap with respect to different genomic features (genes, TSS, upstream/downstream flanks) '''
    to_cluster = True
    genes = PARAMS["geneset_genes"]
    track = P.snip( os.path.basename(infile), ".bed")
    statement = """
                cat %(infile)s | python %(scriptsdir)s/bed2gff.py --as-gtf > %(track)s.gtf;
                cat %(geneset_dir)s/%(genes)s 
                | python %(scriptsdir)s/gtf2table.py
		                --counter=overlap
		                --counter=length
		                --log=%(outfile)s.log
		                --filename-gff=%(track)s.gtf
		                --genome-file=%(genome_dir)s/%(genome)s
                | sed s/nover/capseq_nover/g
                | sed s/pover/capseq_pover/g
                | sed s/min/length/
                > %(outfile)s"""
    P.run()

############################################################
@transform( annotateGenesetCapseqOverlap, suffix(".genes_capseq_overlap"), ".genes_capseq_overlap.load" )
def loadGenesetCapseqOverlap( infile, outfile ):
    '''load interval annotations: genome architecture '''
    geneset_name = PARAMS["geneset_name"]
    track= P.snip( os.path.basename(infile), ".genes_capseq_overlap").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_genes_capseq_overlap
                         --index=gene_id
                 > %(outfile)s; """
    P.run()
            
############################################################
############################################################
## Section 1b: Count overlap of CAPseq intervals with gene/transcript TSSs
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".transcript_tss.overlap.count" )
def getCapseqTranscriptTSSOverlapCount( infile, outfile ):
    '''Establish overlap between capseq and gene tss intervals'''
    tss = os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_transcript_tss"] )
    to_cluster = True
    statement = """echo "CAPseq intervals overlapping 1 or more TSS" > %(outfile)s; intersectBed -a %(infile)s -b %(tss)s -u | wc -l >> %(outfile)s;  
                   echo "CAPseq intervals not overlapping any TSS" >> %(outfile)s; intersectBed -a %(infile)s -b %(tss)s -v | wc -l >> %(outfile)s; 
                   echo "TSSs overlapped by 1 or more CAPseq interval" >> %(outfile)s; intersectBed -a %(tss)s -b %(infile)s -u | wc -l >> %(outfile)s; 
                   echo "TSSs not overlapped by any CAPseq intervals" >> %(outfile)s; intersectBed -a %(tss)s -b %(infile)s -v | wc -l >> %(outfile)s; 
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; """
    P.run()

############################################################
@transform( getCapseqTranscriptTSSOverlapCount, suffix(".transcript_tss.overlap.count"), ".transcript_tss.overlap.count.load")
def loadCapseqTranscriptTSSOverlapCount(infile, outfile):
    '''Load transcript TSS Capseq overlap into database'''
    header = "track,intervals"
    track = P.snip( os.path.basename( infile), ".transcript_tss.overlap.count" )
    geneset_name = PARAMS["geneset_name"]
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                        --database=%(database)s
                        --table=%(track)s_%(geneset_name)s_transcript_tss_venn
                        --header=%(header)s
                   > %(outfile)s '''
    P.run()
    
############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".gene_tss.overlap.count" )
def getCapseqGeneTSSOverlapCount( infile, outfile ):
    '''Establish overlap between capseq and gene tss intervals'''
    tss = os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_gene_tss"] )
    to_cluster = True
    statement = """echo "CAPseq intervals overlapping 1 or more TSS" > %(outfile)s; intersectBed -a %(infile)s -b %(tss)s -u | wc -l >> %(outfile)s;  
                   echo "CAPseq intervals not overlapping any TSS" >> %(outfile)s; intersectBed -a %(infile)s -b %(tss)s -v | wc -l >> %(outfile)s; 
                   echo "TSSs overlapped by 1 or more CAPseq interval" >> %(outfile)s; intersectBed -a %(tss)s -b %(infile)s -u | wc -l >> %(outfile)s; 
                   echo "TSSs not overlapped by any CAPseq intervals" >> %(outfile)s; intersectBed -a %(tss)s -b %(infile)s -v | wc -l >> %(outfile)s; 
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; """
    P.run()

############################################################
@transform( getCapseqGeneTSSOverlapCount, suffix(".gene_tss.overlap.count"), ".gene_tss.overlap.count.load")
def loadCapseqGeneTSSOverlapCount(infile, outfile):
    '''Load gene TSS Capseq overlap into database'''
    header = "track,intervals"
    track = P.snip( os.path.basename( infile), ".gene_tss.overlap.count" )
    geneset_name = PARAMS["geneset_name"]
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                        --database=%(database)s
                        --table=%(track)s_%(geneset_name)s_gene_tss_venn
                        --header=%(header)s
                   > %(outfile)s '''
    P.run()
    
############################################################
############################################################
## Section 1c: Annotate CAPseq interval TTS/TTS distance
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".transcript.tss.distance" )
def annotateCapseqTranscriptTSSDistance( infile, outfile ):
    '''Compute distance from CAPseq intervals to nearest transcript TSS'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_transcript_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
	                 | python %(scriptsdir)s/gtf2table.py 
		                   --counter=distance-tss 
		                   --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( annotateCapseqTranscriptTSSDistance, suffix( ".transcript.tss.distance"), ".transcript.tss.distance.load" )
def loadCapseqTranscriptTSSDistance( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track= P.snip( os.path.basename(infile), ".transcript.tss.distance").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_transcript_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadCapseqTranscriptTSSDistance, suffix(".transcript.tss.distance.load"), ".transcript.tss.distance.export" )
def exportCapseqTSSTranscriptList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_%(geneset_name)s_transcript_tss_distance
               WHERE closest_id is not null ''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\ttranscript_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCapseqTSSTranscriptList, suffix( ".transcript.tss.distance.export"), ".transcript.tss.distance.export.load" )
def loadCapseqTSSTranscriptList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_interval_transcript_mapping
                         --index=transcript_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()
        
############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".gene.tss.distance" )
def annotateCapseqGeneTSSDistance( infile, outfile ):
    '''Compute distance from CAPseq intervals to nearest gene TSS (single TSS per gene)'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_gene_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
	                 | python %(scriptsdir)s/gtf2table.py 
		                   --counter=distance-tss 
		                   --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( annotateCapseqGeneTSSDistance, suffix( ".gene.tss.distance"), ".gene.tss.distance.load" )
def loadCapseqGeneTSSDistance( infile, outfile ):
    '''load CAPseq interval annotations: distance to gene transcription start sites '''
    track= P.snip( os.path.basename(infile), ".gene.tss.distance").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_gene_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadCapseqGeneTSSDistance, suffix(".gene.tss.distance.load"), ".gene.tss.distance.export" )
def exportCapseqTSSGeneList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".gene.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_%(geneset_name)s_gene_tss_distance
               WHERE closest_id is not null''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\tgene_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCapseqTSSGeneList, suffix( ".gene.tss.distance.export"), ".gene.tss.distance.export.load" )
def loadCapseqTSSGeneList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".gene.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_interval_gene_mapping
                         --index=gene_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()
    
############################################################
## Export bed files for CAPseq intervals overlapping TSS intervals
@transform( loadCapseqTranscriptTSSDistance, suffix( ".transcript.tss.distance.load"), ".transcript.tss.bed" )
def exportCapseqTSSBed( infile, outfile ):
    '''export bed file of all CAPseq intervals within 1kb of annotated  transcript TSS '''
    track= P.snip( os.path.basename(infile), ".transcript.tss.distance.load").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT i.contig, i.start, i.end, i.interval_id 
                   FROM %(track)s_intervals i, %(track)s_%(geneset_name)s_transcript_tss_distance t
                   WHERE i.interval_id=t.gene_id 
                   AND t.closest_dist < 1000
                   ORDER by contig, start''' % locals()
    cc.execute( statement )
    outs = open( outfile, "w")
    for result in cc:
        contig, start, stop, interval_id = result
        outs.write( "%s\t%i\t%i\t%i\n" % (contig, start, stop, interval_id) )
    cc.close()
    outs.close()
    
############################################################
@transform( loadCapseqTranscriptTSSDistance, suffix( ".transcript.tss.distance.load"), ".intergenic.bed" )
def exportCapseqIntergenicBed( infile, outfile ):
    '''export bed file of all CAPseq intervals not within 1kb of annotated  transcript TSS '''
    track= P.snip( os.path.basename(infile), ".transcript.tss.distance.load").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT i.contig, i.start, i.end, i.interval_id 
                   FROM %(track)s_intervals i, %(track)s_%(geneset_name)s_transcript_tss_distance t
                   WHERE i.interval_id=t.gene_id 
                   AND t.closest_dist >= 1000
                   ORDER by contig, start''' % locals()
    cc.execute( statement )
    outs = open( outfile, "w")
    for result in cc:
        contig, start, stop, interval_id = result
        outs.write( "%s\t%i\t%i\t%i\n" % (contig, start, stop, interval_id) )
    cc.close()
    outs.close()

############################################################
@transform(copyCapseqReplicatedBedFiles, suffix(".bed"), ".noncoding.tss.distance" )
def getCapseqNoncodingTSSDistance( infile, outfile ):
    '''Calculate distance of CAPseq peaks to nearest non-coding transcript TSS'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_noncoding_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
	               | python %(scriptsdir)s/gtf2table.py 
		                   --counter=distance-tss 
		                   --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( getCapseqNoncodingTSSDistance, suffix( ".noncoding.tss.distance"), ".noncoding.tss.distance.load" )
def loadCapseqNoncodingTSSDistance( infile, outfile ):
    '''Load interval annotations: distance to non-coding transcription start sites '''
    track= P.snip( os.path.basename(infile), ".noncoding.tss.distance").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_noncoding_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadCapseqNoncodingTSSDistance, suffix(".noncoding.tss.distance.load"), ".noncoding.tss.distance.export" )
def exportCapseqNoncodingTSSGeneList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".noncoding.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_%(geneset_name)s_noncoding_tss_distance
               WHERE closest_id is not null''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\tgene_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCapseqNoncodingTSSGeneList, suffix( ".noncoding.tss.distance.export"), ".noncoding.tss.distance.export.load" )
def loadCapseqNoncodingTSSGeneList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".noncoding.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_interval_noncoding_mapping
                         --index=gene_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()

############################################################    
############################################################
## External linCRNA datasets
@files( PARAMS["geneset_lncrna_tss"], "lncrna.load" )
def loadlncRNAs( infile, outfile ):
    '''Load external lncRNA dataset into db '''
    header="contig,start,end,id,strand"
    statement = """zcat %(infile)s 
                   | awk 'OFS="\\t" {print $1,$2,$3,$4,$6}'
                   | python ~/src/csv2db.py 
                         --database=%(database)s
                         --header=%(header)s
                         --table=lncrna_bed
                         --index=contig,start
                 > %(outfile)s; """
    P.run()
    
############################################################
@transform(copyCapseqReplicatedBedFiles, suffix(".bed"), ".lncrna.tss.distance" )
def getCapseqlncRNATSSDistance( infile, outfile ):
    '''Calculate distance of CAPseq peaks to nearest lncRNA transcript TSS'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_lncrna_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
		               --counter=distance-tss 
		               --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( getCapseqlncRNATSSDistance, suffix( ".lncrna.tss.distance"), ".lncrna.tss.distance.load" )
def loadCapseqlncRNATSSDistance( infile, outfile ):
    '''Load interval annotations: distance to lncRNA transcription start sites '''
    track= P.snip( os.path.basename(infile), ".lncrna.tss.distance").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_lncrna_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadCapseqlncRNATSSDistance, suffix(".lncrna.tss.distance.load"), ".lncrna.tss.distance.export" )
def exportCapseqlncRNATSSGeneList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".lncrna.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_lncrna_tss_distance
               WHERE closest_id is not null''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\tgene_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCapseqlncRNATSSGeneList, suffix( ".lncrna.tss.distance.export"), ".lncrna.tss.distance.export.load" )
def loadCapseqlncRNATSSGeneList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".lncrna.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_interval_lncrna_mapping
                         --index=gene_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()
    
############################################################
############################################################
## External RNAseq transcripts
@files( PARAMS["geneset_rnaseq_tss"], "rnaseq.load" )
def loadRNAseq( infile, outfile ):
    '''Load external RNAseq dataset into db '''
    header="contig,start,end,id,strand"
    statement = """zcat %(infile)s 
                   | awk 'OFS="\\t" {print $1,$2,$3,$4,$6}'
                   | python ~/src/csv2db.py 
                         --database=%(database)s
                         --header=%(header)s
                         --table=rnaseq_bed
                         --index=contig,start
                 > %(outfile)s; """
    P.run()

############################################################
@transform(copyCapseqReplicatedBedFiles, suffix(".bed"), ".rnaseq.tss.distance" )
def getCapseqRNAseqTSSDistance( infile, outfile ):
    '''Calculate distance of CAPseq peaks to nearest lncRNA transcript TSS'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_rnaseq_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
		               --counter=distance-tss 
		               --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( getCapseqRNAseqTSSDistance, suffix( ".rnaseq.tss.distance"), ".rnaseq.tss.distance.load" )
def loadCapseqRNAseqTSSDistance( infile, outfile ):
    '''Load interval annotations: distance to lncRNA transcription start sites '''
    track= P.snip( os.path.basename(infile), ".rnaseq.tss.distance").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_rnaseq_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadCapseqRNAseqTSSDistance, suffix(".rnaseq.tss.distance.load"), ".rnaseq.tss.distance.export" )
def exportCapseqRNAseqTSSGeneList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".rnaseq.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_rnaseq_tss_distance
               WHERE closest_id is not null''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\tgene_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCapseqRNAseqTSSGeneList, suffix( ".rnaseq.tss.distance.export"), ".rnaseq.tss.distance.export.load" )
def loadCapseqRNAseqTSSGeneList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".rnaseq.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_interval_rnaseq_mapping
                         --index=gene_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()
                
############################################################
############################################################
## Section 1d: Calculate pileup of CAPseq reads over TSS/TTS
@follows( mkdir("tss-profile") )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.transcript.tss-profile.all.png" )
def getReplicatedTranscriptTSSProfile(infile, outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    tss_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    ofp = "tss-profile/" + track + ".replicated.transcript.tss-profile.all"
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tss_file)s
                       --output-filename-pattern=%(ofp)s
                       --reporter=transcript
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
## TSSs associated (within 1kb) with a CAPseq interval only
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.transcript.tss-profile.capseq.png" )
def getReplicatedTranscriptTSSProfileCapseq(infile,outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    ofp = "tss-profile/" + track + ".replicated.transcript.tss-profile.capseq"
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    tss_file = os.path.join( PARAMS["geneset_dir"],  PARAMS["geneset_transcript_tss"])
    tmpfile = P.getTempFile()
    tmpfilename = tmpfile.name
    statement = '''intersectBed -a %(tss_file)s -b %(infile)s -u | cut -f4 > %(tmpfilename)s; 
                   zcat %(gene_file)s | python %(scriptsdir)s/gtf2gtf.py --filter=transcript --apply=%(tmpfilename)s | gzip > %(tmpfilename)s.gtf.gz; 
                   python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tmpfilename)s.gtf.gz
                       --output-filename-pattern=%(ofp)s
                       --reporter=transcript
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
## TSSs NOT associated (within 1kb) with a CAPseq interval only
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.transcript.tss-profile.nocapseq.png" )
def getReplicatedTranscriptTSSProfileNoCapseq(infile,outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    ofp = "tss-profile/" + track + ".replicated.transcript.tss-profile.nocapseq"
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    tss_file = os.path.join( PARAMS["geneset_dir"],  PARAMS["geneset_transcript_tss"])
    tmpfile = P.getTempFile()
    tmpfilename = tmpfile.name
    statement = '''intersectBed -a %(tss_file)s -b %(infile)s -v | cut -f4 > %(tmpfilename)s; 
                   zcat %(gene_file)s | python %(scriptsdir)s/gtf2gtf.py --filter=transcript --apply=%(tmpfilename)s | gzip > %(tmpfilename)s.gtf.gz; 
                   python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tmpfilename)s.gtf.gz
                       --output-filename-pattern=%(ofp)s
                       --reporter=transcript
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
## Per gene
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.gene.tss-profile.all.png" )
def getReplicatedGeneTSSProfile(infile, outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    tss_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    ofp = "tss-profile/" + track + ".replicated.gene.tss-profile.all"
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tss_file)s
                       --output-filename-pattern=%(ofp)s
                       --reporter=gene
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.gene.tss-profile.capseq.png" )
def getReplicatedGeneTSSProfileCapseq(infile,outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    ofp = "tss-profile/" + track + ".replicated.gene.tss-profile.capseq"
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    tss_file = os.path.join( PARAMS["geneset_dir"],  PARAMS["geneset_transcript_tss"])
    tmpfile = P.getTempFile()
    tmpfilename = tmpfile.name
    statement = '''intersectBed -a %(tss_file)s -b %(infile)s -u | cut -f4 > %(tmpfilename)s; 
                   zcat %(gene_file)s | python %(scriptsdir)s/gtf2gtf.py --filter=transcript --apply=%(tmpfilename)s | gzip > %(tmpfilename)s.gtf.gz; 
                   python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tmpfilename)s.gtf.gz
                       --output-filename-pattern=%(ofp)s
                       --reporter=gene
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"tss-profile/\1.replicated.gene.tss-profile.nocapseq.png" )
def getReplicatedGeneTSSProfileNoCapseq(infile,outfile):
    '''Build TSS profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    ofp = "tss-profile/" + track + ".replicated.gene.tss-profile.nocapseq"
    # setup files
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    tss_file = os.path.join( PARAMS["geneset_dir"],  PARAMS["geneset_transcript_tss"])
    tmpfile = P.getTempFile()
    tmpfilename = tmpfile.name
    statement = '''intersectBed -a %(tss_file)s -b %(infile)s -v | cut -f4 > %(tmpfilename)s; 
                   zcat %(gene_file)s | python %(scriptsdir)s/gtf2gtf.py --filter=transcript --apply=%(tmpfilename)s | gzip > %(tmpfilename)s.gtf.gz; 
                   python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tmpfilename)s.gtf.gz
                       --output-filename-pattern=%(ofp)s
                       --reporter=gene
                       --method=tssprofile
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################
############################################################
## Section 1d: Calculate pileup of CAPseq reads over genes
@follows( mkdir("gene-profile") )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"gene-profile/\1.replicated.transcript-profile.all.png" )
def getReplicatedTranscriptProfile(infile, outfile):
    '''Build transcript profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    tss_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    ofp = "gene-profile/" + track + ".replicated.transcript-profile.all"
    # setup files
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       %(shifts)s 
                       --gtffile=%(tss_file)s
                       --output-filename-pattern=%(ofp)s
                       --reporter=transcript
                       --method=geneprofile
                       --normalization=total-sum
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()

############################################################   
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"gene-profile/\1.replicated.gene-profile.all.png" ) 
def getReplicatedGeneProfile(infile, outfile):
    '''Build transcript profile from BAM files'''
    to_cluster = USECLUSTER
    track = P.snip( os.path.basename(infile), ".replicated.bed" )
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]
    tss_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    ofp = "gene-profile/" + track + ".replicated.gene-profile.all"
    # setup files
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t.asFile()
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( fn )
        fn = "../macs/with_input/%s.macs" % t.asFile()
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )
    bamfiles = " ".join( ("--bamfile=%s" % x) for x in samfiles )
    shifts =  " ".join( ("--shift=%s" % y)  for y in offsets )
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                       %(bamfiles)s 
                       --gtffile=%(tss_file)s
                       --output-filename-pattern=%(ofp)s
                       %(shifts)s
                       --reporter=gene
                       --method=geneprofile
                       --normalization=total-sum
                       --normalize-profile=area
                       --normalize-profile=counts
                       --normalize-profile=none'''
    P.run()
    
############################################################
############################################################
## Section 1f: Export lists of genes with TSS-associated CAPseq intervals
@transform( loadCapseqTranscriptTSSDistance, suffix(".transcript.tss.distance.load"), ".transcript.tss_distance_1kb.genelist")
def exportCapseqTranscriptTSSDistanceTranscriptList( infile, outfile):
    '''Export list of genes where one or more transcript TSS is within 1kb of a replicated CAPseq interval'''
    max_gene_dist = 1000
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.load" ).replace("-","_").replace(".","_")
    # Extract data from db
    cc = dbhandle.cursor()
    query = '''SELECT closest_id FROM %(track)s_%(geneset_name)s_transcript_tss_distance
               WHERE closest_dist < %(max_gene_dist)s ORDER BY closest_dist;''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        ids = str(result[0])
        genes = ids.split(",")
        for g in genes:
            outs.write( "%s\n" % g )
    cc.close()
    outs.close()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".transcript.tss_overlap_1kb.genelist")
def exportCapseqTranscriptTSSOverlapTranscriptList( infile, outfile):
    '''Export list of genes where one or more extended transcript TSS overlaps a replicated CAPseq interval. Alternative method to above.'''
    # Currently outputs transcript list
    transcript_tss_bed = PARAMS["geneset_transcript_tss_extended"]
    geneset_dir = PARAMS["geneset_dir"]
    statement = '''intersectBed -a %(geneset_dir)s/%(transcript_tss_bed)s -b %(infile)s -u | cut -f4 | sort -u > %(outfile)s'''
    P.run()

############################################################
############################################################
## Compare CAPseq intervals with genomic features using GAT
@follows( mkdir("gat") )
@files(PARAMS["samtools_genome"]+".fai", "gat/"+PARAMS["genome"]+".bed.gz")
def buildGATWorkspace(infile, outfile ):
    '''Build genomic workspace file for GAT '''
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,0,$2,"workspace"}' | gzip > %(outfile)s '''
    P.run()
    
############################################################
@follows(buildGATWorkspace)
@merge( copyCapseqReplicatedBedFiles, "gat/genomic_features_gat.tsv" )
def runGenomicFeaturesGAT(infiles, outfile):
    '''Run genome association tester on bed files '''
    to_cluster = True
    
    # Segment files
    segfiles = ""
    for x in infiles:
        track = P.snip(os.path.basename(x), ".replicated.bed")
        statement = """cat %(x)s | awk 'OFS="\\t" {print $1,$2,$3,"%(track)s"}' > gat/%(track)s.bed; """
        P.run()
        segfiles += " --segment-file=gat/%s.bed " % track
        
    # Annotation files
    annofiles = ""
    anno_list = P.asList(PARAMS["geneset_feature_list"])
    anno_dir = PARAMS["geneset_dir"]
    for y in anno_list:
        annotrack = P.snip(os.path.basename(y), ".gtf")
        statement = """cat %(anno_dir)s/%(y)s | python %(scriptsdir)s/gff2bed.py --name='feature' --is-gtf | sed s/exon/%(annotrack)s/g > gat/%(annotrack)s.bed; """
        P.run()
        annofiles += " --annotation-file=gat/%s.bed " % annotrack
    # Run GAT
    statement = """gatrun.py %(segfiles)s %(annofiles)s --workspace=gat/%(genome)s.bed.gz --num-samples=1000 --force --nbuckets=120000 > %(outfile)s"""
    P.run()

############################################################
@transform( runGenomicFeaturesGAT, suffix(".tsv"), ".tsv.load" )
def loadGenomicFeaturesGAT(infile, outfile):
    '''Load genome association tester results into database '''
    statement = """cat %(infile)s | grep -v "^#" | python %(scriptsdir)s/csv2db.py 
                       --database=%(database)s
                       --table=gat_genomic_features_results 
                   > %(outfile)s"""
    P.run()    


########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 2: Annotate CAPseq interval nucleotide composition
########################################################################################################################
########################################################################################################################
########################################################################################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".capseq.composition" )
def annotateCapseqComposition( infile, outfile ):
    '''Establish the nucleotide composition of intervals'''
    to_cluster = True
    statement = """cat %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateCapseqComposition, suffix( ".composition"), ".composition.load" )
def loadCapseqComposition( infile, outfile ):
    '''Load the nucleotide composition of intervals'''
    track= P.snip( os.path.basename(infile), ".composition").replace(".cleaned","").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_composition 
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".control.composition" )
def annotateControlComposition( infile, outfile ):
    '''Establish the nucleotide composition of control intervals'''
    to_cluster = True
    track= P.snip( os.path.basename(infile), ".bed")
    dirname= os.path.dirname(infile)
    statement = """cat %(infile)s | python %(scriptsdir)s/bed2bed.py -m shift -g %(genome_dir)s/%(genome)s --offset=-10000 -S %(track)s.control.bed;
                   cat %(track)s.control.bed
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateControlComposition, suffix( ".control.composition"), ".control.composition.load" )
def loadControlComposition( infile, outfile ):
    '''Load the nucleotide composition of intervals'''
    track= P.snip( os.path.basename(infile), ".control.composition").replace(".cleaned","").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_composition_control
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".flanking5.composition" )
def annotateFlankingCompositionLeft( infile, outfile ):
    '''Establish the nucleotide composition of intervals immediately upstream'''
    to_cluster = True
    track= P.snip( os.path.basename(infile), ".bed")
    dirname= os.path.dirname(infile)
    flank_size = PARAMS["geneset_flank_size"]
    # Exclude intervals with length < 100bp
    statement = """flankBed -i %(infile)s -l %(flank_size)s -r 0 -g %(samtools_genome)s.fai 
                   | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s -L %(track)s.flanking5.log 
                   | awk 'OFS="\\t" {if ($3-$2>100) print $1,$2,$3,$4}' > %(track)s.flanking5.bed;
                   cat %(track)s.flanking5.bed
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateFlankingCompositionLeft, suffix( ".flanking5.composition"), ".flanking5.composition.load" )
def loadFlankingCompositionLeft( infile, outfile ):
    '''Load the nucleotide composition of regions flanking intervals'''

    track= P.snip( os.path.basename(infile), ".flanking5.composition").replace(".cleaned","").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_composition_flanking5
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".flanking3.composition" )
def annotateFlankingCompositionRight( infile, outfile ):
    '''Establish the nucleotide composition of intervals immediately downstream'''

    to_cluster = True
    track= P.snip( os.path.basename(infile), ".bed")
    dirname= os.path.dirname(infile)
    flank_size = PARAMS["geneset_flank_size"]

    # Exclude intervals with length < 100bp
    statement = """flankBed -i %(infile)s -l 0 -r 1000 -g %(samtools_genome)s.fai 
                   | python %(scriptsdir)s/bed2bed.py --method=filter-genome --genome-file=%(genome_dir)s/%(genome)s -L %(track)s.flanking3.log 
                   | awk 'OFS="\\t" {if ($3-$2>100) print $1,$2,$3,$4}' > %(track)s.flanking3.bed;
                   cat %(track)s.flanking3.bed
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateFlankingCompositionRight, suffix( ".flanking3.composition"), ".flanking3.composition.load" )
def loadFlankingCompositionRight( infile, outfile ):
    '''Load the nucleotide composition of regions flanking intervals'''
    track= P.snip( os.path.basename(infile), ".flanking3.composition").replace(".cleaned","").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_composition_flanking3
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
############################################################
@transform( loadCapseqComposition, suffix(".replicated.capseq.composition.load"), ".replicated.gc.export" )
def exportCapseqGCProfiles( infile, outfile ):
    '''Export file of GC content '''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.capseq.composition.load" ).replace("-","_").replace(".","_")
    # Extract data from db
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pGC, cc.pGC, c3.pGC, c5.pGC 
               FROM %(track)s_replicated_capseq_composition c
               left join %(track)s_replicated_composition_control cc on c.gene_id=cc.gene_id
               left join %(track)s_replicated_composition_flanking3 c3 on c.gene_id=c3.gene_id
               left join %(track)s_replicated_composition_flanking5 c5 on c.gene_id=c5.gene_id;''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadCapseqComposition, suffix(".replicated.capseq.composition.load"), ".replicated.cpg.export" )
def exportCapseqCpGObsExp( infile, outfile ):
    '''Export file of GC content '''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.capseq.composition.load" ).replace("-","_").replace(".","_")
    # Extract data from db
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.CpG_ObsExp, cc.CpG_ObsExp, c3.CpG_ObsExp, c5.CpG_ObsExp 
               FROM %(track)s_replicated_capseq_composition c
               left join %(track)s_replicated_composition_control cc on c.gene_id=cc.gene_id
               left join %(track)s_replicated_composition_flanking3 c3 on c.gene_id=c3.gene_id
               left join %(track)s_replicated_composition_flanking5 c5 on c.gene_id=c5.gene_id;''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadCapseqComposition, suffix(".replicated.capseq.composition.load"), ".replicated.cpg_density.export" )
def exportCapseqCpGDensity( infile, outfile ):
    '''Export file of GC content '''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.capseq.composition.load" ).replace("-","_").replace(".","_")
    # Extract data from db
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pCpG, cc.pCpG, c3.pCpG, c5.pCpG 
               FROM %(track)s_replicated_capseq_composition c
               left join %(track)s_replicated_composition_control cc on c.gene_id=cc.gene_id
               left join %(track)s_replicated_composition_flanking3 c3 on c.gene_id=c3.gene_id
               left join %(track)s_replicated_composition_flanking5 c5 on c.gene_id=c5.gene_id;''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()


########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 3: Compare CAPseq intervals with external datasets
########################################################################################################################
########################################################################################################################
########################################################################################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".cgi_overlap")
def getCapseqCGIOverlapCount(infile, outfile):
    '''identify intervals overlapping CGI for each datasets'''
    CGI = P.asList(PARAMS["bed_cgi"])
    if os.path.exists(outfile):
        statement = '''rm %(outfile)s'''
        P.run()
    for dataset in CGI:
        dataset_name =  P.snip( os.path.basename( dataset ), ".bed")
        statement = '''echo %(dataset_name)s >> %(outfile)s; intersectBed -a %(infile)s -b %(dataset)s -u | wc -l >> %(outfile)s; '''
        P.run()
    statement = '''sed -i '{N;s/\\n/\\t/}' %(outfile)s; '''
    P.run()

############################################################
@transform( getCapseqCGIOverlapCount, suffix(".cgi_overlap"), ".cgi_overlap.load")
def loadCapseqCGIOverlapCount(infile, outfile):
    '''Load intervals overlapping CGI into database '''
    track = P.snip( os.path.basename( infile ), ".cgi_overlap" ).replace(".","_").replace("-","_")
    header = "track,overlap"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_cgi_venn
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".cgi_cap.bed")
def getCGIAndCapseqIntervals(infile, outfile):
    '''identify intervals overlapping CGI for each datasets'''
    CGI = PARAMS["bed_ucsc_cgi"]
    dataset_name =  P.snip( os.path.basename( CGI ), ".bed")
    statement = '''intersectBed -a %(infile)s -b %(CGI)s -u > %(outfile)s; '''
    P.run()

############################################################
@transform( getCGIAndCapseqIntervals, suffix(".cgi_cap.bed"), ".cgi_cap.bed.load")
def loadCGIAndCapseqIntervals(infile, outfile):
    '''Load intervals overlapping CGI into database '''
    track = P.snip( os.path.basename( infile ), ".cgi_cap.bed" ).replace(".","_").replace("-","_")
    header = "contig,start,stop,interval_id"
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,$2,$3,$4}' | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_predicted_cgi_and_cap
                      --index=contig,start
                      --index=interval_id
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".cap_only.bed")
def getCapseqSpecificIntervals(infile, outfile):
    '''identify CApseq intervals not overlapping predicted CGI for each dataset'''
    CGI = PARAMS["bed_ucsc_cgi"]
    dataset_name =  P.snip( os.path.basename( CGI ), ".bed")
    statement = '''intersectBed -a %(infile)s -b %(CGI)s -v > %(outfile)s; '''
    P.run()

############################################################
@transform( getCapseqSpecificIntervals, suffix(".cap_only.bed"), ".cap_only.bed.load")
def loadCapseqSpecificIntervals(infile, outfile):
    '''Load intervals not overlapping CGI into database '''
    track = P.snip( os.path.basename( infile ), ".cap_only.bed" ).replace(".","_").replace("-","_")
    header = "contig,start,stop,interval_id"
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,$2,$3,$4}' | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_cap_not_predicted_cgi
                      --index=contig,start
                      --index=interval_id
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".cgi_only.bed")
def getPredictedCGIIntervals(infile, outfile):
    '''identify predicted CGI intervals not overlapping CAPseq intervals for each dataset'''
    CGI = PARAMS["bed_ucsc_cgi"]
    statement = '''cat %(CGI)s | awk 'OFS="\\t" {print $1,$2,$3,$4NR}' | intersectBed -a stdin -b %(infile)s -v > %(outfile)s; '''
    P.run()

############################################################
@transform( getPredictedCGIIntervals, suffix(".cgi_only.bed"), ".cgi_only.bed.load")
def loadPredictedCGIIntervals(infile, outfile):
    '''Load predicted CGI intervals not overlapping CAP-seq intervals into database '''
    track = P.snip( os.path.basename( infile ), ".cgi_only.bed" ).replace(".replicated","")
    table = P.snip( os.path.basename( infile ), ".cgi_only.bed" ).replace(".","_").replace("-","_")
    expt_track = track + "-agg"
    replicates = EXPERIMENTS[expt_track]

    # Write header to output file
    tmpfile = tempfile.NamedTemporaryFile(delete=False)
    headers = ( "contig","start","stop","interval_id","nPeaks","PeakCenter","Length","AvgVal","PeakVal","nProbes" )
    tmpfile.write( "\t".join(headers) + "\n" )
    contig,start,end,interval_id,npeaks,peakcenter,length,avgval,peakval,nprobes = "",0,0,0,0,0,0,0,0,0

    # setup files
    samfiles, offsets = [], []
    for t in replicates:
        fn = "../bam/%s.norm.bam" % t
        assert os.path.exists( fn ), "could not find bamfile %s for track %s" % ( fn, str(t))
        samfiles.append( pysam.Samfile( fn,  "rb" ) )
        fn = "../macs/with_input/%s.macs" % t
        if os.path.exists( fn ):
            offsets.append( PIntervals.getPeakShiftFromMacs( fn ) )

    # Loop over input Bed file and calculate stats for merged intervals
    c = E.Counter()
    for line in open(infile, "r"):
        c.input += 1
        contig, start, end, interval_id = line[:-1].split()[:4]
        start, end = int(start), int(end)
        #interval_id = c.input
        npeaks, peakcenter, length, avgval, peakval, nprobes = PIntervals.countPeaks( contig, start, end, samfiles, offsets )
        if nprobes == 0:
            c.skipped_reads += 1
        c.output += 1
        tmpfile.write( "\t".join( map( str, (contig,start,end,interval_id,npeaks,peakcenter,length,avgval,peakval,nprobes) )) + "\n" )
    tmpfile.close()
    tmpfilename = tmpfile.name
    tablename = "%s_predicted_cgi_not_cap" % table
    
    statement = '''python %(scriptsdir)s/csv2db.py %(csv2db_options)s
                       --database=%(database)s
                       --index=contig,start 
                       --table=%(tablename)s
                       --allow-empty
                   < %(tmpfilename)s > %(outfile)s '''
    P.run()
    os.unlink( tmpfile.name )
    #L.info( "%s\n" % str(c) )
    
############################################################
## Load external bed file stats
@merge( "external_bed/*.bed", "external_interval_sets.stats" )
def getExternalBedStats(infiles, outfile):
    '''Calculate statistics for external bed files '''
    chromatin = P.asList(PARAMS["bed_chromatin"])
    capseq = P.asList(PARAMS["bed_capseq"])
    chipseq = P.asList(PARAMS["bed_chipseq"])
    CGI = P.asList(PARAMS["bed_cgi"])
    extBed = chromatin + capseq + chipseq + CGI

    if os.path.exists(outfile):
        statement = '''rm %(outfile)s'''
        P.run()

    for f in extBed:
        if len(f) > 0:
            track = P.snip( os.path.basename(f),".bed" )
            statement = """echo '%(track)s' >> %(outfile)s; cat %(f)s | wc -l >> %(outfile)s; """
            P.run()
    statement = '''sed -i '{N;s/\\n/\\t/}' %(outfile)s; '''
    P.run()

############################################################
@transform( getExternalBedStats, suffix(".stats"), ".stats.load" )
def loadExternalBedStats(infile, outfile):
    '''Load statistics for external bed files into database '''
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --header=bed,intervals
                         --table=external_interval_sets 
                    > %(outfile)s"""
    P.run()

############################################################
## Compare CAPseq intervals with chromatin marks
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".chromatin")
def getChromatinMarkOverlap(infile, outfile):
    '''identify intervals overlapping chromatin mark intervals for each datasets'''
    chromatin = P.asList(PARAMS["bed_chromatin"])
    if os.path.exists(outfile):
        statement = '''rm %(outfile)s'''
        P.run()
    if len(chromatin[0]) > 0:
        for mark in chromatin:
           dataset_name =  P.snip( os.path.basename( mark ), ".bed")
           statement = '''echo %(dataset_name)s >> %(outfile)s; intersectBed -a %(infile)s -b %(mark)s -u | wc -l >> %(outfile)s; '''
           P.run()
        statement = '''sed -i '{N;s/\\n/\\t/}' %(outfile)s; '''
        P.run()
    else:
        statement = '''touch %(outfile)s '''
        P.run()

############################################################
@transform( getChromatinMarkOverlap, suffix(".chromatin"), ".chromatin.load")
def loadChromatinMarkIntervals(infile, outfile):
    '''Load intervals overlapping chromatin marks into database '''
    track = P.snip( os.path.basename( infile ), ".chromatin" ).replace(".","_").replace("-","_")
    header = "track,overlap"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                       --database=%(database)s
                      --table=%(track)s_chromatin
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
@transform(copyCapseqReplicatedBedFiles, suffix(".bed"), ".h3k4me1.bed" )
def getH3K4Me1Overlap( infile, outfile ):
    '''Calculate overlap of CAPseq peaks and h3k4me1 peaks (enhancer)'''
    to_cluster = True
    annotation_file = PARAMS["bed_h3k4me1"]
    if len(annotation_file) > 0:
        statement = """intersectBed -a %(infile)s -b %(annotation_file)s -u > %(outfile)s"""
        P.run()

############################################################
@transform( getH3K4Me1Overlap, suffix( ".h3k4me1.bed"), ".h3k4me1.bed.load" )
def loadH3K4Me1Overlap( infile, outfile ):
    '''Load interval annotations: h3k4me1 overlap '''
    track= P.snip( os.path.basename(infile), ".h3k4me1.bed").replace(".","_").replace("-","_")
    header = "contig,start,end,interval_id"
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --header=%(header)s
                         --table=%(track)s_h3k4me1_intervals
                         --index=interval_id
                         --index=contig,start
                 > %(outfile)s; """
    P.run()
          
############################################################
## Compare CAPseq intervals with ChIP-seq intervals
@transform(copyCapseqReplicatedBedFiles, suffix(".bed"), ".chipseq")
def getChipseqOverlap(infile, outfile):
    '''identify intervals overlapping chipseq intervals for each datasets'''
    chipseq = P.asList(PARAMS["bed_chipseq"])
    if os.path.exists(outfile):
        statement = '''rm %(outfile)s'''
        P.run()
    if len(chipseq[0]) > 0:
        for tf in chipseq:
           dataset_name =  P.snip( os.path.basename( tf ), ".bed")
           statement = '''echo %(dataset_name)s >> %(outfile)s; intersectBed -a %(infile)s -b %(tf)s -u | wc -l >> %(outfile)s; '''
           P.run()
        statement = '''sed -i '{N;s/\\n/\\t/}' %(outfile)s; '''
        P.run()
    else:
        statement = '''touch %(outfile)s '''
        P.run()

############################################################
@transform( getChipseqOverlap, suffix(".chipseq"), ".chipseq.load")
def loadChipseqIntervals(infile, outfile):
    '''Load intervals overlapping chipseq into database '''
    track = P.snip( os.path.basename( infile ), ".chipseq" ).replace(".","_").replace("-","_")
    header = "track,overlap"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_chipseq
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
## Compare CAPseq intervals with external CAPseq intervals
@transform( copyCapseqReplicatedBedFiles, suffix(".bed"), ".capseq")
def getCapseqOverlap(infile, outfile):
    '''identify intervals overlapping capseq intervals for each datasets'''
    capseq = P.asList(PARAMS["bed_capseq"])
    if os.path.exists(outfile):
        statement = '''rm %(outfile)s'''
        P.run()
    if len(capseq[0]) > 0:
        for x in capseq:
            dataset_name =  P.snip( os.path.basename( x ), ".bed")
            statement = '''echo %(dataset_name)s >> %(outfile)s; intersectBed -a %(infile)s -b %(x)s -u | wc -l >> %(outfile)s; '''
            P.run()
        statement = '''sed -i '{N;s/\\n/\\t/}' %(outfile)s; '''
        P.run()
    else:
        statement = '''touch %(outfile)s '''
        P.run()

############################################################
@transform( getCapseqOverlap, suffix(".capseq"), ".capseq.load")
def loadCapseqIntervals(infile, outfile):
    '''Load intervals overlapping capseq into database '''
    track = P.snip( os.path.basename( infile ), ".capseq" ).replace(".","_").replace("-","_")
    header = "track,overlap"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_capseq
                      --header=%(header)s
                      --allow-empty
                   > %(outfile)s '''
    P.run()

############################################################
############################################################
## Compare intervals to external bed files using GAT
@follows( buildGATWorkspace )
@merge( copyCapseqReplicatedBedFiles, "gat/external_dataset_gat.tsv" )
def runExternalDatasetGAT(infiles, outfile):
    '''Run genome association tester on bed files '''
    to_cluster = True
    segfiles = ""
    for x in infiles:
        track = P.snip(os.path.basename(x), ".bed")
        statement = """cat %(x)s | awk 'OFS="\\t" {print $1,$2,$3,"%(track)s"}' > gat/%(track)s.bed; """
        P.run()
        segfiles += " --segment-file=gat/%s.bed " % track 

    # External datasets
    chromatin = P.asList(PARAMS["bed_chromatin"])
    capseq = P.asList(PARAMS["bed_capseq"])
    chipseq = P.asList(PARAMS["bed_chipseq"])
    CGI = P.asList(PARAMS["bed_cgi"])
    extBed = chromatin + capseq + chipseq + CGI
    annofiles = " ".join( [ "--annotation-file=%s" % x for x in extBed ] )
    statement = """gatrun.py %(segfiles)s %(annofiles)s --workspace=gat/%(genome)s.bed.gz --num-samples=1000 --nbuckets=120000 --force > %(outfile)s"""
    P.run()

############################################################
@transform( runExternalDatasetGAT, suffix(".tsv"), ".tsv.load" )
def loadExternalDatasetGAT(infile, outfile):
    '''Load genome association tester results into database '''
    statement = """cat %(infile)s | grep -v "^#" | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=external_dataset_gat_results gat/external_dataset_gat.tsv
                    > %(outfile)s"""
    P.run()

########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 4: Annotate predicted CGI Intervals
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows( mkdir("cgi") )
@files( PARAMS["bed_ucsc_cgi"], "cgi/ucsc.bed.load")
def loadUCSCPredictedCGIIntervals(infile, outfile):
    '''load CGI intervals'''
    header = "contig,start,stop,id"
    statement = '''cat %(infile)s | awk 'OFS="\\t" {print $1,$2,$3,$4NR}' | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=cgi_intervals
                      --index=contig,start
                      --index=id
                      --header=%(header)s
                   > %(outfile)s '''
    P.run()
    
############################################################
############################################################
## CGI nucleotide composition
@follows( loadUCSCPredictedCGIIntervals )
@files( PARAMS["bed_ucsc_cgi"], "cgi/cgi.composition" )
def annotateCGIComposition( infile, outfile ):
    '''Establish the nucleotide composition of CGI intervals'''
    to_cluster = True

    # Give each row a unique identifier
    statement = """cat %(infile)s 
                   | awk '{print $1,$2,$3,$4NR}'
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                         --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateCGIComposition, suffix( ".composition"), ".composition.load" )
def loadCGIComposition( infile, outfile ):
    '''Load the nucleotide composition of CGI intervals'''

    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=cgi_comp
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@follows( loadUCSCPredictedCGIIntervals )
@files( PARAMS["bed_ucsc_cgi"], "cgi/cgi.transcript.tss.distance" )
def getCGITSSDistance( infile, outfile ):
    '''Calculate distance of predicted CGIs to nearest non-coding transcript TSS'''
    to_cluster = False
    annotation_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_transcript_tss"] )
    statement = """cat < %(infile)s 
                   | awk '{print $1,$2,$3,$4NR}'
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
	               | python %(scriptsdir)s/gtf2table.py 
		                   --counter=distance-tss 
		                   --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( getCGITSSDistance, suffix( ".transcript.tss.distance"), ".transcript.tss.distance.load" )
def loadCGITSSDistance( infile, outfile ):
    '''Load interval annotations: distance to non-coding transcription start sites '''
    track= P.snip( os.path.basename(infile), ".transcript.tss.distance").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_transcript_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()
    
############################################################
@transform( loadCGITSSDistance, suffix(".transcript.tss.distance.load"), ".transcript.tss.distance.export" )
def exportCGITSSTranscriptList( infile, outfile ):
    '''Export list of transcripts closest to CAPseq intervals '''
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct gene_id, closest_id FROM %(track)s_%(geneset_name)s_transcript_tss_distance
               WHERE closest_id is not null ''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\ttranscript_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportCGITSSTranscriptList, suffix( ".transcript.tss.distance.export"), ".transcript.tss.distance.export.load" )
def loadCGITSSTranscriptList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.export" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_interval_transcript_mapping
                         --index=transcript_id
                         --index=interval_id
                   > %(outfile)s; """
    P.run()
    
############################################################
@transform( loadCGIComposition, suffix("cgi.composition.load"), "cgi.gc.export" )
def exportCGIGCProfiles( infile, outfile ):
    '''Export file of GC content '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pGC FROM cgi_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadCGIComposition, suffix("cgi.composition.load"), "cgi.cpg_density.export" )
def exportCGICpGDensity( infile, outfile ):
    '''Export file of CpG density '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pCpG FROM cgi_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadCGIComposition, suffix("cgi.composition.load"), "cgi.cpg.export" )
def exportCGICpGObsExp( infile, outfile ):
    '''Export file of CpG Observed / expected ratio '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.CpG_ObsExp FROM cgi_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
        
############################################################    
############################################################
## Compare predicted CGI intervals from UCSC with  TSS annotations
@files( ( os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_transcript_tss"] ), PARAMS["bed_ucsc_cgi"]), "cgi/cgi.transcript_tss.overlap.count" )
def getCGITranscriptTSSOverlapCount( infiles, outfile ):
    '''Establish overlap between UCSC predicted CGIs and  protein-coding transcript TSS intervals'''
    tss, cgi = infiles
    to_cluster = True
    statement = '''echo "Predicted CGIs overlapping 1 or more TSS" > %(outfile)s; intersectBed -a %(cgi)s -b %(tss)s -u | wc -l >> %(outfile)s; 
                   echo "Predicted CGIs not overlapping any TSS" >> %(outfile)s; intersectBed -a %(cgi)s -b %(tss)s -v | wc -l >> %(outfile)s; 
                   echo "TSS overlapped by 1 or more CGI" >> %(outfile)s; intersectBed -a %(tss)s -b %(cgi)s -u | wc -l >> %(outfile)s; 
                   echo "TSS not overlapped by any predicted CGI" >> %(outfile)s; intersectBed -a %(tss)s -b %(cgi)s -v | wc -l >> %(outfile)s; 
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; '''
    P.run()

############################################################    
@transform( getCGITranscriptTSSOverlapCount, regex(r"cgi/cgi.transcript_tss.overlap.count"), r"cgi/cgi.transcript_tss.overlap.count.load")
def loadCGITranscriptTSSOverlapCount(infile, outfile):
    '''Load UCSC predicted CGI overlap with  protein-coding transcript TSSs into database'''
    header = "track,intervals"
    geneset_name = PARAMS["geneset_name"]
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                        --database=%(database)s
                        --table=cgi_%(geneset_name)s_transcript_tss_venn
                        --header=%(header)s
                   > %(outfile)s '''
    P.run()    

############################################################
@files( ( os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_gene_tss"] ), PARAMS["bed_ucsc_cgi"]), "cgi/cgi.gene_tss.overlap.count" )
def getCGIGeneTSSOverlapCount( infiles, outfile ):
    '''Establish overlap between UCSC predicted CGIs and  protein-coding gene TSS intervals'''
    tss, cgi = infiles
    to_cluster = True
    statement = """echo "Predicted CGIs overlapping 1 or more TSS" > %(outfile)s; intersectBed -a %(cgi)s -b %(tss)s -u | wc -l >> %(outfile)s; 
                   echo "Predicted CGIs not overlapping any TSS" >> %(outfile)s; intersectBed -a %(cgi)s -b %(tss)s -v | wc -l >> %(outfile)s; 
                   echo "TSS overlapped by 1 or more CGI" >> %(outfile)s; intersectBed -a %(tss)s -b %(cgi)s -u | wc -l >> %(outfile)s; 
                   echo "TSS not overlapped by any predicted CGI" >> %(outfile)s; intersectBed -a %(tss)s -b %(cgi)s -v | wc -l >> %(outfile)s; 
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; """
    P.run()

############################################################
@transform( getCGIGeneTSSOverlapCount, regex(r"cgi/cgi.gene_tss.overlap.count"), r"cgi/cgi.gene_tss.overlap.count.load")
def loadCGIGeneTSSOverlapCount(infile, outfile):
    '''Load UCSC predicted CGI overlap with  protein-coding gene TSSs into database'''
    header = "track,intervals"
    geneset_name = PARAMS["geneset_name"]
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                        --database=%(database)s
                        --table=cgi_%(geneset_name)s_gene_tss_venn
                        --header=%(header)s
                   > %(outfile)s '''
    P.run()

############################################################
############################################################
## Record overlap of intervals with  protein-coding gene/transcript models
@files( PARAMS["bed_ucsc_cgi"], "cgi/cgi.geneset.overlap" )
def annotateCGIGenesetOverlap( infile, outfile ):
    '''classify predicted CGI intervals according to their base pair overlap 
       with respect to different genomic features (genes, TSS, upstream/downstream flanks) '''
    to_cluster = True
    feature_list = P.asList( PARAMS["geneset_feature_list"] )
    outfiles = ""
    first = True
    for feature in feature_list:
        feature_name = P.snip( os.path.basename( feature ), ".gtf" ).replace(".","_")
        outfiles += " %(outfile)s.%(feature_name)s " % locals()
        if first:
            cut_command = "cut -f1,4,5,6,8 "
            first = False
        else:
            cut_command = "cut -f4,5,6 "
        statement = """
                cat %(infile)s 
                | awk '{print $1,$2,$3,$4NR}'
                | python %(scriptsdir)s/bed2gff.py --as-gtf 
                | python %(scriptsdir)s/gtf2table.py 
		                --counter=overlap  
		                --counter=length  
		                --log=%(outfile)s.log 
		                --filename-gff=%(geneset_dir)s/%(feature)s 
		                --genome-file=%(genome_dir)s/%(genome)s
                | %(cut_command)s 
                | sed s/nover/%(feature_name)s_nover/g 
                | sed s/pover/%(feature_name)s_pover/g 
                | sed s/min/length/
                > %(outfile)s.%(feature_name)s"""
        P.run()
    # Paste output together
    statement = '''paste  %(outfiles)s > %(outfile)s'''
    P.run()

############################################################
@transform( annotateCGIGenesetOverlap, suffix(".geneset.overlap"), ".geneset.overlap.load" )
def loadCGIGenesetOverlap( infile, outfile ):
    '''load interval annotations: genome architecture '''
    track= P.snip( os.path.basename(infile), ".geneset.overlap").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_%(geneset_name)s_overlap 
                         --index=gene_id
                 > %(outfile)s; """
    P.run()
          
########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 5: Annotate nucleotide composition of protein-coding / non-coding TSSs
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows( mkdir("tss") )
@files( os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_transcript_tss"] ), "tss/tss.transcript.composition" )
def annotateTranscriptTSSComposition( infile, outfile ):
    '''Establish the nucleotide composition of tss intervals'''
    to_cluster = True
    tss_extend = PARAMS["geneset_tss_extend"]
    statement = """zcat %(infile)s 
                   | slopBed -i stdin -g %(samtools_genome)s.fai -b %(tss_extend)s
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateTranscriptTSSComposition, suffix( ".composition"), ".composition.load" )
def loadTranscriptTSSComposition( infile, outfile ):
    '''Load the nucleotide composition of tss intervals'''
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=tss_transcript_comp
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@files( os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_tss"] ), "tss/tss.gene.composition" )
def annotateGeneTSSComposition( infile, outfile ):
    '''Establish the nucleotide composition of tss intervals'''
    to_cluster = True
    tss_extend = PARAMS["geneset_tss_extend"]
    statement = """zcat %(infile)s 
                   | slopBed -i stdin -g %(samtools_genome)s.fai -b %(tss_extend)s
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateGeneTSSComposition, suffix( ".composition"), ".composition.load" )
def loadGeneTSSComposition( infile, outfile ):
    '''Load the nucleotide composition of tss intervals'''
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=tss_gene_comp
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@files( os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_tss_interval"] ), "tss/tss.gene.interval.composition" )
def annotateGeneTSSIntervalComposition( infile, outfile ):
    '''Establish the nucleotide composition of tss intervals'''
    to_cluster = True
    statement = """zcat %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateGeneTSSIntervalComposition, suffix( ".composition"), ".composition.load" )
def loadGeneTSSIntervalComposition( infile, outfile ):
    '''Load the nucleotide composition of tss intervals'''
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=tss_gene_interval_comp
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadTranscriptTSSComposition, suffix("tss.transcript.composition.load"), "tss.transcript.gc.export" )
def exportTranscriptTSSGCProfiles( infile, outfile ):
    '''Export file of GC content '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pGC FROM tss_transcript_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadGeneTSSComposition, suffix("tss.gene.composition.load"), "tss.gene.gc.export" )
def exportGeneTSSGCProfiles( infile, outfile ):
    '''Export file of GC content '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pGC FROM tss_gene_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadTranscriptTSSComposition, suffix("tss.transcript.composition.load"), "tss.transcript.cpg.export" )
def exportTranscriptTSSCpGObsExp( infile, outfile ):
    '''Export file of CpG observed / expected '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.CpG_ObsExp FROM tss_transcript_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadGeneTSSComposition, suffix("tss.gene.composition.load"), "tss.gene.cpg.export" )
def exportGeneTSSCpGObsExp( infile, outfile ):
    '''Export file of CpG observed / expected '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.CpG_ObsExp FROM tss_gene_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
    
############################################################
@transform( loadTranscriptTSSComposition, suffix("tss.transcript.composition.load"), "tss.transcript.cpg_density.export" )
def exportTranscriptTSSCpGDensity( infile, outfile ):
    '''Export file of CpG density '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pCpG FROM tss_transcript_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( loadGeneTSSComposition, suffix("tss.gene.composition.load"), "tss.gene.cpg_density.export" )
def exportGeneTSSCpGDensity( infile, outfile ):
    '''Export file of CpG density '''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    query = '''SELECT c.gene_id, c.pCpG FROM tss_gene_comp c;''' % locals()
    cc.execute( query )
    E.info( query )
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
                               
########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 6: Identify and annotate long and short CAPseq intervals
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows( loadCapseqTranscriptTSSDistance, loadCapseqGenesetOverlap, mkdir("long_intervals") )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"long_intervals/\1.long.genelist" )
def getLongIntervalGeneList( infile, outfile ):
    '''Generate bed file of top 500 longest intervals'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.bed" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct b.gene_id
               FROM (SELECT distinct s.closest_id, i.interval_id, i.contig, i.start, i.end, i.length, i.avgval, i.fold, o.genes_pover1, o.genes_pover2
               FROM %(track)s_replicated_intervals i, %(track)s_replicated_%(geneset_name)s_transcript_tss_distance s, 
               %(track)s_replicated_%(geneset_name)s_overlap o
               WHERE  i.interval_id=s.gene_id
               AND o.gene_id=i.interval_id
               AND i.length > 3000
               AND o.genes_pover2 > 0
               ORDER BY i.length desc
               LIMIT 1000) a,
               (SELECT "%%" || transcript_id || "%%" as pattern, t.gene_id, t.gene_biotype 
               FROM annotations.transcript_info t
               WHERE t.gene_biotype='protein_coding') b
               WHERE a.closest_id like b.pattern  
               ORDER BY a.length desc
               LIMIT 500''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@follows( loadCapseqTranscriptTSSDistance, loadCapseqGenesetOverlap, mkdir("long_intervals") )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"long_intervals/\1.gene_overlap.genelist" )
def getGeneOverlapGeneList( infile, outfile ):
    '''Generate bed file of top 500 longest intervals'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.bed" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct b.gene_id
               FROM (SELECT distinct s.closest_id, i.interval_id, i.contig, i.start, i.end, i.length, i.avgval, i.fold, o.genes_pover1, o.genes_pover2
               FROM %(track)s_replicated_intervals i, %(track)s_replicated_%(geneset_name)s_transcript_tss_distance s, 
               %(track)s_replicated_%(geneset_name)s_overlap o
               WHERE  i.interval_id=s.gene_id
               AND o.gene_id=i.interval_id
               AND i.length > 3000
               AND o.genes_pover2 > 80
               ORDER BY i.length desc
               LIMIT 1000) a,
               (SELECT "%%" || transcript_id || "%%" as pattern, t.gene_id, t.gene_biotype 
               FROM annotations.transcript_info t
               WHERE t.gene_biotype='protein_coding') b
               WHERE a.closest_id like b.pattern  
               ORDER BY a.length desc
               LIMIT 500''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()      
      
############################################################
@follows( loadCapseqTranscriptTSSDistance, loadCapseqGenesetOverlap, mkdir("long_intervals") )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"long_intervals/\1.short.genelist" )
def getShortIntervalGeneList( infile, outfile ):
    '''Generate bed file of 500 random intervals of normal size (<2kb)'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.bed" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct b.gene_id
               FROM (SELECT distinct s.closest_id, i.interval_id, i.contig, i.start, i.end, i.length, i.avgval, i.fold, o.genes_pover1, o.genes_pover2
               FROM %(track)s_replicated_intervals i, %(track)s_replicated_%(geneset_name)s_transcript_tss_distance s, 
               %(track)s_replicated_%(geneset_name)s_overlap o
               WHERE  i.interval_id=s.gene_id
               AND o.gene_id=i.interval_id
               AND i.length < 2000
               AND o.genes_pover2 > 0) a,
               (SELECT "%%" || transcript_id || "%%" as pattern, t.gene_id, t.gene_biotype 
               FROM annotations.transcript_info t
               WHERE t.gene_biotype='protein_coding') b
               WHERE a.closest_id like b.pattern  
               ORDER BY RANDOM()
               LIMIT 500''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( (getLongIntervalGeneList, getShortIntervalGeneList, getGeneOverlapGeneList), suffix(".genelist"), ".gtf.gz" )
def getLongIntervalGeneGTF( infile, outfile ):
    '''Filter  GTF file using list of  gene ids associated with long CAPseq intervals '''
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    statement = '''zcat %(gene_file)s 
                   | python %(scriptsdir)s/gtf2gtf.py --filter=gene --apply=%(infile)s --log=%(outfile)s.log
                   | python %(scriptsdir)s/gtf2gtf.py --join-exons --log=%(outfile)s.log
                   | sed s/\\\\ttranscript\\\\t/\\\\texon\\\\t/g 
                   | gzip > %(outfile)s; '''
    P.run()

############################################################
############################################################
## CAPseq profile over long and short capseq interval genes
@follows(getLongIntervalGeneGTF)
@transform( "../merged_bams/*.merge.bam", regex(r"../merged_bams/(\S+).merge.bam"), r"long_intervals/\1.long_interval_genes.capseq_profile.log" )    
def longIntervalGeneCAPseqProfile(infile, outfile):
    '''plot CAPseq profiles over long intervals'''
    track = P.snip( os.path.basename(infile), ".merge.bam" )
    ofp = P.snip( outfile, ".log" )
    capseq = "long_intervals/"+track+".long.gtf.gz"
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(infile)s 
                           --gtffile=%(capseq)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none'''
    P.run() 

############################################################
@follows(getLongIntervalGeneGTF)
@transform( "../merged_bams/*.merge.bam", regex(r"../merged_bams/(\S+).merge.bam"), r"long_intervals/\1.gene_overlap.capseq_profile.log" )    
def geneOverlapCAPseqProfile(infile, outfile):
    '''plot CAPseq profiles over long intervals'''
    track = P.snip( os.path.basename(infile), ".merge.bam" )
    ofp = P.snip( outfile, ".log" )
    capseq = "long_intervals/"+track+".gene_overlap.gtf.gz"
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(infile)s 
                           --gtffile=%(capseq)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none'''
    P.run() 

############################################################
@follows(getLongIntervalGeneGTF)
@transform( "../merged_bams/*.merge.bam", regex(r"../merged_bams/(\S+).merge.bam"), r"long_intervals/\1.short_interval_genes.capseq_profile.log" )    
def shortIntervalGeneCAPseqProfile(infile, outfile):
    '''plot CAPseq profiles over long intervals'''
    track = P.snip( os.path.basename(infile), ".merge.bam" )
    ofp = P.snip( outfile, ".log" )
    capseq = "long_intervals/"+track+".short.gtf.gz"
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(infile)s 
                           --gtffile=%(capseq)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none'''
    P.run() 
            
############################################################
## GO analysis    
@follows( mkdir("long_intervals/go") )
@transform( getLongIntervalGeneList, suffix(".long.genelist"), ".long.go" )
def runGOLongGeneLists( infile, outfile ):
    statement = """cat %(infile)s | sed "1igene_id\n" > %(infile)s.header"""
    P.run()
    track = os.path.basename(P.snip(infile,".long.genelist"))
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "long_intervals/go/%s" % track,
                               fg_file = infile+".header",
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full_obo"] ),
                               minimum_counts = PARAMS["go_minimum_counts"] )

############################################################
@follows( runGOLongGeneLists, mkdir("long_intervals/goslim") )
@transform( getLongIntervalGeneList, suffix(".long.genelist"), ".long.goslim" )
def runGOSlimLongGeneLists( infile, outfile ):
    track = os.path.basename(P.snip(infile,".long.genelist"))
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "long_intervals/goslim/%s" % track,
                               fg_file = infile+".header",
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim_obo"]),
                               minimum_counts = PARAMS["go_minimum_counts"] )
                               
############################################################
@transform( runGOLongGeneLists, suffix( ".long.go"), ".long.go.load" )
def loadLongGeneGo( infile, outfile ):
    '''Load GO results for overlapped genes into database'''
    track = os.path.basename(P.snip(infile,".long.go"))
    go_categories = ["biol_process","cell_location","mol_function"]
    for category in go_categories:
        results_file = "long_intervals/go/%(track)s/foreground.%(category)s.withgenes" % locals()
        statement = """cat %(results_file)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_long_go_%(category)s
                         --index=fdr
                         --index=goid
                        > %(outfile)s; """
        P.run()

############################################################
@transform( runGOSlimLongGeneLists, suffix( ".long.goslim"), ".long.goslim.load" )
def loadLongGeneGoslim( infile, outfile ):
    '''Load GO results for overlapped genes into database'''
    track = os.path.basename(P.snip(infile,".long.goslim"))
    go_categories = ["biol_process","cell_location"]
    for category in go_categories:
        results_file = "long_intervals/goslim/%(track)s/foreground.%(category)s.withgenes" % locals()
        statement = """cat %(results_file)s | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_long_goslim_%(category)s
                         --index=fdr
                         --index=goid
                        > %(outfile)s; """
        P.run()  

############################################################    
############################################################
## Analyse long and short CAPseq intervals
@transform( getLongIntervalGeneGTF, suffix(".gtf.gz"), ".chromatin_profile.log" )    
def longIntervalGeneChromatinProfile(infile, outfile):
    '''plot chromatin mark profiles over tissue-specific CAPseq intervals'''
    chromatin = P.asList(PARAMS["bigwig_chromatin"])
    track = P.snip( os.path.basename(infile), ".gtf.gz" )
    if len(chromatin[0]) > 0:
        for bw in chromatin:
            chromatin_track = P.snip( os.path.basename(bw), ".bam" )
            ofp = "long_intervals/" + track + ".genes." + chromatin_track + ".profile"    
            statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(bw)s 
                           --gtffile=%(infile)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none'''
            P.run() 
    else:
        statement = '''touch %(outfile)s '''
        P.run()
        
############################################################
@transform( getLongIntervalGeneGTF, suffix(".gtf.gz"), ".chromatin_profile.log" )    
def shortIntervalGeneChromatinProfile(infile, outfile):
    '''plot chromatin mark profiles over genes with normal length CAPseq intervals'''
    chromatin = P.asList(PARAMS["bigwig_chromatin"])
    track = P.snip( os.path.basename(infile), ".gtf.gz" )
    if len(chromatin[0]) > 0:
        for bw in chromatin:
            chromatin_track = P.snip( os.path.basename(bw), ".bam" )
            ofp = "long_intervals/" + track + ".genes." + chromatin_track + ".profile"    
            statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(bw)s 
                           --gtffile=%(infile)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none'''
            P.run()
    else:
        statement = '''touch %(outfile)s '''
        P.run()
                
############################################################
## Intersection of H3K27Me3 intervals and long interval genes
@transform( getLongIntervalGeneGTF, suffix(".gtf.gz"), ".H3K27Me3.log" )    
def longGeneChromatinIntersection(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    chromatin = P.asList(PARAMS["bed_h3k27me3"])
    track = P.snip(os.path.basename(infile), ".gtf.gz")
    for bed in chromatin:
        chromatin_track = P.snip(os.path.basename(bed), ".bed")
        statement = '''zcat %(infile)s | python %(scriptsdir)s/gff2bed.py --is-gtf > long_intervals/%(track)s.bed;
                       cat long_intervals/%(track)s.bed %(bed)s | awk 'OFS="\\t" {print $1,$2,$3}'
                       | mergeBed -i stdin | awk 'OFS="\\t" {print $1,$2,$3,"merged"NR}' > long_intervals/%(track)s_%(chromatin_track)s.merged.bed;
                       echo "Track" > long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "%(track)s" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "Chromatin_track" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "%(chromatin_track)s" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "Total_merged_intervals" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       cat long_intervals/%(track)s_%(chromatin_track)s.merged.bed | wc -l >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "track_and_chromatin_track" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a long_intervals/%(track)s_%(chromatin_track)s.merged.bed -b long_intervals/%(track)s.bed -u | intersectBed -a stdin -b %(bed)s -u > long_intervals/%(track)s_%(chromatin_track)s.shared.bed; 
                       cat long_intervals/%(track)s_%(chromatin_track)s.shared.bed | wc -l >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "chromatin_track_only" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a long_intervals/%(track)s_%(chromatin_track)s.merged.bed -b long_intervals/%(track)s.bed -v > long_intervals/%(track)s_%(chromatin_track)s.%(chromatin_track)s.unique.bed; 
                       cat long_intervals/%(track)s_%(chromatin_track)s.%(chromatin_track)s.unique.bed | wc -l >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       echo "track_only" >> long_intervals/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a long_intervals/%(track)s_%(chromatin_track)s.merged.bed -b %(bed)s -v > long_intervals/%(track)s_%(chromatin_track)s.%(track)s.unique.bed; 
                       cat long_intervals/%(track)s_%(chromatin_track)s.%(track)s.unique.bed | wc -l >> long_intervals/%(track)s_%(chromatin_track)s.counts;                   
                       sed -i '{N;s/\\n/\\t/g}' long_intervals/%(track)s_%(chromatin_track)s.counts;
                       touch %(outfile)s '''
        P.run()

############################################################
@follows( longGeneChromatinIntersection )
@merge( "long_intervals/*.counts", "long_intervals/h3k27me3.stats" )
def longGeneChromatinIntersectionStats(infiles, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    first = True
    header = ""
    outs = open(outfile, "w")
    for infile in infiles:
        f = open(infile, "r")
        names = []
        values = []
        for line in f:
            name, value = line.split("\t")
            names.append(name.strip())
            values.append(value.strip())
        header = "\t".join(names)+"\n"
        outline = "\t".join(values)+"\n"
        if first:
            outs.write(header)
            first = False
        outs.write(outline)
        f.close()
    outs.close()
    
############################################################
@transform( longGeneChromatinIntersectionStats, suffix(".stats"), ".stats.load" )
def loadLongGeneChromatinIntersection(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=long_intervals_h3k27me3_venn
                    > %(outfile)s"""
    P.run()
    
############################################################
## Compare intervals to external bed files using GAT
@follows( buildGATWorkspace, mkdir("long_intervals/gat/") )
@merge( getLongIntervalGeneGTF, "long_intervals/gat/long_intervals_gat.tsv" )
def runLongGenesGAT(infiles, outfile):
    '''Run genome association tester on bed files '''
    to_cluster = True
    segfiles = ""
    for x in infiles:
        track = P.snip(os.path.basename(x), ".gtf.gz")
        statement = """zcat %(x)s | awk 'OFS="\\t" {print $1,$4-1,$5-1,"%(track)s"}' > long_intervals/gat/%(track)s.bed; """
        P.run()
        segfiles += " --segment-file=long_intervals/gat/%s.bed " % track 

    # External datasets
    annofiles = ""
    chromatin = P.asList(PARAMS["bed_h3k27me3"])
    for y in chromatin:
        track = P.snip(os.path.basename(y), ".bed")
        statement = """cat %(y)s | awk 'OFS="\\t" {print $1,$2,$3,"%(track)s"}' > long_intervals/gat/%(track)s.bed; """
        P.run()
        annofiles +=  "--annotation-file=long_intervals/gat/%s.bed " % track
    statement = """gatrun.py %(segfiles)s %(annofiles)s --workspace=gat/%(genome)s.bed.gz --num-samples=1000 --nbuckets=500000 --bucket-size=10 --force > %(outfile)s"""
    P.run()

############################################################
@transform( runLongGenesGAT, suffix(".tsv"), ".tsv.load" )
def loadLongGenesGAT(infile, outfile):
    '''Load genome association tester results into database '''
    statement = """cat %(infile)s | grep -v "^#" | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=long_intervals_gat_results
                    > %(outfile)s"""
    P.run()
       
        
########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 6b: Identify genes overlapped >90% by CAPseq intervals
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows( mkdir("overlapped_genes") )
@transform( loadGenesetCapseqOverlap, regex(r"(\S+).replicated.genes_capseq_overlap.load"), r"overlapped_genes/\1.overlapped_genes.genelist" )
def getGenesetCapseqOverlapList( infile, outfile ):
    '''Generate text file of all genes overlapped by >90% by CAPseq intervals'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.genes_capseq_overlap.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''select distinct o.gene_id 
               from %(track)s_replicated_%(geneset_name)s_genes_capseq_overlap o, annotations.transcript_info i
               where capseq_pover1>90
               and o.gene_id=i.gene_id
               and o.length > 1000
               order by length desc''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

########################################################################################################################
## Added 24-07-2013 For Hannahs thesis
@follows( mkdir("overlapped_genes") )
@transform( loadGenesetCapseqOverlap, regex(r"(\S+).replicated.genes_capseq_overlap.load"), r"overlapped_genes/\1.overlapped_genes_50.genelist" )
def getGenesetCapseqOverlapList50( infile, outfile ):
    '''Generate text file of all genes overlapped by >50% by CAPseq intervals'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.genes_capseq_overlap.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''select distinct o.gene_id 
               from %(track)s_replicated_%(geneset_name)s_genes_capseq_overlap o, annotations.transcript_info i
               where capseq_pover1>50
               and o.gene_id=i.gene_id
               and o.length > 1000
               order by length desc''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
        
############################################################
@follows( mkdir("overlapped_genes") )
@transform( loadGenesetCapseqOverlap, regex(r"(\S+).replicated.genes_capseq_overlap.load"), r"overlapped_genes/\1.overlapped_genes.control.genelist" )
def getGenesetCapseqOverlapControlList( infile, outfile ):
    '''Generate text file of all genes overlapped by <50% by CAPseq intervals'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    track = P.snip( os.path.basename( infile ), ".replicated.genes_capseq_overlap.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''select distinct o.gene_id 
               from %(track)s_replicated_%(geneset_name)s_genes_capseq_overlap o, annotations.transcript_info i
               where capseq_pover1 >0
               and capseq_pover1 < 10
               and o.gene_id=i.gene_id
               and o.length < 15000
               and o.length > 1000
               order by length desc''' % locals()
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( (getGenesetCapseqOverlapList, getGenesetCapseqOverlapControlList), suffix(".genelist"), ".gtf.gz" )
def getOverlappedGeneGTF( infile, outfile ):
    '''Filter  GTF file using list of  gene ids associated with long CAPseq intervals '''
    gene_file = os.path.join( PARAMS["geneset_dir"], PARAMS["geneset_gene_profile"])
    statement = '''zcat %(gene_file)s 
                   | python %(scriptsdir)s/gtf2gtf.py --filter=gene --apply=%(infile)s --log=%(outfile)s.log
                   | python %(scriptsdir)s/gtf2gtf.py --join-exons --log=%(outfile)s.log
                   | sed s/\\\\ttranscript\\\\t/\\\\texon\\\\t/g 
                   | gzip > %(outfile)s; '''
    P.run()

############################################################
## CAPseq profile over overlapped genes
@follows(getOverlappedGeneGTF)
@transform( "../merged_bams/*.merge.bam", regex(r"../merged_bams/(\S+).merge.bam"), r"overlapped_genes/\1.overlapped_genes.capseq_profile.log" )    
def overlappedGeneCAPseqProfile(infile, outfile):
    '''plot CAPseq profiles over long intervals'''
    track = P.snip( os.path.basename(infile), ".merge.bam" )
    ofp = P.snip( outfile, ".log" )
    capseq = "overlapped_genes/"+track+".overlapped_genes.gtf.gz"
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(infile)s 
                           --gtffile=%(capseq)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none
                           --scale_flank_length=1'''
    P.run() 

############################################################
@follows(getOverlappedGeneGTF)
@transform( "../merged_bams/*.merge.bam", regex(r"../merged_bams/(\S+).merge.bam"), r"overlapped_genes/\1.overlapped_genes.control.capseq_profile.log" )    
def controlGeneCAPseqProfile(infile, outfile):
    '''plot CAPseq profiles over long intervals'''
    track = P.snip( os.path.basename(infile), ".merge.bam" )
    ofp = P.snip( outfile, ".log" )
    capseq = "overlapped_genes/"+track+".overlapped_genes.control.gtf.gz"
    statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(infile)s 
                           --gtffile=%(capseq)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none
                           --scale_flank_length=1'''
    P.run() 
         
############################################################
## Chromatin profile over overlapped genes
@transform( getOverlappedGeneGTF, suffix(".gtf.gz"), ".chromatin_profile.log" )    
def overlappedGeneChromatinProfile(infile, outfile):
    '''plot chromatin mark profiles over CAPSeq overlapped genes'''
    chromatin = P.asList(PARAMS["bigwig_chromatin"])
    track = P.snip( os.path.basename(infile), ".gtf.gz" )
    if len(chromatin[0]) > 0:
        for bw in chromatin:
            chromatin_track = P.snip( os.path.basename(bw), ".bam" )
            ofp = "overlapped_genes/" + track + "." + chromatin_track + ".profile"    
            statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(bw)s 
                           --gtffile=%(infile)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none
                           --scale_flank_length=1'''
            P.run() 
    else:
        statement = '''touch %(outfile)s '''
        P.run()
        
############################################################
## Chromatin profile over overlapped genes
@transform( getOverlappedGeneGTF, suffix(".gtf.gz"), ".chromatin_profile.wide.log" )    
def overlappedGeneChromatinProfileWide(infile, outfile):
    '''plot chromatin mark profiles over CAPSeq overlapped genes'''
    chromatin = P.asList(PARAMS["bigwig_chromatin"])
    track = P.snip( os.path.basename(infile), ".gtf.gz" )
    if len(chromatin[0]) > 0:
        for bw in chromatin:
            chromatin_track = P.snip( os.path.basename(bw), ".bam" )
            ofp = "overlapped_genes/" + track + "." + chromatin_track + ".profile.wide"    
            statement = '''python %(scriptsdir)s/bam2geneprofile.py 
                           --bamfile=%(bw)s 
                           --gtffile=%(infile)s
                           --output-filename-pattern=%(ofp)s
                           --reporter=gene
                           --method=geneprofile
                           --log=%(outfile)s
                           --normalize-profile=area
                           --normalize-profile=counts
                           --normalize-profile=none
                           --scale_flank_length=3'''
            P.run() 
    else:
        statement = '''touch %(outfile)s '''
        P.run()

############################################################
## GO analysis    
@follows( mkdir("overlapped_genes/go") )
@transform( getGenesetCapseqOverlapList, suffix(".overlapped_genes.genelist"), ".overlapped_genes.go" )
def runGOOverlappedGeneLists( infile, outfile ):
    statement = """cat %(infile)s | sed "1igene_id\n" > %(infile)s.header"""
    P.run()
    track = os.path.basename(P.snip(infile,".overlapped_genes.genelist"))
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "overlapped_genes/go/%s" % track,
                               fg_file = infile+".header",
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full_obo"] ),
                               minimum_counts = PARAMS["go_minimum_counts"] )

############################################################
@follows( runGOOverlappedGeneLists, mkdir("overlapped_genes/goslim") )
@transform( getGenesetCapseqOverlapList, suffix(".overlapped_genes.genelist"), ".overlapped_genes.goslim" )
def runGOSlimOverlappedGeneLists( infile, outfile ):
    track = os.path.basename(P.snip(infile,".overlapped_genes.genelist"))
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "overlapped_genes/goslim/%s" % track,
                               fg_file = infile+".header",
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim_obo"]),
                               minimum_counts = PARAMS["go_minimum_counts"] )
                               
############################################################
@transform( runGOOverlappedGeneLists, suffix( ".overlapped_genes.go"), ".overlapped_genes.go.load" )
def loadOverlappedGeneGo( infile, outfile ):
    '''Load GO results for overlapped genes into database'''
    track = os.path.basename(P.snip(infile,".overlapped_genes.go"))
    go_categories = ["biol_process","cell_location","mol_function"]
    for category in go_categories:
        results_file = "overlapped_genes/go/%(track)s/foreground.%(category)s.withgenes" % locals()
        statement = """cat %(results_file)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_overlapped_genes_go_%(category)s
                         --index=fdr
                         --index=goid
                        > %(outfile)s; """
        P.run()

############################################################
@transform( runGOSlimOverlappedGeneLists, suffix( ".overlapped_genes.goslim"), ".overlapped_genes.goslim.load" )
def loadOverlappedGeneGoslim( infile, outfile ):
    '''Load GO results for overlapped genes into database'''
    track = os.path.basename(P.snip(infile,".overlapped_genes.goslim"))
    go_categories = ["biol_process","cell_location"]
    for category in go_categories:
        results_file = "overlapped_genes/goslim/%(track)s/foreground.%(category)s.withgenes" % locals()
        statement = """cat %(results_file)s | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=%(track)s_overlapped_genes_goslim_%(category)s
                         --index=fdr
                         --index=goid
                        > %(outfile)s; """
        P.run()    

############################################################
@follows(runGOOverlappedGeneLists)
@collate( "overlapped_genes/go/*/*.results", regex(r"overlapped_genes/go/(.*)/(.*)\.(.*).results"), r"overlapped_genes/go/\1/\3.revigo" )
def clusterGOResults( infiles, outfile ):
    '''Use revigo to cluster go terms'''
    infiles = " ".join(infiles)
    filename_go = os.path.join( PARAMS["geneset_dir"], PARAMS["go_full"])
    filename_obo = os.path.join( PARAMS["geneset_dir"], PARAMS["go_full_obo_xml"])
    to_cluster = True
    track = P.snip( outfile, ".revigo" )
    statement = '''cat %(infiles)s 
                   | python %(scriptsdir)s/revigo.py 
                      --filename-go=%(filename_go)s
                      --filename-ontology=%(filename_obo)s
                      --output-filename-pattern=%(track)s.%%s 
                      --ontology=all 
                      --max-similarity=0.5
                      --reverse-palette
                      --force 
                      -v 2 
                   > %(outfile)s'''
    P.run()
    
############################################################
## Intersection of H3K27Me3 intervals and overlapped genes
@transform( getOverlappedGeneGTF, suffix(".gtf.gz"), ".H3K27Me3.log" )    
def overlappedGeneChromatinIntersection(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    chromatin = P.asList(PARAMS["bed_h3k27me3"])
    track = P.snip(os.path.basename(infile), ".gtf.gz")
    for bed in chromatin:
        chromatin_track = P.snip(os.path.basename(bed), ".bed")
        statement = '''zcat %(infile)s | python %(scriptsdir)s/gff2bed.py --is-gtf > overlapped_genes/%(track)s.bed;
                       cat overlapped_genes/%(track)s.bed %(bed)s | awk 'OFS="\\t" {print $1,$2,$3}'
                       | mergeBed -i stdin | awk 'OFS="\\t" {print $1,$2,$3,"merged"NR}' > overlapped_genes/%(track)s_%(chromatin_track)s.merged.bed;
                       echo "Track" > overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "%(track)s" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "Chromatin_track" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "%(chromatin_track)s" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "Total_merged_intervals" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       cat overlapped_genes/%(track)s_%(chromatin_track)s.merged.bed | wc -l >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "track_and_chromatin_track" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a overlapped_genes/%(track)s_%(chromatin_track)s.merged.bed -b overlapped_genes/%(track)s.bed -u | intersectBed -a stdin -b %(bed)s -u > overlapped_genes/%(track)s_%(chromatin_track)s.shared.bed; 
                       cat overlapped_genes/%(track)s_%(chromatin_track)s.shared.bed | wc -l >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "chromatin_track_only" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a overlapped_genes/%(track)s_%(chromatin_track)s.merged.bed -b overlapped_genes/%(track)s.bed -v > overlapped_genes/%(track)s_%(chromatin_track)s.%(chromatin_track)s.unique.bed; 
                       cat overlapped_genes/%(track)s_%(chromatin_track)s.%(chromatin_track)s.unique.bed | wc -l >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       echo "track_only" >> overlapped_genes/%(track)s_%(chromatin_track)s.counts; 
                       intersectBed -a overlapped_genes/%(track)s_%(chromatin_track)s.merged.bed -b %(bed)s -v > overlapped_genes/%(track)s_%(chromatin_track)s.%(track)s.unique.bed; 
                       cat overlapped_genes/%(track)s_%(chromatin_track)s.%(track)s.unique.bed | wc -l >> overlapped_genes/%(track)s_%(chromatin_track)s.counts;                   
                       sed -i '{N;s/\\n/\\t/g}' overlapped_genes/%(track)s_%(chromatin_track)s.counts;
                       touch %(outfile)s '''
        P.run()
     
############################################################
@follows( overlappedGeneChromatinIntersection )
@merge( "overlapped_genes/*.counts", "overlapped_genes/h3k27me3.stats" )
def overlappedGeneChromatinIntersectionStats(infiles, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    first = True
    header = ""
    outs = open(outfile, "w")
    for infile in infiles:
        f = open(infile, "r")
        names = []
        values = []
        for line in f:
            name, value = line.split("\t")
            names.append(name.strip())
            values.append(value.strip())
        header = "\t".join(names)+"\n"
        outline = "\t".join(values)+"\n"
        if first:
            outs.write(header)
            first = False
        outs.write(outline)
        f.close()
    outs.close()
    
############################################################
@transform( overlappedGeneChromatinIntersectionStats, suffix(".stats"), ".stats.load" )
def loadOverlappedGeneChromatinIntersection(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=overlapped_genes_h3k27me3_venn
                    > %(outfile)s"""
    P.run()

############################################################
@transform( overlappedGeneChromatinIntersectionStats, suffix(".stats"), ".stats.contingency_table" )
def OverlappedGeneChromatinIntersectionContingencyTable(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    chromatin_track = PARAMS["plots_h3k27_track"]
    track = PARAMS["plots_fig4_tissue"]
    species = PARAMS["species"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    tracks = []
    # Extract data from db
    cc = dbhandle.cursor()
    query = ''' SELECT "Canonical" as interval_type, track_and_chromatin_track as H3K27Me3, track_only as no_H3K27Me3
                FROM overlapped_genes_h3k27me3_venn
                WHERE chromatin_track="%(chromatin_track)s"
                AND track="%(species)s_%(track)s-cap.overlapped_genes.control"
                UNION
                SELECT "Broad" as interval_type, track_and_chromatin_track as H3K27Me3, track_only as no_H3K27Me3
                FROM overlapped_genes_h3k27me3_venn
                WHERE chromatin_track="%(chromatin_track)s"
                AND track="%(species)s_%(track)s-cap.overlapped_genes"''' % locals()
    E.info( query )
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_type\tH3K27Me3\tno_H3K27Me3\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform( OverlappedGeneChromatinIntersectionContingencyTable, regex(r"overlapped_genes/(\S+).stats.contingency_table"), r"overlapped_genes/"+PARAMS["species"]+r"_\1.stats.fisher.test.tsv" )
def OverlappedGeneChromatinIntersectionFisherTest(infile, outfile):
    '''calculate intersection of chromatin marks and CAPSeq overlapped genes'''
    R('''x <- read.table(file='%(infile)s', header=TRUE, stringsAsFactors=FALSE, row.names=1)''' % locals() )
    R('''res <- fisher.test(x)''')
    R('''fisher_result <- data.frame(res[3]$estimate,res[1]$p.value,res[2]$conf.int[1],res[2]$conf.int[2])''')
    R('''colnames(fisher_result) <- c("odds.ratio","p.value","conf.int.low","conf.int.high") ''')
    R('''write.table(fisher_result, file="%(outfile)s", sep="\t", row.names=F) ''' % locals() )
    
############################################################
## Compare intervals to external bed files using GAT
@follows( buildGATWorkspace, mkdir("overlapped_genes/gat/") )
@merge( getOverlappedGeneGTF, "overlapped_genes/gat/overlapped_genes_gat.tsv" )
def runOverlappedGenesGAT(infiles, outfile):
    '''Run genome association tester on bed files '''
    to_cluster = True
    segfiles = ""
    for x in infiles:
        track = P.snip(os.path.basename(x), ".gtf.gz")
        statement = """zcat %(x)s | awk 'OFS="\\t" {print $1,$4-1,$5-1,"%(track)s"}' > overlapped_genes/gat/%(track)s.bed; """
        P.run()
        segfiles += " --segment-file=overlapped_genes/gat/%s.bed " % track 

    # External datasets
    annofiles = ""
    chromatin = P.asList(PARAMS["bed_h3k27me3"])
    for y in chromatin:
        track = P.snip(os.path.basename(y), ".bed")
        statement = """cat %(y)s | awk 'OFS="\\t" {print $1,$2,$3,"%(track)s"}' > overlapped_genes/gat/%(track)s.bed; """
        P.run()
        annofiles +=  "--annotation-file=overlapped_genes/gat/%s.bed " % track
    statement = """gatrun.py %(segfiles)s %(annofiles)s --workspace=gat/%(genome)s.bed.gz --num-samples=1000 --nbuckets=500000 --bucket-size=10 --force > %(outfile)s"""
    P.run()

############################################################
@transform( runOverlappedGenesGAT, suffix(".tsv"), ".tsv.load" )
def loadOverlappedGenesGAT(infile, outfile):
    '''Load genome association tester results into database '''
    statement = """cat %(infile)s | grep -v "^#" | python %(scriptsdir)s/csv2db.py
                         --database=%(database)s
                         --table=overlapped_genes_gat_results
                    > %(outfile)s"""
    P.run()
        
########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 7: Identify and annotate liver and testes tissue specific intervals
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows(copyCapseqReplicatedBedFiles, mkdir("liver_vs_testes") )
@files( (PARAMS["compare_liver_pattern"]+".replicated.bed", PARAMS["compare_testes_pattern"]+".replicated.bed"), "liver_vs_testes/liver.testes.venn" )
def liverTestesVenn(infiles, outfile):
    '''identify interval overlap between liver and testes. Merge intervals first.'''
    liver, testes = infiles
    liver_name = P.snip( os.path.basename(liver), ".bed" )
    testes_name = P.snip( os.path.basename(testes), ".bed" )
    to_cluster = True
    
    statement = '''cat %(liver)s %(testes)s | mergeBed -i stdin | awk 'OFS="\\t" {print $1,$2,$3,"merged"NR}' > liver_vs_testes/liver.testes.merge.bed;
                   echo "Total merged intervals" > %(outfile)s; 
                   cat liver_vs_testes/liver.testes.merge.bed | wc -l >> %(outfile)s; 
                   echo "Liver & testes" >> %(outfile)s; 
                   intersectBed -a liver_vs_testes/liver.testes.merge.bed -b %(liver)s -u | intersectBed -a stdin -b %(testes)s -u > liver_vs_testes/liver.testes.shared.bed; 
                   cat liver_vs_testes/liver.testes.shared.bed | wc -l >> %(outfile)s; 
                   echo "Testes only" >> %(outfile)s; 
                   intersectBed -a liver_vs_testes/liver.testes.merge.bed -b %(liver)s -v > liver_vs_testes/%(testes_name)s.liver.testes.unique.bed; 
                   cat liver_vs_testes/%(testes_name)s.liver.testes.unique.bed | wc -l >> %(outfile)s; 
                   echo "Liver only" >> %(outfile)s; 
                   intersectBed -a liver_vs_testes/liver.testes.merge.bed -b %(testes)s -v > liver_vs_testes/%(liver_name)s.liver.testes.unique.bed; 
                   cat liver_vs_testes/%(liver_name)s.liver.testes.unique.bed | wc -l >> %(outfile)s;                   
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; '''
    P.run()

############################################################    
@follows(copyCapseqReplicatedBedFiles, mkdir("liver_vs_testes") )
@files( (PARAMS["compare_liver_pattern"]+".replicated.bed", PARAMS["compare_testes_pattern"]+".replicated.bed"), ("liver_vs_testes/liver_nmi.liver.testes.shared.bed", "liver_vs_testes/testes_nmi.liver.testes.shared.bed", "liver_vs_testes/liver_nmi.liver.testes.uniq.bed", "liver_vs_testes/testes_nmi.liver.testes.uniq.bed") )
def liverTestesCompare(infiles, outfile):
    '''identify interval overlap between liver and testes. Merge intervals first.'''
    liver, testes = infiles
    to_cluster = False
    
    statement = '''intersectBed -a %(liver)s -b %(testes)s -u > liver_vs_testes/liver_nmi.liver.testes.shared.bed;
                   intersectBed -a %(testes)s -b %(liver)s -u > liver_vs_testes/testes_nmi.liver.testes.shared.bed;
                   intersectBed -a %(liver)s -b %(testes)s -v > liver_vs_testes/liver_nmi.liver.testes.uniq.bed;
                   intersectBed -a %(testes)s -b %(liver)s -v > liver_vs_testes/testes_nmi.liver.testes.uniq.bed; ''' % locals()
    P.run()
        
############################################################    
@transform( liverTestesVenn, suffix(".venn"), ".venn.load" )
def loadLiverTestesVenn(infile, outfile):
    '''Load liver testes venn overlap into database '''
    header = "category,intervals"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=liver_testes_venn
                      --header=%(header)s
                   > %(outfile)s '''
    P.run()
    
############################################################    
@follows(copyCapseqReplicatedBedFiles, exportCapseqIntergenicBed)
@files( (PARAMS["compare_liver_pattern"]+".replicated.intergenic.bed", PARAMS["compare_testes_pattern"]+".replicated.intergenic.bed"), "liver_vs_testes/liver.testes.intergenic.venn" )
def liverTestesIntergenicVenn(infiles, outfile):
    '''identify interval overlap between liver and testes for non-TSS associated intervals. Merge intervals first.'''
    liver, testes = infiles
    to_cluster = True
    statement = '''cat %(liver)s %(testes)s | mergeBed -i stdin > liver_vs_testes/liver.testes.intergenic.merge.bed;
                   echo "Total merged intervals" > %(outfile)s; cat liver_vs_testes/liver.testes.intergenic.merge.bed | wc -l >> %(outfile)s; 
                   echo "Liver & testes" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.intergenic.merge.bed -b %(liver)s -u | intersectBed -a stdin -b %(testes)s -u | wc -l >> %(outfile)s; 
                   echo "Testes only" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.intergenic.merge.bed -b %(liver)s -v | wc -l >> %(outfile)s; 
                   echo "Liver only" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.intergenic.merge.bed -b %(testes)s -v | wc -l >> %(outfile)s;                   
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; '''
    P.run()
    
############################################################    
@transform( liverTestesIntergenicVenn, suffix(".venn"), ".venn.load" )
def loadLiverTestesIntergenicVenn(infile, outfile):
    '''Load liver testes venn overlap into database '''
    header = "category,intervals"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=liver_testes_intergenic_venn
                      --header=%(header)s
                   > %(outfile)s '''
    P.run() 
    
############################################################   
@follows(liverTestesVenn) 
@files( "liver_vs_testes/liver.testes.shared.bed", "liver_vs_testes/liver.testes.shared.bed.load" )
def loadLiverTestesShared(infile, outfile):
    '''Load liver testes shared intervals into database '''
    header = "contig,start,end,interval_id"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=liver_testes_shared_intervals
                      --header=%(header)s
                   > %(outfile)s '''
    P.run()

############################################################       
@follows(liverTestesVenn) 
@transform( "liver_vs_testes/*.liver.testes.unique.bed", suffix(".liver.testes.unique.bed"),  ".liver.testes.unique.bed.load" )
def loadLiverTestesUnique(infile, outfile):
    '''Load liver testes unique intervals into database '''
    header = "contig,start,end,interval_id"
    track = P.snip(os.path.basename(infile), ".liver.testes.unique.bed")
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=%(track)s_liver_testes_unique_intervals
                      --header=%(header)s
                   > %(outfile)s '''
    P.run()

############################################################       
@follows(liverTestesVenn) 
@files( "liver_vs_testes/liver.testes.merge.bed", "liver_vs_testes/liver.testes.merge.bed.load" )
def loadLiverTestesMerge(infile, outfile):
    '''Load liver testes shared intervals into database '''
    header = "contig,start,end,interval_id"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=liver_testes_merged_intervals
                      --header=%(header)s
                   > %(outfile)s '''
    P.run()

############################################################
@follows(loadLiverTestesShared, loadLiverTestesUnique, loadLiverTestesMerge)
@merge( "liver_vs_testes/*.liver.testes.unique.bed", "liver_vs_testes/liver.testes.merge.sort.bed")
def exportLiverTestesMergeWithSort( infiles, outfile):
    '''Query database to produce a bed file which can be sorted by liver testes unique category and then length'''
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    tracks = []
    for infile in infiles:
        t = P.snip(os.path.basename(infile), ".liver.testes.unique.bed").replace("-","_").replace(".","_")
        tracks.append(t)
    # Extract data from db
    cc = dbhandle.cursor()
    query = '''SELECT m.contig, m.start, m.end, m.interval_id, 
               "sh_" || substr('000000' || (m.end-m.start), -6, 6)  as sort
               FROM liver_testes_merged_intervals m, liver_testes_shared_intervals s 
               WHERE m.interval_id=s.interval_id ''' % locals()
    for i, t in enumerate(tracks):
        query += '''UNION 
                    SELECT m.contig, m.start, m.end, m.interval_id, 
                    "a%(i)s_" || substr('000000' || (m.end-m.start), -6, 6)  as sort
                    FROM liver_testes_merged_intervals m, %(t)s_liver_testes_unique_intervals u%(i)s 
                    WHERE m.interval_id=u%(i)s.interval_id ''' % locals()
    print query
    cc.execute( query )
    # Write to file
    outs = open( outfile, "w")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
############################################################
## Analyse liver/testes tissue specific intervals
@follows( liverTestesVenn )
@files( "liver_vs_testes/liver.testes.merge.bed", "liver_vs_testes/liver.testes.merge.geneset_overlap" )
def annotateLiverTestesMergedGenesetOverlap( infile, outfile ):
    '''classify intervals according to their base pair overlap with respect to different genomic features (genes, TSS, upstream/downstream flanks) '''
    to_cluster = True
    feature_list = P.asList( PARAMS["geneset_feature_list"] )
    outfiles = ""
    first = True
    for feature in feature_list:
        feature_name = P.snip( os.path.basename( feature ), ".gtf" ).replace(".","_")
        outdir = os.path.dirname( outfile )
        outfiles += " %(outfile)s.%(feature_name)s " % locals()
        if first:
            cut_command = "cut -f1,4,5,6,8 "
            first = False
        else:
            cut_command = "cut -f4,5,6 "
        statement = """
                cat %(infile)s
                | python %(scriptsdir)s/bed2gff.py --as-gtf
                | python %(scriptsdir)s/gtf2table.py
		                --counter=overlap
		                --counter=length
		                --log=%(outfile)s.log
		                --filename-gff=%(geneset_dir)s/%(feature)s
		                --genome-file=%(genome_dir)s/%(genome)s
                | %(cut_command)s
                | sed s/nover/%(feature_name)s_nover/g
                | sed s/pover/%(feature_name)s_pover/g
                | sed s/min/length/
                > %(outfile)s.%(feature_name)s"""
        P.run()
    # Paste output together
    statement = '''paste  %(outfiles)s > %(outfile)s'''
    P.run()

############################################################
@transform( annotateLiverTestesMergedGenesetOverlap, suffix(".geneset_overlap"), ".geneset_overlap.load" )
def loadLiverTestesMergedGenesetOverlap( infile, outfile ):
    '''load interval annotations: genome architecture '''
    geneset_name = PARAMS["geneset_name"]
    track= P.snip( os.path.basename(infile), ".geneset_overlap").replace(".","_").replace("-","_")
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=liver_testes_merged_%(geneset_name)s_overlap
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@follows( liverTestesVenn )
@files( "liver_vs_testes/liver.testes.merge.bed", "liver_vs_testes/liver.testes.merge.transcript.tss.distance" )
def annotateLiverTestesMergedTranscriptTSSDistance( infile, outfile ):
    '''Compute distance from CAPseq intervals to nearest transcript TSS'''
    to_cluster = True
    annotation_file = os.path.join( PARAMS["geneset_dir"],PARAMS["geneset_transcript_tss"] )
    statement = """cat < %(infile)s 
                   | python %(scriptsdir)s/bed2gff.py --as-gtf 
	                 | python %(scriptsdir)s/gtf2table.py 
		                   --counter=distance-tss 
		                   --log=%(outfile)s.log 
                       --filename-gff=%(annotation_file)s 
                       --filename-format="bed" 
                   > %(outfile)s"""
    P.run()

############################################################
@transform( annotateLiverTestesMergedTranscriptTSSDistance, suffix( ".transcript.tss.distance"), ".transcript.tss.distance.load" )
def loadLiverTestesMergedTranscriptTSSDistance( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    track= P.snip( os.path.basename(infile), ".transcript.tss.distance").replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python ~/src/csv2db.py 
                         --database=%(database)s
                         --table=liver_testes_merged_%(geneset_name)s_transcript_tss_distance
                         --index=gene_id
                         --index=closest_id
                         --index=id5
                         --index=id3
                 > %(outfile)s; """
    P.run()

############################################################
@transform( loadLiverTestesMergedTranscriptTSSDistance, suffix(".transcript.tss.distance.load"), ".transcript.tss.distance.export" )
def exportLiverTestesTSSTranscriptList( infile, outfile ):
    '''Export liver vs testes tissue specific CAPseq genes '''
    track = P.snip( os.path.basename( infile ), ".transcript.tss.distance.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct t.gene_id, t.closest_id 
               FROM liver_testes_merged_intervals i, 
               liver_testes_merged_%(geneset_name)s_transcript_tss_distance t
               WHERE i.interval_id=t.gene_id
               AND t.closest_dist < 1000 ''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("interval_id\ttranscript_id\n")
    for result in cc:
        pre = ""
        interval_id,transcripts = result
        transcript_list = transcripts.split(",")
        for t in transcript_list:
            outs.write("%s\t%s\n" % (interval_id, str(t)) )
    cc.close()
    outs.close()

############################################################
@transform( exportLiverTestesTSSTranscriptList, suffix( ".transcript.tss.distance.export"), ".transcript.tss.distance.export.load" )
def loadLiverTestesTSSTranscriptList( infile, outfile ):
    '''Load CAPseq interval annotations: distance to transcript transcription start sites '''
    geneset_name = PARAMS["geneset_name"]
    statement = """cat %(infile)s | python %(scriptsdir)s/csv2db.py 
                         --database=%(database)s
                         --table=liver_testes_merged_%(geneset_name)s_interval_transcript_mapping
                         --index=gene_id
                         --index=interval_id
                 > %(outfile)s; """
    P.run()
        
############################################################    
@follows( liverTestesVenn )
@files( "liver_vs_testes/liver.testes.merge.bed", "liver_vs_testes/liver.testes.merge.composition" )
def annotateLiverTesteMergedComposition( infile, outfile ):
    '''Establish the nucleotide composition of tss intervals'''
    to_cluster = True
    statement = """cat %(infile)s | python %(scriptsdir)s/bed2gff.py --as-gtf 
                   | python %(scriptsdir)s/gtf2table.py 
                      	 --counter=composition-cpg
                      	 --log=%(outfile)s.log
                         --genome-file=%(genome_dir)s/%(genome)s
                   > %(outfile)s; """
    P.run()

############################################################
@transform( annotateLiverTesteMergedComposition, suffix( ".composition"), ".composition.load" )
def loadLiverTesteMergedComposition( infile, outfile ):
    '''Load the nucleotide composition of tss intervals'''
    statement = """cat %(infile)s | python ~/src/csv2db.py
                         --database=%(database)s
                         --table=liver_testes_merged_composition
                         --index=gene_id
                 > %(outfile)s; """
    P.run()

############################################################
@follows(copyCapseqReplicatedBedFiles, exportCapseqTSSBed)
@files( (PARAMS["compare_liver_pattern"]+".replicated.transcript.tss.bed", PARAMS["compare_testes_pattern"]+".replicated.transcript.tss.bed"), "liver_vs_testes/liver.testes.transcript.tss.venn" )
def liverTestesTSSVenn(infiles, outfile):
    '''identify interval overlap between liver and testes for TSS associated intervals. Merge intervals first.'''
    liver, testes = infiles
    to_cluster = True
    statement = '''cat %(liver)s %(testes)s | mergeBed -i stdin > liver_vs_testes/liver.testes.tss.merge.bed;
                   echo "Total merged intervals" > %(outfile)s; cat liver_vs_testes/liver.testes.tss.merge.bed | wc -l >> %(outfile)s; 
                   echo "Liver & testes" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.tss.merge.bed -b %(liver)s -u | intersectBed -a stdin -b %(testes)s -u | wc -l >> %(outfile)s; 
                   echo "Testes only" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.tss.merge.bed -b %(liver)s -v | wc -l >> %(outfile)s; 
                   echo "Liver only" >> %(outfile)s; intersectBed -a liver_vs_testes/liver.testes.tss.merge.bed -b %(testes)s -v | wc -l >> %(outfile)s;                   
                   sed -i '{N;s/\\n/\\t/g}' %(outfile)s; '''
    P.run()
    
############################################################    
@transform( liverTestesTSSVenn, suffix(".venn"), ".venn.load" )
def loadLiverTestesTSSVenn(infile, outfile):
    '''Load liver testes venn overlap into database '''
    header = "category,intervals"
    statement = '''cat %(infile)s | python %(scriptsdir)s/csv2db.py
                      --database=%(database)s
                      --table=liver_testes_tss_venn
                      --header=%(header)s
                   > %(outfile)s '''
    P.run() 

############################################################    
@follows( exportLiverTestesMergeWithSort )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"liver_vs_testes/\1.replicated.liver.testes.merge.reads.peakshape.gz" )
def getPeakShapeLiverTestesReads(infile, outfile):
    '''Cluster intervals based on peak shape '''
    track = P.snip( os.path.basename( infile ), ".replicated.bed" )
    bedfile = "liver_vs_testes/liver.testes.merge.sort.bed"
    bamfile = "../merged_bams/%s.merge.bam" % track
    assert os.path.exists( bamfile ), "could not find bamfile %s for track %s" % ( bamfile, track )
    statement = '''python %(scriptsdir)s/bam2peakshape.py %(bamfile)s %(bedfile)s
                       --output-filename-pattern=%(outfile)s.%%s
                       --sort=peak-width
                       --sort=peak-height
                       --sort=interval-width
                       --sort=interval-score
                       --window-size=3000
                       --bin-size=10
                       --normalization=sum
                       --centring-method=reads
                       --force
                       --log=%(outfile)s.log
                   | gzip > %(outfile)s '''
    P.run()

############################################################    
@follows( exportLiverTestesMergeWithSort )
@transform( copyCapseqReplicatedBedFiles, regex(r"(\S+).replicated.bed"), r"liver_vs_testes/\1.replicated.liver.testes.merge.centre.peakshape.gz" )
def getPeakShapeLiverTestesCentre(infile, outfile):
    '''Cluster intervals based on peak shape '''
    track = P.snip( os.path.basename( infile ), ".replicated.bed" )
    bedfile = "liver_vs_testes/liver.testes.merge.sort.bed"
    bamfile = "../merged_bams/%s.merge.bam" % track
    assert os.path.exists( bamfile ), "could not find bamfile %s for track %s" % ( bamfile, track )
    statement = '''python %(scriptsdir)s/bam2peakshape.py %(bamfile)s %(bedfile)s
                       --output-filename-pattern=%(outfile)s.%%s
                       --sort=peak-width
                       --sort=peak-height
                       --sort=interval-width
                       --sort=interval-score
                       --window-size=3000
                       --bin-size=10
                       --normalization=sum
                       --centring-method=middle
                       --force
                       --log=%(outfile)s.log
                   | gzip > %(outfile)s '''
    P.run()
    
############################################################
@follows( liverTestesVenn )
@files( "liver_vs_testes/*.liver.testes.unique.bed", "liver_vs_testes/liver.testes.chromatin.log" )    
def liverTestesUniqueChromatinProfile(infiles, outfile):
    '''plot chromatin mark profiles over tissue-specific CAPseq intervals'''
    chromatin = P.asList(PARAMS["bigwig_chromatin"])
    if len(chromatin[0]) > 0:
        for infile in infiles:
            track = P.snip( os.path.basename(infile), ".liver.testes.unique.bed" )
            outtemp = P.getTempFile()
            tmpfilename = outtemp.name
            for bw in chromatin:
                chromatin_track = P.snip( os.path.basename(bw), ".bam" )
                ofp = "liver_vs_testes/" + track + "." + chromatin_track + ".profile"    
                statement = '''cat %(infile)s | python %(scriptsdir)s/bed2gff.py --as-gtf | gzip > %(tmpfilename)s.gtf.gz;
                               python %(scriptsdir)s/bam2geneprofile.py 
                               --bamfile=%(bw)s 
                               --gtffile=%(tmpfilename)s.gtf.gz
                               --output-filename-pattern=%(ofp)s
                               --reporter=gene
                               --method=intervalprofile
                               --log=%(outfile)s
                               --normalization=total-sum
                               --normalize-profile=area
                               --normalize-profile=counts
                               --normalize-profile=none'''
                P.run() 
    else:
        statement = '''touch %(outfile)s '''
        P.run()
                     
############################################################
############################################################
## Export gene lists
@follows(loadLiverTestesTSSTranscriptList)
@transform( loadLiverTestesUnique, suffix(".liver.testes.unique.bed.load"), ".liver.testes.unique.genelist" )
def exportLiverTestesSpecificCAPseqGenes( infile, outfile ):
    '''Export liver vs testes tissue specific CAPseq genes '''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace("-","_").replace(".","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct a.gene_id 
               FROM %(track)s_liver_testes_unique_intervals u, annotations.transcript_info a,
               liver_testes_merged_%(geneset_name)s_transcript_tss_distance t, liver_testes_merged_intervals i,
               liver_testes_merged_%(geneset_name)s_interval_transcript_mapping m
               WHERE i.interval_id=t.gene_id
               AND i.contig=u.contig
               AND i.start=u.start
               AND t.closest_dist < 1000 
               AND a.gene_biotype='protein_coding'
               AND m.interval_id=t.gene_id
               AND a.transcript_id = m.transcript_id  ''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@follows(loadLiverTestesTSSTranscriptList)
@transform(loadLiverTestesShared, suffix(".shared.bed.load"), ".shared.genelist")
def exportLiverTestesSharedCAPseqGenes( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT distinct a.gene_id 
               FROM liver_testes_shared_intervals s, annotations.transcript_info a,
               liver_testes_merged_%(geneset_name)s_transcript_tss_distance t, liver_testes_merged_intervals i,
               liver_testes_merged_%(geneset_name)s_interval_transcript_mapping m
               WHERE i.interval_id=t.gene_id
               AND i.contig=s.contig
               AND i.start=s.start
               AND t.closest_dist < 1000 
               AND a.gene_biotype='protein_coding'
               AND m.interval_id=t.gene_id
               AND a.transcript_id = m.transcript_id''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
          outs.write("%s%s" % (pre, str(r)) )
          pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
    
############################################################
@follows(liverTestesVenn)
@transform( "liver_vs_testes/*.replicated.liver.testes.unique.bed", suffix(".bed"), ".length" )
def exportLiverTestesUniqueLength( infile, outfile ):
    '''Export length of CAPseq intervals'''
    statement = '''cat %(infile)s | awk '{print $3-$2}' > %(outfile)s'''
    P.run()

############################################################
@follows(liverTestesVenn)
@transform( "liver_vs_testes/liver.testes.shared.bed", suffix(".bed"), ".length" )
def exportLiverTestesSharedLength( infile, outfile ):
    '''Export length of CAPseq intervals'''
    statement = '''cat %(infile)s | awk '{print $3-$2}' > %(outfile)s'''
    P.run()

############################################################
@merge(liverTestesCompare, "liver_testes_lengths.log")
def exportLiverTestesIntervalLengths( infiles, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    for bed in infiles:
        out = bed.replace(".bed",".length")
        statement = '''cat %(bed)s | awk '{print $3-$2}' > %(out)s 2>> %(outfile)s '''
        P.run()

############################################################
@transform(loadLiverTestesUnique, suffix(".unique.bed.load"), ".shared.cpg_obsexp")
def exportLiverTestesSharedCpGObsExp( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    # Extract data from db
    query = '''SELECT CpG_ObsExp
                FROM %(track)s_capseq_composition 
                EXCEPT
                SELECT CpG_ObsExp
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

###########################################################
@transform(loadLiverTestesUnique, suffix(".bed.load"), ".cpg_obsexp")
def exportLiverTestesUniqueCpGObsExp( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT CpG_ObsExp
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform(loadLiverTestesUnique, suffix(".unique.bed.load"), ".shared.gc_content")
def exportLiverTestesSharedGC( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    # Extract data from db
    query = '''SELECT pGC
                FROM %(track)s_capseq_composition 
                EXCEPT
                SELECT pGC
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

###########################################################
@transform(loadLiverTestesUnique, suffix(".bed.load"), ".gc_content")
def exportLiverTestesUniqueGC( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT pGC
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

############################################################
@transform(loadLiverTestesUnique, suffix(".unique.bed.load"), ".shared.cpg_density")
def exportLiverTestesSharedCpGDensity( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    # Extract data from db
    query = '''SELECT pCpG
                FROM %(track)s_capseq_composition 
                EXCEPT
                SELECT pCpG
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()

###########################################################
@transform(loadLiverTestesUnique, suffix(".bed.load"), ".cpg_density")
def exportLiverTestesUniqueCpGDensity( infile, outfile ):
    '''Export list of genes with TSS associated CAPseq intervals in both liver and testes'''
    track = P.snip( os.path.basename( infile ), ".liver.testes.unique.bed.load" ).replace(".","_").replace("-","_")
    geneset_name = PARAMS["geneset_name"]
    # Connect to DB
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = "ATTACH DATABASE '%s' AS annotations; "  % (PARAMS["geneset_database"])
    cc.execute(statement)
    # Extract data from db
    query = '''SELECT pCpG
                FROM %(track)s_capseq_composition c, %(track)s_intervals i, 
                %(track)s_liver_testes_unique_intervals s
                WHERE c.gene_id=i.interval_id
                AND i.contig=s.contig
                AND i.start=s.start''' % locals()
    cc.execute( query )
    E.info( query )
    # Write to file
    outs = open( outfile, "w")
    #outs.write("gene_id\n")
    for result in cc:
        pre = ""
        for r in result:
            outs.write("%s%s" % (pre, str(r)) )
            pre = "\t"
        outs.write("\n")
    cc.close()
    outs.close()
        
############################################################
############################################################
## GO analysis    
@follows( mkdir("liver_vs_testes/go") )
@transform( exportLiverTestesSpecificCAPseqGenes, suffix(".liver.testes.unique.genes.export"), ".liver.testes.unique.genes.go" )
def runGOOnGeneLists( infile, outfile ):
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "liver_vs_testes/go",
                               fg_file = infile,
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_full_obo"] ),
                               minimum_counts = PARAMS["go_minimum_counts"] )

############################################################
@transform( exportLiverTestesSpecificCAPseqGenes, suffix(".liver.testes.unique.genes.export"), ".liver.testes.unique.genes.goslim" )
def runGOSlimOnGeneLists( infile, outfile ):
    PipelineGO.runGOFromFiles( outfile = outfile,
                               outdir = "go",
                               fg_file = infile,
                               bg_file = None,
                               go_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim"] ),
                               ontology_file = os.path.join(PARAMS["geneset_dir"], PARAMS["go_slim_obo"]),
                               minimum_counts = PARAMS["go_minimum_counts"] )

 

########################################################################################################################
########################################################################################################################
########################################################################################################################
## Section 8: Plot paper figures in R
########################################################################################################################
########################################################################################################################
########################################################################################################################
@follows( mkdir("plots") )
@transform(getCapseqCGIOverlapCount, regex(r"(\S+).cgi_overlap"), r"plots/\1.nmi.cgi.venn.pdf")
def plotFigure1b( infile, outfile):
    '''Figure 1b: Venn diagrams of CAPseq NMIs vs UCSC CGIs'''
    track= P.snip( os.path.basename(infile), ".cgi_overlap").replace(".","_").replace("-","_")
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT overlap FROM %(track)s_cgi_venn where track like "%%ucsc%%"''' % locals()
    print statement
    cc.execute( statement )
    overlap=int(cc.fetchone()[0])
    statement = '''SELECT intervals FROM external_interval_sets where bed like "%%ucsc%%"''' % locals()
    print statement
    cc.execute( statement )
    cgi=int(cc.fetchone()[0])
    statement = '''SELECT count(*) FROM %(track)s_intervals ''' % locals()
    print statement
    cc.execute( statement )
    nmi=int(cc.fetchone()[0])
    offset = cgi - overlap
    nmi2 = offset+int(nmi)
    R('''library(VennDiagram) ''')
    R('''CGI <- seq(1,%(cgi)i)''' % locals() )
    R('''NMI <- seq(%(offset)i,%(nmi2)i)''' % locals() )
    R('''x <- list(CGI=CGI,NMI=NMI)''' )
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", fill=c("#EC1C24","#69BC45"), alpha=0.75, label.col=c("darkred", "white", "darkgreen"), cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
    R('''grid.draw(venn)''')
    R('''dev.off()''')

############################################################
@follows( mkdir("plots"), getReplicatedTranscriptTSSProfileCapseq )
@transform("tss-profile/*.replicated.transcript.tss-profile.capseq.counts.tsv.gz", regex(r"tss-profile/(\S+).replicated.transcript.tss-profile.capseq.counts.tsv.gz"), r"plots/\1.combined.tss-profile.pdf")
def plotFigure2b( infile, outfile):
    '''Figure 2b: TSS profiles for CAPseq and non CAPseq genes'''
    capseq = infile
    scriptsdir = PARAMS["scriptsdir"]
    nocapseq = capseq.replace("capseq", "nocapseq")
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''combinedTSSPlot(capseqfile="%(capseq)s", nocapseqfile="%(nocapseq)s", outfile="%(outfile)s", ylimit=c(0,10), scale=1)''' % locals() )
    
############################################################
@follows( mkdir("plots"), getReplicatedTranscriptTSSProfileCapseq )
@transform("tss-profile/*.replicated.gene.tss-profile.capseq.counts.tsv.gz", regex(r"tss-profile/(\S+).replicated.gene.tss-profile.capseq.counts.tsv.gz"), r"plots/\1.combined.gene.tss-profile.pdf")
def plotFigure2bGene( infile, outfile):
    '''Figure 2b: TSS profiles for CAPseq and non CAPseq genes'''
    capseq = infile
    scriptsdir = PARAMS["scriptsdir"]
    nocapseq = capseq.replace("capseq", "nocapseq")
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''combinedTSSPlot(capseqfile="%(capseq)s", nocapseqfile="%(nocapseq)s", outfile="%(outfile)s", ylimit=c(0,10), scale=1)''' % locals() )

############################################################
@follows( mkdir("plots") )
@transform(loadLiverTestesTSSVenn, regex(r"liver_vs_testes/(\S+).load"), r"plots/"+PARAMS["species"]+r"_\1.pdf")
def plotFigure3bTSSVenn( infile, outfile):
    '''Figure 3b: TSS profiles for CAPseq and non CAPseq genes'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT * FROM liver_testes_tss_venn''' % locals()
    print statement
    cc.execute( statement )
    total=int(cc.fetchone()[1])
    liverAndTestes=int(cc.fetchone()[1])
    testes=int(cc.fetchone()[1])
    liver=int(cc.fetchone()[1])
    cc.close()
    liver_total = liver+liverAndTestes
    R('''library(VennDiagram) ''')
    R('''liver <- seq(1,%(liver_total)i)''' % locals() )
    R('''testes <- seq(%(liver)i,%(total)i)''' % locals() )
    R('''x <- list(Liver=liver,Testes=testes)''' )
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", fill=c("#EC1C24","#69BC45"), alpha=0.75, label.col=c("darkred", "white", "darkgreen"), cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
    R('''grid.draw(venn)''')
    R('''dev.off()''')

############################################################
@follows( mkdir("plots") )
@transform(loadLiverTestesIntergenicVenn, regex(r"liver_vs_testes/(\S+).load"), r"plots/"+PARAMS["species"]+r"_\1.pdf")
def plotFigure3bIntergenicVenn( infile, outfile):
    '''Figure 3b: TSS profiles for CAPseq and non CAPseq genes'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''SELECT * FROM liver_testes_intergenic_venn''' % locals()
    print statement
    cc.execute( statement )
    total=int(cc.fetchone()[1])
    liverAndTestes=int(cc.fetchone()[1])
    testes=int(cc.fetchone()[1])
    liver=int(cc.fetchone()[1])
    cc.close()
    liver_total = liver+liverAndTestes
    R('''library(VennDiagram) ''')
    R('''liver <- seq(1,%(liver_total)i)''' % locals() )
    R('''testes <- seq(%(liver)i,%(total)i)''' % locals() )
    R('''x <- list(Liver=liver,Testes=testes)''' )
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", fill=c("#EC1C24","#69BC45"), alpha=0.75, label.col=c("darkred", "white", "darkgreen"), cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
    R('''grid.draw(venn)''')
    R('''dev.off()''')
    
############################################################
@follows( mkdir("plots"),exportLiverTestesIntervalLengths )
@files(("liver_vs_testes/*nmi.liver.testes.shared.length","liver_vs_testes/*nmi.liver.testes.uniq.length"), "plots/"+PARAMS["species"]+".liver.testes.length.pdf")
def plotFigure3Length( infiles, outfile):
    '''Figure 3 supplementary: length of liver and testes unique intervals compared to shared'''
    liver_shared, testes_shared, liver_uniq, testes_uniq = infiles
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''sharesVsUniqueLengthPlot(liver_shared="%(liver_shared)s", liver_unique="%(liver_uniq)s", testes_shared="%(testes_shared)s", testes_unique="%(testes_uniq)s", outfile="%(outfile)s")''' % locals() )

############################################################
@follows( mkdir("plots"),exportLiverTestesUniqueCpGObsExp,exportLiverTestesSharedCpGObsExp )
@files("liver_vs_testes/*.cpg_obsexp", "plots/"+PARAMS["species"]+".liver.testes.cpg_obsexp.pdf")
def plotFigure3CpGObsExp( infiles, outfile):
    '''Figure 3 supplementary: CpG Obs/Exp of liver and testes unique intervals compared to shared'''
    liver_shared, liver_uniq, testes_shared, testes_uniq = infiles
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''sharesVsUniqueCpgPlot(liver_shared="%(liver_shared)s", liver_unique="%(liver_uniq)s", testes_shared="%(testes_shared)s", testes_unique="%(testes_uniq)s", outfile="%(outfile)s")''' % locals() )

############################################################
@follows( mkdir("plots"),exportLiverTestesUniqueGC,exportLiverTestesSharedGC )
@files("liver_vs_testes/*.gc_content", "plots/"+PARAMS["species"]+".liver.testes.gc_content.pdf")
def plotFigure3GC( infiles, outfile):
    '''Figure 3 supplementary: CpG Obs/Exp of liver and testes unique intervals compared to shared'''
    liver_shared, liver_uniq, testes_shared, testes_uniq = infiles
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''sharesVsUniqueCpgPlot(liver_shared="%(liver_shared)s", liver_unique="%(liver_uniq)s", testes_shared="%(testes_shared)s", testes_unique="%(testes_uniq)s", outfile="%(outfile)s", xlabel="GC content", xlimit=c(0,1))''' % locals() )
    
############################################################
@follows( mkdir("plots"),exportLiverTestesUniqueCpGDensity,exportLiverTestesSharedCpGDensity )
@files("liver_vs_testes/*.cpg_density", "plots/"+PARAMS["species"]+".liver.testes.cpg_density.pdf")
def plotFigure3CpGDensity( infiles, outfile):
    '''Figure 3 supplementary: CpG density of liver and testes unique intervals compared to shared'''
    liver_shared, liver_uniq, testes_shared, testes_uniq = infiles
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''sharesVsUniqueCpgPlot(liver_shared="%(liver_shared)s", liver_unique="%(liver_uniq)s", testes_shared="%(testes_shared)s", testes_unique="%(testes_uniq)s", outfile="%(outfile)s", xlabel="CpG Density", xlimit=c(0,0.3))''' % locals() )
            
############################################################
@follows( liverTestesUniqueChromatinProfile, mkdir("plots") )
@merge("liver_vs_testes/"+PARAMS["species"]+"_testes*H3K4Me3-1*profile.area.tsv.gz", r"plots/"+PARAMS["species"]+r"_testes_unique_intervals_H3K4Me3_profile.pdf")
def plotFigure3cH3K4Me3Testes( infiles, outfile):
    '''Figure 3c: Liver and testes H3K4Me3 reads over liver and testes unique intervals'''
    if len(infiles) == 2:
        inlist = "','".join(infiles)
        inlist = "'"+inlist+"'"
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''infiles <- c(%(inlist)s) ''' % locals() )
        R('''liverTestesChromatinPlot(infiles=infiles, outfile="%(outfile)s")''' % locals() )

############################################################
@follows( liverTestesUniqueChromatinProfile, mkdir("plots") )
@merge("liver_vs_testes/"+PARAMS["species"]+"_liver*H3K4Me3-1*profile.area.tsv.gz", r"plots/"+PARAMS["species"]+r"_liver_unique_intervals_H3K4Me3_profile.pdf")
def plotFigure3cH3K4Me3Liver( infiles, outfile):
    '''Figure 3c: Liver and testes H3K4Me3 reads over liver and testes unique intervals'''
    if len(infiles) == 2:
        inlist = "','".join(infiles)
        inlist = "'"+inlist+"'"
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''infiles <- c(%(inlist)s) ''' % locals() )
        R('''liverTestesChromatinPlot(infiles=infiles, outfile="%(outfile)s")''' % locals() )

############################################################
@follows( exportLiverTestesSpecificCAPseqGenes, exportLiverTestesSharedCAPseqGenes, mkdir("plots") )
@merge("liver_vs_testes/*unique.genelist", r"plots/"+PARAMS["species"]+r"_liver_testes_unique_interval_dx_scatter_rpkm.pdf")
def plotFigure3dxScatterRPKM( infiles, outfile):
    '''Figure 3: differential expression of genes with liver and testes specific NMIs'''
    if len(infiles) == 2:
        liver, testes = infiles
        shared = "liver_vs_testes/liver.testes.shared.genelist"
        scriptsdir = PARAMS["scriptsdir"]
        rpkm = PARAMS["expression_rpkm"]
        R('''source("%(scriptsdir)s/R/proj007/rpkm.R") ''' % locals() )
        R('''plot_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(rpkm)s", outfile="%(outfile)s")''' % locals() )
        
############################################################
@follows( exportLiverTestesSpecificCAPseqGenes, exportLiverTestesSharedCAPseqGenes, mkdir("plots") )
@merge("liver_vs_testes/*unique.genelist", r"plots/"+PARAMS["species"]+r"_liver_testes_unique_interval_dx_2fold_rpkm.pdf")
def plotFigure3TwoFolddxRPKM( infiles, outfile):
    '''Figure 3: differential expression of genes with liver and testes specific NMIs'''
    if len(infiles) == 2:
        liver, testes = infiles
        shared = "liver_vs_testes/liver.testes.shared.genelist"
        scriptsdir = PARAMS["scriptsdir"]
        rpkm = PARAMS["expression_rpkm"]
        R('''source("%(scriptsdir)s/R/proj007/rpkm.R") ''' % locals() )
        print '''foldchange_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(rpkm)s", outfile="%(outfile)s")''' % locals()
        R('''foldchange_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(rpkm)s", outfile="%(outfile)s")''' % locals() )
        
############################################################
@follows( exportLiverTestesSpecificCAPseqGenes, exportLiverTestesSharedCAPseqGenes, mkdir("plots") )
@merge("liver_vs_testes/*unique.genelist", r"plots/"+PARAMS["species"]+r"_liver_testes_unique_interval_dx_density_rpkm.pdf")
def plotFigure3dxRPKMDist( infiles, outfile):
    '''Figure 3: differential expression of genes with liver and testes specific NMIs'''
    if len(infiles) == 2:
        liver, testes = infiles
        shared = "liver_vs_testes/liver.testes.shared.genelist"
        scriptsdir = PARAMS["scriptsdir"]
        rpkm = PARAMS["expression_rpkm"]
        R('''source("%(scriptsdir)s/R/proj007/rpkm.R") ''' % locals() )
        R('''density_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(rpkm)s", outfile="%(outfile)s")''' % locals() )

############################################################
@follows( exportLiverTestesSpecificCAPseqGenes, exportLiverTestesSharedCAPseqGenes, mkdir("plots") )
@merge("liver_vs_testes/*unique.genelist", r"plots/"+PARAMS["species"]+r"_liver_testes_unique_interval_dx_scatter_counts.pdf")
def plotFigure3dxScatterReadCounts( infiles, outfile):
    '''Figure 3: differential expression of genes with liver and testes specific NMIs'''
    if len(infiles) == 2:
        liver, testes = infiles
        shared = "liver_vs_testes/liver.testes.shared.genelist"
        scriptsdir = PARAMS["scriptsdir"]
        counts = PARAMS["expression_counts"]
        R('''source("%(scriptsdir)s/R/proj007/rpkm.R") ''' % locals() )
        R('''plot_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(counts)s", outfile="%(outfile)s")''' % locals() )
                
############################################################
@follows( exportLiverTestesSpecificCAPseqGenes, exportLiverTestesSharedCAPseqGenes, mkdir("plots") )
@merge("liver_vs_testes/*unique.genelist", r"plots/"+PARAMS["species"]+r"_liver_testes_unique_interval_dx_boxplot_rpkm.pdf")
def plotFigure3dxBoxplotRPKM( infiles, outfile):
    '''Figure 3: differential expression of genes with liver and testes specific NMIs'''
    if len(infiles) == 2:
        liver, testes = infiles
        shared = "liver_vs_testes/liver.testes.shared.genelist"
        scriptsdir = PARAMS["scriptsdir"]
        rpkm = PARAMS["expression_rpkm"]
        R('''source("%(scriptsdir)s/R/proj007/rpkm.R") ''' % locals() )
        R('''boxplot_rpkm(liver="%(liver)s", testes="%(testes)s", shared="%(shared)s", rpkm="%(rpkm)s", outfile="%(outfile)s")''' % locals() )        
            
############################################################
@follows( overlappedGeneCAPseqProfile, controlGeneCAPseqProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*.capseq_profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_capseq_profile.pdf")
def plotFigure4a( infiles, outfile):
    '''Figure 4a: capseq profile over overlapped genes'''
    overlapped,control = infiles
    species = overlapped[0:2]
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''overlappedGenesProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="NMIs")''' % locals() )

############################################################
@follows( overlappedGeneCAPseqProfile, controlGeneCAPseqProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*.capseq_profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_capseq_profile_smoothed.pdf")
def plotFigure4aSmoothed( infiles, outfile):
    '''Figure 4a: capseq profile over overlapped genes'''
    overlapped,control = infiles
    species = overlapped[0:2]
    scriptsdir = PARAMS["scriptsdir"]
    R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
    R('''overlappedGenesSmoothedProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="NMIs", smooth=0.5)''' % locals() )
    
############################################################
@follows( overlappedGeneChromatinProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"*H3K27Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K27Me3_profile.pdf")
def plotFigure4bK27( infiles, outfile):
    '''Figure 4b: H3K27Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K27Me3")''' % locals() )

############################################################
@follows( overlappedGeneChromatinProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"*H3K27Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K27Me3_profile_smoothed.pdf")
def plotFigure4bK27Smoothed( infiles, outfile):
    '''Figure 4b: H3K27Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesSmoothedProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K27Me3")''' % locals() )

############################################################
@follows( overlappedGeneChromatinProfileWide, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"*H3K27Me3*profile.wide.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K27Me3_profile_wide_smoothed.pdf")
def plotFigure4bK27WideSmoothed( infiles, outfile):
    '''Figure 4b: H3K27Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesSmoothedProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K27Me3", smooth=0.5)''' % locals() )
        
############################################################
@follows( longIntervalGeneChromatinProfile, mkdir("plots") )
@merge("long_intervals/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"*H3K27Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_long_genes_H3K27Me3_profile.pdf")
def plotFigure4bLongGenesK27( infiles, outfile):
    '''Figure 4b: H3K27Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        overlapped,longgenes,shortgenes = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesProfilePlot(overlapped="%(longgenes)s", control="%(shortgenes)s", outfile="%(outfile)s", ylabel="H3K27Me3")''' % locals() )
        
############################################################
@follows( overlappedGeneChromatinProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"-H3K4Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K4Me3_profile.pdf")
def plotFigure4bK4( infiles, outfile):
    '''Figure 4b: H3K4Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K4Me3")''' % locals() )

############################################################
@follows( overlappedGeneChromatinProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"-H3K4Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K4Me3_profile_smoothed.pdf")
def plotFigure4bK4Smoothed( infiles, outfile):
    '''Figure 4b: H3K4Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesSmoothedProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K4Me3", smooth=0.3)''' % locals() )

############################################################
@follows( overlappedGeneChromatinProfile, mkdir("plots") )
@merge("overlapped_genes/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"-H3K4Me3*profile.wide.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_overlapped_genes_H3K4Me3_profile_wide_smoothed.pdf")
def plotFigure4bK4WideSmoothed( infiles, outfile):
    '''Figure 4b: H3K4Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        control,overlapped = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesSmoothedProfilePlot(overlapped="%(overlapped)s", control="%(control)s", outfile="%(outfile)s", ylabel="H3K4Me3")''' % locals() )

############################################################
@follows( longIntervalGeneChromatinProfile, mkdir("plots") )
@merge("long_intervals/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"*_"+PARAMS["plots_fig4_tissue"]+"-H3K4Me3*profile.counts.tsv.gz", "plots/"+PARAMS["species"]+"_"+PARAMS["plots_fig4_tissue"]+"_long_genes_H3K4Me3_profile.pdf")
def plotFigure4bLongGenesK4( infiles, outfile):
    '''Figure 4b: H3K4Me3 profile over overlapped genes'''
    if len(infiles) > 0:
        overlapped,longgenes,shortgenes = infiles
        scriptsdir = PARAMS["scriptsdir"]
        R('''source("%(scriptsdir)s/R/proj007/proj007.R") ''' % locals() )
        R('''overlappedGenesProfilePlot(overlapped="%(longgenes)s", control="%(shortgenes)s", outfile="%(outfile)s", ylabel="H3K4Me3")''' % locals() )
                
############################################################
@follows( mkdir("plots") )
@merge(getGenesetCapseqOverlapList, "plots/"+PARAMS["species"]+"_overlapped_genes_tissue_venn.pdf")
def plotFigure4OverlappedGenesTissueVenn( infiles, outfile):
    '''Figure 4: venn diagram of genes overlapped >90% in different tissues'''
    inlist = "'"+"','".join(infiles)+"'"
    print(inlist)
    R('''library(VennDiagram) ''')
    R('''inlist <- c(%(inlist)s)''' % locals() )
    R('''x <- list()''' )
    R('''listnames <- NULL''' )
    R('''length(x) <- length(inlist)''')
    R('''for ( i in 1:length(inlist)) { x[[i]] <- read.table(file=inlist[i], header=FALSE, stringsAsFactors=FALSE)[,1]; listnames <- c(listnames,inlist[i]); }''' % locals() )
    R('''names(x) <- listnames''')
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", alpha=0.75, cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
    R('''grid.draw(venn)''')
    R('''dev.off()''')
    
    # Convert pdf to png for web
    outfile2 = outfile.replace("pdf","png")
    statement = '''convert %(outfile)s %(outfile2)s'''
    P.run()

############################################################
@follows( mkdir("plots") )
@merge(getLongIntervalGeneList, "plots/"+PARAMS["species"]+"_long_interval_genes_tissue_venn.pdf")
def plotFigure4LongGenesTissueVenn( infiles, outfile):
    '''Figure 4: venn diagram of genes overlapped >90% in different tissues'''
    inlist = "'"+"','".join(infiles)+"'"
    print(inlist)
    R('''library(VennDiagram) ''')
    R('''inlist <- c(%(inlist)s)''' % locals() )
    R('''x <- list()''' )
    R('''listnames <- NULL''' )
    R('''length(x) <- length(inlist)''')
    R('''for ( i in 1:length(inlist)) { x[[i]] <- read.table(file=inlist[i], header=FALSE, stringsAsFactors=FALSE)[,1]; listnames <- c(listnames,inlist[i]); }''' % locals() )
    R('''names(x) <- listnames''')
    R('''pdf(file='%(outfile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
    R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", alpha=0.75, cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
    R('''grid.draw(venn)''')
    R('''dev.off()''')
    
    # Convert pdf to png for web
    outfile2 = outfile.replace("pdf","png")
    statement = '''convert %(outfile)s %(outfile2)s'''
    P.run()
    
############################################################
@follows( mkdir("plots") )
@transform(loadOverlappedGeneChromatinIntersection, regex(r"(\S+).stats.load"), "plots/"+PARAMS["species"]+"_overlapped_genes_h3k27me3_venn.log")
def plotFigure4OverlappedGenesH3K27Me3Venn( infile, outfile):
    '''Figure 4: venn diagram of genes overlapped >90% in different tissues'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''select track, chromatin_track, total_merged_intervals, track_and_chromatin_track, track_only, chromatin_track_only
                   from overlapped_genes_h3k27me3_venn''' % locals()
    print statement
    cc.execute( statement )
    for venn in cc:
        track, chromatin_track, total_merged_intervals, track_and_chromatin_track, track_only, chromatin_track_only = venn
        track = track.replace("_",".").replace("-",".")
        chromatin_track = chromatin_track.replace("_",".").replace("-",".")
        track_total = int(track_and_chromatin_track)+int(track_only)
        total_merged_intervals = int(total_merged_intervals)
        track_only = int(track_only)
        pdffile = "plots/"+track+"."+chromatin_track+".pdf"
        R('''library(VennDiagram) ''')
        R('''track <- seq(1,%(track_total)i)''' % locals() )
        R('''chromatin_track <- seq(%(track_only)i,%(total_merged_intervals)i)''' % locals() )
        R('''x <- list(%(track)s=track,%(chromatin_track)s=chromatin_track)'''  % locals() )
        R('''pdf(file='%(pdffile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
        R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", fill=c("#EC1C24","#69BC45"), alpha=0.75, label.col=c("darkred", "white", "darkgreen"), cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
        R('''grid.draw(venn)''')
        R('''dev.off()''')
    
        # Convert pdf to png for web
        pdffile2 = pdffile.replace("pdf","png")
        statement = '''convert %(pdffile)s %(pdffile2)s'''
        P.run()
    statement = '''touch %(outfile)s'''
    P.run()

############################################################
@follows( mkdir("plots") )
@transform(loadLongGeneChromatinIntersection, regex(r"(\S+).stats.load"), "plots/"+PARAMS["species"]+"_long_interval_genes_h3k27me3_venn.log")
def plotFigure4LongGenesH3K27Me3Venn( infile, outfile):
    '''Figure 4: venn diagram of genes overlapped by NMIs ><3kb in length with H3K27Me3 intervals'''
    dbhandle = sqlite3.connect( PARAMS["database"] )
    cc = dbhandle.cursor()
    statement = '''select track, chromatin_track, total_merged_intervals, track_and_chromatin_track, track_only, chromatin_track_only
                   from long_intervals_h3k27me3_venn''' % locals()
    print statement
    cc.execute( statement )
    for venn in cc:
        track, chromatin_track, total_merged_intervals, track_and_chromatin_track, track_only, chromatin_track_only = venn
        track = track.replace("_",".").replace("-",".")
        chromatin_track = chromatin_track.replace("_",".").replace("-",".")
        track_total = int(track_and_chromatin_track)+int(track_only)
        total_merged_intervals = int(total_merged_intervals)
        track_only = int(track_only)
        pdffile = "plots/"+track+"."+chromatin_track+".pdf"
        R('''library(VennDiagram) ''')
        R('''track <- seq(1,%(track_total)i)''' % locals() )
        R('''chromatin_track <- seq(%(track_only)i,%(total_merged_intervals)i)''' % locals() )
        R('''x <- list(%(track)s=track,%(chromatin_track)s=chromatin_track)'''  % locals() )
        R('''pdf(file='%(pdffile)s', height=8, width=8, onefile=TRUE, family='Helvetica', paper='A4', pointsize=12)''' % locals() )
        R('''venn <- venn.diagram( x, filename=NULL, col="#58595B", fill=c("#EC1C24","#69BC45"), alpha=0.75, label.col=c("darkred", "white", "darkgreen"), cex=2.0, fontfamily="Helvetica", fontface="bold")''' % locals() )
        R('''grid.draw(venn)''')
        R('''dev.off()''')
    
        # Convert pdf to png for web
        pdffile2 = pdffile.replace("pdf","png")
        statement = '''convert %(pdffile)s %(pdffile2)s'''
        P.run()
    statement = '''touch %(outfile)s'''
    P.run()
                                    
############################################################
############################################################
############################################################
## REPORTS
@follows( mkdir( "report" ) )
def build_report():
    '''build report from scratch.'''

    E.info( "starting documentation build process from scratch" )
    P.run_report( clean = True )

############################################################
@follows( mkdir( "report" ) )
def update_report():
    '''update report.'''

    E.info( "updating documentation" )
    P.run_report( clean = False )

############################################################
@files( "report.log", "publish.log")
def publish_report(infile, outfile):
    '''Link bed, bam, wig and report files to web '''
    publish_dir = PARAMS["publish_dir"]
    species = PARAMS["genome"]
    report_dir = os.path.join(publish_dir, species)
    bam_dir = os.path.join(publish_dir, "bam")
    bed_dir = os.path.join(publish_dir, "bed")
    wig_dir = os.path.join(publish_dir, "wig")  
    tss_dir = os.path.join(publish_dir, "tss")
    tss_dist_dir = os.path.join(publish_dir, "tss_distance")
    gc_dir = os.path.join(publish_dir, "gc")
    cgi_dir = os.path.join(publish_dir, "cpg")
    cpg_density_dir = os.path.join(publish_dir, "cpg_density")
    length_dir = os.path.join(publish_dir, "length")
    long_interval_dir = os.path.join(publish_dir, "long_intervals")
    liver_testes_dir = os.path.join(publish_dir, "liver_vs_testes")
    fig_dir = os.path.join(publish_dir, "figures")
    working_dir = os.getcwd()
    capseq_dir = PARAMS["capseq_dir"]
    # create directories if they do not exist
    statement = '''[ -d %(report_dir)s ] || mkdir %(report_dir)s; 
                   [ -d %(bam_dir)s ] || mkdir %(bam_dir)s;
                   [ -d %(bam_dir)s/merged ] || mkdir %(bam_dir)s/merged;
                   [ -d %(bed_dir)s ] || mkdir %(bed_dir)s;
                   [ -d %(bed_dir)s/no_input ] || mkdir %(bed_dir)s/no_input;
                   [ -d %(bed_dir)s/replicates ] || mkdir %(bed_dir)s/replicates;
                   [ -d %(bed_dir)s/tissue_specific ] || mkdir %(bed_dir)s/tissue_specific;
                   [ -d %(bed_dir)s/liver_vs_testes ] || mkdir %(bed_dir)s/liver_vs_testes;
                   [ -d %(wig_dir)s ] || mkdir %(wig_dir)s;
                   [ -d %(wig_dir)s/merged ] || mkdir %(wig_dir)s/merged;
                   [ -d %(tss_dir)s ] || mkdir %(tss_dir)s;
                   [ -d %(tss_dist_dir)s ] || mkdir %(tss_dist_dir)s;
                   [ -d %(gc_dir)s ] || mkdir %(gc_dir)s;
                   [ -d %(cgi_dir)s ] || mkdir %(cgi_dir)s;
                   [ -d %(cpg_density_dir)s ] || mkdir %(cpg_density_dir)s;
                   [ -d %(length_dir)s ] || mkdir %(length_dir)s;
                   [ -d %(long_interval_dir)s ] || mkdir %(long_interval_dir)s;
                   [ -d %(liver_testes_dir)s ] || mkdir %(liver_testes_dir)s;
                   [ -d %(fig_dir)s ] || mkdir %(fig_dir)s;
                   [ -d %(fig_dir)s/Fig1 ] || mkdir %(fig_dir)s/Fig1;
                   [ -d %(fig_dir)s/Fig2 ] || mkdir %(fig_dir)s/Fig2;
                   [ -d %(fig_dir)s/Fig3 ] || mkdir %(fig_dir)s/Fig3;
                   [ -d %(fig_dir)s/Fig4 ] || mkdir %(fig_dir)s/Fig4;'''
    statement += '''cp -rf report/html/* %(report_dir)s > %(outfile)s; '''
    statement += '''cp -sf %(capseq_dir)s/bam/*.norm.bam* %(bam_dir)s >> %(outfile)s;'''
    statement += '''cp -sf %(capseq_dir)s/merged_bams/*.merge.bam* %(bam_dir)s/merged >> %(outfile)s;'''
    statement += '''cp -sf %(capseq_dir)s/macs/with_input/*/*/*.wig.gz %(wig_dir)s >> %(outfile)s; '''
    statement += '''cp -sf %(capseq_dir)s/macs/merged/*/*/*.wig.gz %(wig_dir)s/merged >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/*.replicated.bed %(bed_dir)s >> %(outfile)s;'''    
    statement += '''cp -sf %(capseq_dir)s/intervals/*solo*.bed %(bed_dir)s/no_input >> %(outfile)s; ''' 
    statement += '''cp -sf %(capseq_dir)s/intervals/*.merged.cleaned.bed %(bed_dir)s/replicates >> %(outfile)s; '''
    statement += '''cp -sf %(capseq_dir)s/replicated_intervals/*.replicated.unique.bed %(bed_dir)s/tissue_specific >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/tss-profile/*.tss-profile*.counts.tsv.gz %(tss_dir)s >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/*.replicated.gc.export %(gc_dir)s >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/tss/tss.gene.gc.export %(gc_dir)s/%(species)s.tss.gene.gc.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/tss/tss.transcript.gc.export %(gc_dir)s/%(species)s.tss.transcript.gc.export >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/cgi/cgi.gc.export %(gc_dir)s/%(species)s.cgi.gc.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/*.replicated.cpg.export %(cgi_dir)s >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/tss/tss.gene.cpg.export %(cgi_dir)s/%(species)s.tss.gene.cpg.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/tss/tss.transcript.cpg.export %(cgi_dir)s/%(species)s.tss.transcript.cpg.export >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/cgi/cgi.cpg.export %(cgi_dir)s/%(species)s.cgi.cpg.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/*.replicated.cpg_density.export %(cpg_density_dir)s >> %(outfile)s; '''   
    statement += '''cp -sf %(working_dir)s/tss/tss.gene.cpg_density.export %(cpg_density_dir)s/%(species)s.tss.gene.cpg_density.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/tss/tss.transcript.cpg_density.export %(cpg_density_dir)s/%(species)s.tss.transcript.cpg_density.export >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/cgi/cgi.cpg_density.export %(cpg_density_dir)s/%(species)s.cgi.cpg_density.export >> %(outfile)s; ''' 
    statement += '''cp -sf %(working_dir)s/*.gene.tss.distance %(tss_dist_dir)s >> %(outfile)s; '''     
    statement += '''cp -sf %(working_dir)s/long_intervals/*.capseq_profile.counts.tsv.gz %(long_interval_dir)s >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/liver_vs_testes/*.liver.testes.unique.bed %(bed_dir)s/liver_vs_testes >> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/liver_vs_testes/*.length %(length_dir)s >> %(outfile)s; ''' 
    # Export plots
    statement += '''cp -sf %(working_dir)s/plots/*.nmi.cgi.venn.pdf %(fig_dir)s/Fig1 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*.combined.*tss-profile.pdf %(fig_dir)s/Fig2 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*.liver.testes.length.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*liver.testes.intergenic.venn.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*liver.testes.transcript.tss.venn.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*cpg_obsexp.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*cpg_density.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*gc_content.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    if len(PARAMS["bigwig_chromatin"]) > 0:
        statement += '''cp -sf %(working_dir)s/plots/*unique_intervals_H3K4Me3_profile.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    if len(PARAMS["expression_rpkm"]) > 0:
        statement += '''cp -sf %(working_dir)s/plots/*dx*.pdf %(fig_dir)s/Fig3 2>> %(outfile)s; '''
    statement += '''cp -sf %(working_dir)s/plots/*overlapped_genes_capseq_profile*.pdf %(fig_dir)s/Fig4 2>> %(outfile)s; '''
    if len(PARAMS["bigwig_chromatin"]) > 0:
        statement += '''cp -sf %(working_dir)s/plots/*overlapped_genes_H3K27Me3_profile*.pdf %(fig_dir)s/Fig4 2>> %(outfile)s; '''
        statement += '''cp -sf %(working_dir)s/plots/*overlapped_genes_H3K4Me3_profile*.pdf %(fig_dir)s/Fig4 2>> %(outfile)s; '''
        statement += '''cp -sf %(working_dir)s/plots/*overlapped.genes*.pdf %(fig_dir)s/Fig4 2>> %(outfile)s; '''
        statement += '''cp -sf %(working_dir)s/overlapped_genes/*.fisher.test.tsv %(fig_dir)s/Fig4 2>> %(outfile)s; '''
        
    # species-specific datasets - chromatin plots
    if len(PARAMS["bigwig_chromatin"]) > 0:
        statement += '''cp -sf %(working_dir)s/liver_vs_testes/*H3K4Me3*profile*.tsv.gz %(liver_testes_dir)s 2>> %(outfile)s; '''
        statement += '''cp -sf %(working_dir)s/long_intervals/*.profile.counts.tsv.gz %(long_interval_dir)s 2>> %(outfile)s; '''
     
    P.run()

############################################################
############################################################
############################################################
## Pipeline organisation

@follows(annotateCapseqGenesetOverlap,
         loadCapseqGenesetOverlap,
         getCapseqGeneTSSOverlapCount,
         loadCapseqGeneTSSOverlapCount,
         annotateCapseqTranscriptTSSDistance,
         loadCapseqTranscriptTSSDistance,
         exportCapseqTSSTranscriptList,
         loadCapseqTSSTranscriptList,
         annotateCapseqGeneTSSDistance,
         loadCapseqGeneTSSDistance,
         exportCapseqTSSGeneList,
         loadCapseqTSSGeneList,
         exportCapseqTSSBed,
         exportCapseqIntergenicBed,
         getCapseqNoncodingTSSDistance,
         loadCapseqNoncodingTSSDistance,
         exportCapseqNoncodingTSSGeneList,
         loadCapseqNoncodingTSSGeneList,
         exportCapseqTranscriptTSSDistanceTranscriptList,
         exportCapseqTranscriptTSSOverlapTranscriptList,
         runGenomicFeaturesGAT,
         loadGenomicFeaturesGAT )
def capseqGeneset():
    '''Annoatate CAPseq intervals using a geneset specified in the ini file'''
    pass

@follows( loadlncRNAs, 
          getCapseqlncRNATSSDistance,
          loadCapseqlncRNATSSDistance,
          exportCapseqlncRNATSSGeneList,
          loadCapseqlncRNATSSGeneList )
def capseqlincRNA():
    '''Annoatate CAPseq intervals using an external lincRNA bed file specified in the ini file'''
    pass

@follows( loadRNAseq,
          getCapseqRNAseqTSSDistance,
          loadCapseqRNAseqTSSDistance,
          exportCapseqRNAseqTSSGeneList,
          loadCapseqRNAseqTSSGeneList )    
def capseqRNAseq():
    '''Annoatate CAPseq intervals using an external RNAseq gtf specified in the ini file'''
    pass
    
@follows(getReplicatedTranscriptTSSProfile,
         getReplicatedTranscriptTSSProfileCapseq,
         getReplicatedTranscriptTSSProfileNoCapseq,
         getReplicatedGeneTSSProfile,
         getReplicatedGeneTSSProfileCapseq,
         getReplicatedGeneTSSProfileNoCapseq,
         getReplicatedTranscriptProfile,
         getReplicatedGeneProfile)
def capseqProfiles():
    '''Calculate CAPseq profile over genes and TSSs using a geneset specified in the ini file'''
    pass      
       
# Section 2
@follows( annotateCapseqComposition,
         loadCapseqComposition,
         annotateControlComposition,
         loadControlComposition,
         annotateFlankingCompositionLeft,
         loadFlankingCompositionLeft,
         annotateFlankingCompositionRight,
         loadFlankingCompositionRight,
         exportCapseqGCProfiles,
         exportCapseqCpGObsExp,
         exportCapseqCpGDensity )
def capseqComposition():
    '''Annotate nucleotide composition of CAPseq intervals and export to text files for plotting'''
    pass

# Section 3
@follows( getCapseqCGIOverlapCount,
         loadCapseqCGIOverlapCount,
         getCGIAndCapseqIntervals,
         loadCGIAndCapseqIntervals,
         getCapseqSpecificIntervals,
         loadCapseqSpecificIntervals,
         getPredictedCGIIntervals,
         loadPredictedCGIIntervals,
         getExternalBedStats,
         loadExternalBedStats,
         getChromatinMarkOverlap,
         loadChromatinMarkIntervals,
         getChipseqOverlap,
         loadChipseqIntervals,
         getCapseqOverlap,
         loadCapseqIntervals,
         buildGATWorkspace,
         runExternalDatasetGAT,
         loadExternalDatasetGAT )
def compareExternal():
    '''Compare intervals external bed files'''
    pass

# Section 4
@follows( loadUCSCPredictedCGIIntervals,
         annotateCGIComposition,
         loadCGIComposition,
         getCGITranscriptTSSOverlapCount,
         loadCGITranscriptTSSOverlapCount,
         getCGIGeneTSSOverlapCount,
         loadCGIGeneTSSOverlapCount,
         annotateCGIGenesetOverlap,
         loadCGIGenesetOverlap,
         exportCGICpGDensity,
         exportCGICpGObsExp,
         exportCGIGCProfiles )
def predictedCGIs():
    '''Annotate predicted CGI intervals'''
    pass

# Section 5
@follows( annotateTranscriptTSSComposition,
         loadTranscriptTSSComposition,
         annotateGeneTSSComposition,
         loadGeneTSSComposition,
         annotateGeneTSSIntervalComposition,
         loadGeneTSSIntervalComposition,
         exportTranscriptTSSCpGDensity,
         exportGeneTSSCpGDensity,
         exportTranscriptTSSCpGObsExp,
         exportGeneTSSCpGObsExp,
         exportTranscriptTSSGCProfiles,
         exportGeneTSSGCProfiles )
def genesetTSSComposition():
    '''Annotate the nucleotide composition of the TSS of the supplied gene set'''
    pass

# Section 6a
@follows( getLongIntervalGeneList,
         getShortIntervalGeneList,
         getLongIntervalGeneGTF,
         longIntervalGeneCAPseqProfile,
         shortIntervalGeneCAPseqProfile,
         runGOLongGeneLists,
         runGOSlimLongGeneLists,
         loadLongGeneGo,
         loadLongGeneGoslim )
def longIntervals():
    '''Annotate long vs short CAPseq intervals'''
    pass

# Section 6a - chromatin
@follows( longIntervalGeneChromatinProfile, 
         shortIntervalGeneChromatinProfile,
         longGeneChromatinIntersection,
         longGeneChromatinIntersectionStats,
         loadLongGeneChromatinIntersection,
         runLongGenesGAT,
         loadLongGenesGAT )
def longIntervalsChromatin():
    '''Annotate long vs short CAPseq intervals'''
    pass
    
# Section 6b
@follows( annotateGenesetCapseqOverlap,
         loadGenesetCapseqOverlap,
         getGenesetCapseqOverlapList,
         getGenesetCapseqOverlapControlList,
         getOverlappedGeneGTF,
         overlappedGeneCAPseqProfile,
         controlGeneCAPseqProfile,
         runGOOverlappedGeneLists,
         runGOSlimOverlappedGeneLists,
         loadOverlappedGeneGo,
         loadOverlappedGeneGoslim,
         clusterGOResults )
def overlappedGenes():
    '''Annotate long vs short CAPseq intervals'''
    pass

# Section 6b - chromatin
@follows( overlappedGeneChromatinProfile,
         overlappedGeneChromatinProfileWide,
         overlappedGeneChromatinIntersection,
         overlappedGeneChromatinIntersectionStats,
         loadOverlappedGeneChromatinIntersection,
         runOverlappedGenesGAT,
         loadOverlappedGenesGAT )
def overlappedGenesChromatin():
    '''Annotate long vs short CAPseq intervals'''
    pass
        
# Section 7
@follows( liverTestesVenn,
         loadLiverTestesVenn,
         liverTestesIntergenicVenn,
         loadLiverTestesIntergenicVenn,
         loadLiverTestesShared,
         loadLiverTestesUnique,
         loadLiverTestesMerge,
         exportLiverTestesMergeWithSort,
         annotateLiverTestesMergedGenesetOverlap,
         loadLiverTestesMergedGenesetOverlap,
         annotateLiverTestesMergedTranscriptTSSDistance,
         loadLiverTestesMergedTranscriptTSSDistance,
         exportLiverTestesTSSTranscriptList,
         loadLiverTestesTSSTranscriptList,
         annotateLiverTesteMergedComposition,
         loadLiverTesteMergedComposition,
         liverTestesTSSVenn,
         loadLiverTestesTSSVenn,
         getPeakShapeLiverTestesReads,
         getPeakShapeLiverTestesCentre,
         liverTestesUniqueChromatinProfile,
         exportLiverTestesSpecificCAPseqGenes,
         exportLiverTestesSharedCAPseqGenes,
         exportLiverTestesUniqueLength,
         exportLiverTestesSharedLength,
         exportLiverTestesSharedCpGObsExp,
         exportLiverTestesUniqueCpGObsExp,
         exportLiverTestesSharedGC,
         exportLiverTestesUniqueGC,
         exportLiverTestesSharedCpGDensity,
         exportLiverTestesUniqueCpGDensity)
def liverTestes():
    '''Annotate liver vs testes specific CAPseq intervals'''
    pass

# Section 8 
@follows( plotFigure1b, 
          plotFigure2b,
          plotFigure3bTSSVenn, 
          plotFigure3bIntergenicVenn,
          plotFigure3Length, 
          plotFigure3CpGObsExp, 
          plotFigure3GC,
          plotFigure3CpGDensity,
          plotFigure3cH3K4Me3Testes,
          plotFigure3cH3K4Me3Liver, 
          plotFigure4a,
          plotFigure4aSmoothed,
          plotFigure4OverlappedGenesTissueVenn )
def figures():
    '''Plot paper figures in R'''
    pass

# Section 8 - histone plots
@follows( plotFigure4bK27, 
          plotFigure4bK27Smoothed,
          plotFigure4bK4,
          plotFigure4bK4Smoothed,
          plotFigure4OverlappedGenesH3K27Me3Venn )
def histoneFigures():
    '''Plot paper figures in R'''
    pass
        
# Section 8 - differential expression
@follows( plotFigure3dxScatterRPKM, 
          plotFigure3dxScatterReadCounts, 
          plotFigure3dxBoxplotRPKM )
def dxFigures():
    '''Plot paper figures in R'''
    pass    

@follows( build_report, publish_report )
def fullReport():
    '''Build and publish report'''
    pass

@follows( capseqGeneset,
          capseqProfiles,
          capseqComposition,
          compareExternal,
          predictedCGIs,
          genesetTSSComposition,
          longIntervals,
          liverTestes)
def full():
    '''Run the full pipeline.'''
    pass

if __name__== "__main__":
    sys.exit( P.main(sys.argv) )
    
